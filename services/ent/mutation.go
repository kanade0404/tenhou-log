// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/kanade0404/tenhou-log/services/ent/call"
	"github.com/kanade0404/tenhou-log/services/ent/chakan"
	"github.com/kanade0404/tenhou-log/services/ent/chii"
	"github.com/kanade0404/tenhou-log/services/ent/compressedmjlog"
	"github.com/kanade0404/tenhou-log/services/ent/concealedkan"
	"github.com/kanade0404/tenhou-log/services/ent/dan"
	"github.com/kanade0404/tenhou-log/services/ent/discard"
	"github.com/kanade0404/tenhou-log/services/ent/drawn"
	"github.com/kanade0404/tenhou-log/services/ent/event"
	"github.com/kanade0404/tenhou-log/services/ent/game"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayer"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerhandhai"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerpoint"
	"github.com/kanade0404/tenhou-log/services/ent/hand"
	"github.com/kanade0404/tenhou-log/services/ent/meldedkan"
	"github.com/kanade0404/tenhou-log/services/ent/mjlog"
	"github.com/kanade0404/tenhou-log/services/ent/mjlogfile"
	"github.com/kanade0404/tenhou-log/services/ent/player"
	"github.com/kanade0404/tenhou-log/services/ent/pon"
	"github.com/kanade0404/tenhou-log/services/ent/predicate"
	"github.com/kanade0404/tenhou-log/services/ent/reach"
	"github.com/kanade0404/tenhou-log/services/ent/room"
	"github.com/kanade0404/tenhou-log/services/ent/round"
	"github.com/kanade0404/tenhou-log/services/ent/turn"
	"github.com/kanade0404/tenhou-log/services/ent/win"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCall              = "Call"
	TypeChakan            = "Chakan"
	TypeChii              = "Chii"
	TypeCompressedMJLog   = "CompressedMJLog"
	TypeConcealedKan      = "ConcealedKan"
	TypeDan               = "Dan"
	TypeDiscard           = "Discard"
	TypeDrawn             = "Drawn"
	TypeEvent             = "Event"
	TypeGame              = "Game"
	TypeGamePlayer        = "GamePlayer"
	TypeGamePlayerHandHai = "GamePlayerHandHai"
	TypeGamePlayerPoint   = "GamePlayerPoint"
	TypeHand              = "Hand"
	TypeMJLog             = "MJLog"
	TypeMJLogFile         = "MJLogFile"
	TypeMeldedKan         = "MeldedKan"
	TypePlayer            = "Player"
	TypePon               = "Pon"
	TypeReach             = "Reach"
	TypeRoom              = "Room"
	TypeRound             = "Round"
	TypeTurn              = "Turn"
	TypeWin               = "Win"
)

// CallMutation represents an operation that mutates the Call nodes in the graph.
type CallMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	clearedFields       map[string]struct{}
	event               *uuid.UUID
	clearedevent        bool
	discard             *uuid.UUID
	cleareddiscard      bool
	chii                *uuid.UUID
	clearedchii         bool
	chakan              *uuid.UUID
	clearedchakan       bool
	concealedkan        *uuid.UUID
	clearedconcealedkan bool
	meldedkan           *uuid.UUID
	clearedmeldedkan    bool
	pon                 *uuid.UUID
	clearedpon          bool
	done                bool
	oldValue            func(context.Context) (*Call, error)
	predicates          []predicate.Call
}

var _ ent.Mutation = (*CallMutation)(nil)

// callOption allows management of the mutation configuration using functional options.
type callOption func(*CallMutation)

// newCallMutation creates new mutation for the Call entity.
func newCallMutation(c config, op Op, opts ...callOption) *CallMutation {
	m := &CallMutation{
		config:        c,
		op:            op,
		typ:           TypeCall,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCallID sets the ID field of the mutation.
func withCallID(id uuid.UUID) callOption {
	return func(m *CallMutation) {
		var (
			err   error
			once  sync.Once
			value *Call
		)
		m.oldValue = func(ctx context.Context) (*Call, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Call.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCall sets the old Call of the mutation.
func withCall(node *Call) callOption {
	return func(m *CallMutation) {
		m.oldValue = func(context.Context) (*Call, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CallMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CallMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Call entities.
func (m *CallMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CallMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CallMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Call.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *CallMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *CallMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *CallMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *CallMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *CallMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *CallMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetDiscardID sets the "discard" edge to the Discard entity by id.
func (m *CallMutation) SetDiscardID(id uuid.UUID) {
	m.discard = &id
}

// ClearDiscard clears the "discard" edge to the Discard entity.
func (m *CallMutation) ClearDiscard() {
	m.cleareddiscard = true
}

// DiscardCleared reports if the "discard" edge to the Discard entity was cleared.
func (m *CallMutation) DiscardCleared() bool {
	return m.cleareddiscard
}

// DiscardID returns the "discard" edge ID in the mutation.
func (m *CallMutation) DiscardID() (id uuid.UUID, exists bool) {
	if m.discard != nil {
		return *m.discard, true
	}
	return
}

// DiscardIDs returns the "discard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscardID instead. It exists only for internal usage by the builders.
func (m *CallMutation) DiscardIDs() (ids []uuid.UUID) {
	if id := m.discard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscard resets all changes to the "discard" edge.
func (m *CallMutation) ResetDiscard() {
	m.discard = nil
	m.cleareddiscard = false
}

// SetChiiID sets the "chii" edge to the Chii entity by id.
func (m *CallMutation) SetChiiID(id uuid.UUID) {
	m.chii = &id
}

// ClearChii clears the "chii" edge to the Chii entity.
func (m *CallMutation) ClearChii() {
	m.clearedchii = true
}

// ChiiCleared reports if the "chii" edge to the Chii entity was cleared.
func (m *CallMutation) ChiiCleared() bool {
	return m.clearedchii
}

// ChiiID returns the "chii" edge ID in the mutation.
func (m *CallMutation) ChiiID() (id uuid.UUID, exists bool) {
	if m.chii != nil {
		return *m.chii, true
	}
	return
}

// ChiiIDs returns the "chii" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChiiID instead. It exists only for internal usage by the builders.
func (m *CallMutation) ChiiIDs() (ids []uuid.UUID) {
	if id := m.chii; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChii resets all changes to the "chii" edge.
func (m *CallMutation) ResetChii() {
	m.chii = nil
	m.clearedchii = false
}

// SetChakanID sets the "chakan" edge to the Chakan entity by id.
func (m *CallMutation) SetChakanID(id uuid.UUID) {
	m.chakan = &id
}

// ClearChakan clears the "chakan" edge to the Chakan entity.
func (m *CallMutation) ClearChakan() {
	m.clearedchakan = true
}

// ChakanCleared reports if the "chakan" edge to the Chakan entity was cleared.
func (m *CallMutation) ChakanCleared() bool {
	return m.clearedchakan
}

// ChakanID returns the "chakan" edge ID in the mutation.
func (m *CallMutation) ChakanID() (id uuid.UUID, exists bool) {
	if m.chakan != nil {
		return *m.chakan, true
	}
	return
}

// ChakanIDs returns the "chakan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChakanID instead. It exists only for internal usage by the builders.
func (m *CallMutation) ChakanIDs() (ids []uuid.UUID) {
	if id := m.chakan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChakan resets all changes to the "chakan" edge.
func (m *CallMutation) ResetChakan() {
	m.chakan = nil
	m.clearedchakan = false
}

// SetConcealedkanID sets the "concealedkan" edge to the ConcealedKan entity by id.
func (m *CallMutation) SetConcealedkanID(id uuid.UUID) {
	m.concealedkan = &id
}

// ClearConcealedkan clears the "concealedkan" edge to the ConcealedKan entity.
func (m *CallMutation) ClearConcealedkan() {
	m.clearedconcealedkan = true
}

// ConcealedkanCleared reports if the "concealedkan" edge to the ConcealedKan entity was cleared.
func (m *CallMutation) ConcealedkanCleared() bool {
	return m.clearedconcealedkan
}

// ConcealedkanID returns the "concealedkan" edge ID in the mutation.
func (m *CallMutation) ConcealedkanID() (id uuid.UUID, exists bool) {
	if m.concealedkan != nil {
		return *m.concealedkan, true
	}
	return
}

// ConcealedkanIDs returns the "concealedkan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConcealedkanID instead. It exists only for internal usage by the builders.
func (m *CallMutation) ConcealedkanIDs() (ids []uuid.UUID) {
	if id := m.concealedkan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConcealedkan resets all changes to the "concealedkan" edge.
func (m *CallMutation) ResetConcealedkan() {
	m.concealedkan = nil
	m.clearedconcealedkan = false
}

// SetMeldedkanID sets the "meldedkan" edge to the MeldedKan entity by id.
func (m *CallMutation) SetMeldedkanID(id uuid.UUID) {
	m.meldedkan = &id
}

// ClearMeldedkan clears the "meldedkan" edge to the MeldedKan entity.
func (m *CallMutation) ClearMeldedkan() {
	m.clearedmeldedkan = true
}

// MeldedkanCleared reports if the "meldedkan" edge to the MeldedKan entity was cleared.
func (m *CallMutation) MeldedkanCleared() bool {
	return m.clearedmeldedkan
}

// MeldedkanID returns the "meldedkan" edge ID in the mutation.
func (m *CallMutation) MeldedkanID() (id uuid.UUID, exists bool) {
	if m.meldedkan != nil {
		return *m.meldedkan, true
	}
	return
}

// MeldedkanIDs returns the "meldedkan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MeldedkanID instead. It exists only for internal usage by the builders.
func (m *CallMutation) MeldedkanIDs() (ids []uuid.UUID) {
	if id := m.meldedkan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMeldedkan resets all changes to the "meldedkan" edge.
func (m *CallMutation) ResetMeldedkan() {
	m.meldedkan = nil
	m.clearedmeldedkan = false
}

// SetPonID sets the "pon" edge to the Pon entity by id.
func (m *CallMutation) SetPonID(id uuid.UUID) {
	m.pon = &id
}

// ClearPon clears the "pon" edge to the Pon entity.
func (m *CallMutation) ClearPon() {
	m.clearedpon = true
}

// PonCleared reports if the "pon" edge to the Pon entity was cleared.
func (m *CallMutation) PonCleared() bool {
	return m.clearedpon
}

// PonID returns the "pon" edge ID in the mutation.
func (m *CallMutation) PonID() (id uuid.UUID, exists bool) {
	if m.pon != nil {
		return *m.pon, true
	}
	return
}

// PonIDs returns the "pon" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PonID instead. It exists only for internal usage by the builders.
func (m *CallMutation) PonIDs() (ids []uuid.UUID) {
	if id := m.pon; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPon resets all changes to the "pon" edge.
func (m *CallMutation) ResetPon() {
	m.pon = nil
	m.clearedpon = false
}

// Where appends a list predicates to the CallMutation builder.
func (m *CallMutation) Where(ps ...predicate.Call) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CallMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CallMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Call, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CallMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CallMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Call).
func (m *CallMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CallMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CallMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CallMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Call field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Call field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CallMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CallMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CallMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Call numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CallMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CallMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CallMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Call nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CallMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Call field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CallMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.event != nil {
		edges = append(edges, call.EdgeEvent)
	}
	if m.discard != nil {
		edges = append(edges, call.EdgeDiscard)
	}
	if m.chii != nil {
		edges = append(edges, call.EdgeChii)
	}
	if m.chakan != nil {
		edges = append(edges, call.EdgeChakan)
	}
	if m.concealedkan != nil {
		edges = append(edges, call.EdgeConcealedkan)
	}
	if m.meldedkan != nil {
		edges = append(edges, call.EdgeMeldedkan)
	}
	if m.pon != nil {
		edges = append(edges, call.EdgePon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CallMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case call.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case call.EdgeDiscard:
		if id := m.discard; id != nil {
			return []ent.Value{*id}
		}
	case call.EdgeChii:
		if id := m.chii; id != nil {
			return []ent.Value{*id}
		}
	case call.EdgeChakan:
		if id := m.chakan; id != nil {
			return []ent.Value{*id}
		}
	case call.EdgeConcealedkan:
		if id := m.concealedkan; id != nil {
			return []ent.Value{*id}
		}
	case call.EdgeMeldedkan:
		if id := m.meldedkan; id != nil {
			return []ent.Value{*id}
		}
	case call.EdgePon:
		if id := m.pon; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CallMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CallMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CallMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedevent {
		edges = append(edges, call.EdgeEvent)
	}
	if m.cleareddiscard {
		edges = append(edges, call.EdgeDiscard)
	}
	if m.clearedchii {
		edges = append(edges, call.EdgeChii)
	}
	if m.clearedchakan {
		edges = append(edges, call.EdgeChakan)
	}
	if m.clearedconcealedkan {
		edges = append(edges, call.EdgeConcealedkan)
	}
	if m.clearedmeldedkan {
		edges = append(edges, call.EdgeMeldedkan)
	}
	if m.clearedpon {
		edges = append(edges, call.EdgePon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CallMutation) EdgeCleared(name string) bool {
	switch name {
	case call.EdgeEvent:
		return m.clearedevent
	case call.EdgeDiscard:
		return m.cleareddiscard
	case call.EdgeChii:
		return m.clearedchii
	case call.EdgeChakan:
		return m.clearedchakan
	case call.EdgeConcealedkan:
		return m.clearedconcealedkan
	case call.EdgeMeldedkan:
		return m.clearedmeldedkan
	case call.EdgePon:
		return m.clearedpon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CallMutation) ClearEdge(name string) error {
	switch name {
	case call.EdgeEvent:
		m.ClearEvent()
		return nil
	case call.EdgeDiscard:
		m.ClearDiscard()
		return nil
	case call.EdgeChii:
		m.ClearChii()
		return nil
	case call.EdgeChakan:
		m.ClearChakan()
		return nil
	case call.EdgeConcealedkan:
		m.ClearConcealedkan()
		return nil
	case call.EdgeMeldedkan:
		m.ClearMeldedkan()
		return nil
	case call.EdgePon:
		m.ClearPon()
		return nil
	}
	return fmt.Errorf("unknown Call unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CallMutation) ResetEdge(name string) error {
	switch name {
	case call.EdgeEvent:
		m.ResetEvent()
		return nil
	case call.EdgeDiscard:
		m.ResetDiscard()
		return nil
	case call.EdgeChii:
		m.ResetChii()
		return nil
	case call.EdgeChakan:
		m.ResetChakan()
		return nil
	case call.EdgeConcealedkan:
		m.ResetConcealedkan()
		return nil
	case call.EdgeMeldedkan:
		m.ResetMeldedkan()
		return nil
	case call.EdgePon:
		m.ResetPon()
		return nil
	}
	return fmt.Errorf("unknown Call edge %s", name)
}

// ChakanMutation represents an operation that mutates the Chakan nodes in the graph.
type ChakanMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	call          *uuid.UUID
	clearedcall   bool
	done          bool
	oldValue      func(context.Context) (*Chakan, error)
	predicates    []predicate.Chakan
}

var _ ent.Mutation = (*ChakanMutation)(nil)

// chakanOption allows management of the mutation configuration using functional options.
type chakanOption func(*ChakanMutation)

// newChakanMutation creates new mutation for the Chakan entity.
func newChakanMutation(c config, op Op, opts ...chakanOption) *ChakanMutation {
	m := &ChakanMutation{
		config:        c,
		op:            op,
		typ:           TypeChakan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChakanID sets the ID field of the mutation.
func withChakanID(id uuid.UUID) chakanOption {
	return func(m *ChakanMutation) {
		var (
			err   error
			once  sync.Once
			value *Chakan
		)
		m.oldValue = func(ctx context.Context) (*Chakan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chakan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChakan sets the old Chakan of the mutation.
func withChakan(node *Chakan) chakanOption {
	return func(m *ChakanMutation) {
		m.oldValue = func(context.Context) (*Chakan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChakanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChakanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Chakan entities.
func (m *ChakanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChakanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChakanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chakan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallID sets the "call" edge to the Call entity by id.
func (m *ChakanMutation) SetCallID(id uuid.UUID) {
	m.call = &id
}

// ClearCall clears the "call" edge to the Call entity.
func (m *ChakanMutation) ClearCall() {
	m.clearedcall = true
}

// CallCleared reports if the "call" edge to the Call entity was cleared.
func (m *ChakanMutation) CallCleared() bool {
	return m.clearedcall
}

// CallID returns the "call" edge ID in the mutation.
func (m *ChakanMutation) CallID() (id uuid.UUID, exists bool) {
	if m.call != nil {
		return *m.call, true
	}
	return
}

// CallIDs returns the "call" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallID instead. It exists only for internal usage by the builders.
func (m *ChakanMutation) CallIDs() (ids []uuid.UUID) {
	if id := m.call; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCall resets all changes to the "call" edge.
func (m *ChakanMutation) ResetCall() {
	m.call = nil
	m.clearedcall = false
}

// Where appends a list predicates to the ChakanMutation builder.
func (m *ChakanMutation) Where(ps ...predicate.Chakan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChakanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChakanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chakan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChakanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChakanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chakan).
func (m *ChakanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChakanMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChakanMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChakanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Chakan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChakanMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chakan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChakanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChakanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChakanMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Chakan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChakanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChakanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChakanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Chakan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChakanMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Chakan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChakanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.call != nil {
		edges = append(edges, chakan.EdgeCall)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChakanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chakan.EdgeCall:
		if id := m.call; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChakanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChakanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChakanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcall {
		edges = append(edges, chakan.EdgeCall)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChakanMutation) EdgeCleared(name string) bool {
	switch name {
	case chakan.EdgeCall:
		return m.clearedcall
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChakanMutation) ClearEdge(name string) error {
	switch name {
	case chakan.EdgeCall:
		m.ClearCall()
		return nil
	}
	return fmt.Errorf("unknown Chakan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChakanMutation) ResetEdge(name string) error {
	switch name {
	case chakan.EdgeCall:
		m.ResetCall()
		return nil
	}
	return fmt.Errorf("unknown Chakan edge %s", name)
}

// ChiiMutation represents an operation that mutates the Chii nodes in the graph.
type ChiiMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	call          *uuid.UUID
	clearedcall   bool
	done          bool
	oldValue      func(context.Context) (*Chii, error)
	predicates    []predicate.Chii
}

var _ ent.Mutation = (*ChiiMutation)(nil)

// chiiOption allows management of the mutation configuration using functional options.
type chiiOption func(*ChiiMutation)

// newChiiMutation creates new mutation for the Chii entity.
func newChiiMutation(c config, op Op, opts ...chiiOption) *ChiiMutation {
	m := &ChiiMutation{
		config:        c,
		op:            op,
		typ:           TypeChii,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChiiID sets the ID field of the mutation.
func withChiiID(id uuid.UUID) chiiOption {
	return func(m *ChiiMutation) {
		var (
			err   error
			once  sync.Once
			value *Chii
		)
		m.oldValue = func(ctx context.Context) (*Chii, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chii.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChii sets the old Chii of the mutation.
func withChii(node *Chii) chiiOption {
	return func(m *ChiiMutation) {
		m.oldValue = func(context.Context) (*Chii, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChiiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChiiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Chii entities.
func (m *ChiiMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChiiMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChiiMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chii.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallID sets the "call" edge to the Call entity by id.
func (m *ChiiMutation) SetCallID(id uuid.UUID) {
	m.call = &id
}

// ClearCall clears the "call" edge to the Call entity.
func (m *ChiiMutation) ClearCall() {
	m.clearedcall = true
}

// CallCleared reports if the "call" edge to the Call entity was cleared.
func (m *ChiiMutation) CallCleared() bool {
	return m.clearedcall
}

// CallID returns the "call" edge ID in the mutation.
func (m *ChiiMutation) CallID() (id uuid.UUID, exists bool) {
	if m.call != nil {
		return *m.call, true
	}
	return
}

// CallIDs returns the "call" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallID instead. It exists only for internal usage by the builders.
func (m *ChiiMutation) CallIDs() (ids []uuid.UUID) {
	if id := m.call; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCall resets all changes to the "call" edge.
func (m *ChiiMutation) ResetCall() {
	m.call = nil
	m.clearedcall = false
}

// Where appends a list predicates to the ChiiMutation builder.
func (m *ChiiMutation) Where(ps ...predicate.Chii) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChiiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChiiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chii, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChiiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChiiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chii).
func (m *ChiiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChiiMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChiiMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChiiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Chii field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChiiMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Chii field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChiiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChiiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChiiMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Chii numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChiiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChiiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChiiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Chii nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChiiMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Chii field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChiiMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.call != nil {
		edges = append(edges, chii.EdgeCall)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChiiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chii.EdgeCall:
		if id := m.call; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChiiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChiiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChiiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcall {
		edges = append(edges, chii.EdgeCall)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChiiMutation) EdgeCleared(name string) bool {
	switch name {
	case chii.EdgeCall:
		return m.clearedcall
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChiiMutation) ClearEdge(name string) error {
	switch name {
	case chii.EdgeCall:
		m.ClearCall()
		return nil
	}
	return fmt.Errorf("unknown Chii unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChiiMutation) ResetEdge(name string) error {
	switch name {
	case chii.EdgeCall:
		m.ResetCall()
		return nil
	}
	return fmt.Errorf("unknown Chii edge %s", name)
}

// CompressedMJLogMutation represents an operation that mutates the CompressedMJLog nodes in the graph.
type CompressedMJLogMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	name               *string
	size               *uint
	addsize            *int
	inserted_at        *time.Time
	clearedFields      map[string]struct{}
	mjlog_files        *uuid.UUID
	clearedmjlog_files bool
	done               bool
	oldValue           func(context.Context) (*CompressedMJLog, error)
	predicates         []predicate.CompressedMJLog
}

var _ ent.Mutation = (*CompressedMJLogMutation)(nil)

// compressedmjlogOption allows management of the mutation configuration using functional options.
type compressedmjlogOption func(*CompressedMJLogMutation)

// newCompressedMJLogMutation creates new mutation for the CompressedMJLog entity.
func newCompressedMJLogMutation(c config, op Op, opts ...compressedmjlogOption) *CompressedMJLogMutation {
	m := &CompressedMJLogMutation{
		config:        c,
		op:            op,
		typ:           TypeCompressedMJLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompressedMJLogID sets the ID field of the mutation.
func withCompressedMJLogID(id uuid.UUID) compressedmjlogOption {
	return func(m *CompressedMJLogMutation) {
		var (
			err   error
			once  sync.Once
			value *CompressedMJLog
		)
		m.oldValue = func(ctx context.Context) (*CompressedMJLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompressedMJLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompressedMJLog sets the old CompressedMJLog of the mutation.
func withCompressedMJLog(node *CompressedMJLog) compressedmjlogOption {
	return func(m *CompressedMJLogMutation) {
		m.oldValue = func(context.Context) (*CompressedMJLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompressedMJLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompressedMJLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CompressedMJLog entities.
func (m *CompressedMJLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompressedMJLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompressedMJLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompressedMJLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CompressedMJLogMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompressedMJLogMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CompressedMJLog entity.
// If the CompressedMJLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompressedMJLogMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompressedMJLogMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *CompressedMJLogMutation) SetSize(u uint) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *CompressedMJLogMutation) Size() (r uint, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the CompressedMJLog entity.
// If the CompressedMJLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompressedMJLogMutation) OldSize(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *CompressedMJLogMutation) AddSize(u int) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *CompressedMJLogMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *CompressedMJLogMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetInsertedAt sets the "inserted_at" field.
func (m *CompressedMJLogMutation) SetInsertedAt(t time.Time) {
	m.inserted_at = &t
}

// InsertedAt returns the value of the "inserted_at" field in the mutation.
func (m *CompressedMJLogMutation) InsertedAt() (r time.Time, exists bool) {
	v := m.inserted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInsertedAt returns the old "inserted_at" field's value of the CompressedMJLog entity.
// If the CompressedMJLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompressedMJLogMutation) OldInsertedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInsertedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInsertedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsertedAt: %w", err)
	}
	return oldValue.InsertedAt, nil
}

// ResetInsertedAt resets all changes to the "inserted_at" field.
func (m *CompressedMJLogMutation) ResetInsertedAt() {
	m.inserted_at = nil
}

// SetMjlogFilesID sets the "mjlog_files" edge to the MJLogFile entity by id.
func (m *CompressedMJLogMutation) SetMjlogFilesID(id uuid.UUID) {
	m.mjlog_files = &id
}

// ClearMjlogFiles clears the "mjlog_files" edge to the MJLogFile entity.
func (m *CompressedMJLogMutation) ClearMjlogFiles() {
	m.clearedmjlog_files = true
}

// MjlogFilesCleared reports if the "mjlog_files" edge to the MJLogFile entity was cleared.
func (m *CompressedMJLogMutation) MjlogFilesCleared() bool {
	return m.clearedmjlog_files
}

// MjlogFilesID returns the "mjlog_files" edge ID in the mutation.
func (m *CompressedMJLogMutation) MjlogFilesID() (id uuid.UUID, exists bool) {
	if m.mjlog_files != nil {
		return *m.mjlog_files, true
	}
	return
}

// MjlogFilesIDs returns the "mjlog_files" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MjlogFilesID instead. It exists only for internal usage by the builders.
func (m *CompressedMJLogMutation) MjlogFilesIDs() (ids []uuid.UUID) {
	if id := m.mjlog_files; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMjlogFiles resets all changes to the "mjlog_files" edge.
func (m *CompressedMJLogMutation) ResetMjlogFiles() {
	m.mjlog_files = nil
	m.clearedmjlog_files = false
}

// Where appends a list predicates to the CompressedMJLogMutation builder.
func (m *CompressedMJLogMutation) Where(ps ...predicate.CompressedMJLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompressedMJLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompressedMJLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompressedMJLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompressedMJLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompressedMJLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompressedMJLog).
func (m *CompressedMJLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompressedMJLogMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, compressedmjlog.FieldName)
	}
	if m.size != nil {
		fields = append(fields, compressedmjlog.FieldSize)
	}
	if m.inserted_at != nil {
		fields = append(fields, compressedmjlog.FieldInsertedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompressedMJLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case compressedmjlog.FieldName:
		return m.Name()
	case compressedmjlog.FieldSize:
		return m.Size()
	case compressedmjlog.FieldInsertedAt:
		return m.InsertedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompressedMJLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case compressedmjlog.FieldName:
		return m.OldName(ctx)
	case compressedmjlog.FieldSize:
		return m.OldSize(ctx)
	case compressedmjlog.FieldInsertedAt:
		return m.OldInsertedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompressedMJLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompressedMJLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case compressedmjlog.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case compressedmjlog.FieldSize:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case compressedmjlog.FieldInsertedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsertedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompressedMJLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompressedMJLogMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, compressedmjlog.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompressedMJLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case compressedmjlog.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompressedMJLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case compressedmjlog.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown CompressedMJLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompressedMJLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompressedMJLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompressedMJLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CompressedMJLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompressedMJLogMutation) ResetField(name string) error {
	switch name {
	case compressedmjlog.FieldName:
		m.ResetName()
		return nil
	case compressedmjlog.FieldSize:
		m.ResetSize()
		return nil
	case compressedmjlog.FieldInsertedAt:
		m.ResetInsertedAt()
		return nil
	}
	return fmt.Errorf("unknown CompressedMJLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompressedMJLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.mjlog_files != nil {
		edges = append(edges, compressedmjlog.EdgeMjlogFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompressedMJLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case compressedmjlog.EdgeMjlogFiles:
		if id := m.mjlog_files; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompressedMJLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompressedMJLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompressedMJLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmjlog_files {
		edges = append(edges, compressedmjlog.EdgeMjlogFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompressedMJLogMutation) EdgeCleared(name string) bool {
	switch name {
	case compressedmjlog.EdgeMjlogFiles:
		return m.clearedmjlog_files
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompressedMJLogMutation) ClearEdge(name string) error {
	switch name {
	case compressedmjlog.EdgeMjlogFiles:
		m.ClearMjlogFiles()
		return nil
	}
	return fmt.Errorf("unknown CompressedMJLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompressedMJLogMutation) ResetEdge(name string) error {
	switch name {
	case compressedmjlog.EdgeMjlogFiles:
		m.ResetMjlogFiles()
		return nil
	}
	return fmt.Errorf("unknown CompressedMJLog edge %s", name)
}

// ConcealedKanMutation represents an operation that mutates the ConcealedKan nodes in the graph.
type ConcealedKanMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	call          *uuid.UUID
	clearedcall   bool
	done          bool
	oldValue      func(context.Context) (*ConcealedKan, error)
	predicates    []predicate.ConcealedKan
}

var _ ent.Mutation = (*ConcealedKanMutation)(nil)

// concealedkanOption allows management of the mutation configuration using functional options.
type concealedkanOption func(*ConcealedKanMutation)

// newConcealedKanMutation creates new mutation for the ConcealedKan entity.
func newConcealedKanMutation(c config, op Op, opts ...concealedkanOption) *ConcealedKanMutation {
	m := &ConcealedKanMutation{
		config:        c,
		op:            op,
		typ:           TypeConcealedKan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConcealedKanID sets the ID field of the mutation.
func withConcealedKanID(id uuid.UUID) concealedkanOption {
	return func(m *ConcealedKanMutation) {
		var (
			err   error
			once  sync.Once
			value *ConcealedKan
		)
		m.oldValue = func(ctx context.Context) (*ConcealedKan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConcealedKan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConcealedKan sets the old ConcealedKan of the mutation.
func withConcealedKan(node *ConcealedKan) concealedkanOption {
	return func(m *ConcealedKanMutation) {
		m.oldValue = func(context.Context) (*ConcealedKan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConcealedKanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConcealedKanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConcealedKan entities.
func (m *ConcealedKanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConcealedKanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConcealedKanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConcealedKan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallID sets the "call" edge to the Call entity by id.
func (m *ConcealedKanMutation) SetCallID(id uuid.UUID) {
	m.call = &id
}

// ClearCall clears the "call" edge to the Call entity.
func (m *ConcealedKanMutation) ClearCall() {
	m.clearedcall = true
}

// CallCleared reports if the "call" edge to the Call entity was cleared.
func (m *ConcealedKanMutation) CallCleared() bool {
	return m.clearedcall
}

// CallID returns the "call" edge ID in the mutation.
func (m *ConcealedKanMutation) CallID() (id uuid.UUID, exists bool) {
	if m.call != nil {
		return *m.call, true
	}
	return
}

// CallIDs returns the "call" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallID instead. It exists only for internal usage by the builders.
func (m *ConcealedKanMutation) CallIDs() (ids []uuid.UUID) {
	if id := m.call; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCall resets all changes to the "call" edge.
func (m *ConcealedKanMutation) ResetCall() {
	m.call = nil
	m.clearedcall = false
}

// Where appends a list predicates to the ConcealedKanMutation builder.
func (m *ConcealedKanMutation) Where(ps ...predicate.ConcealedKan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConcealedKanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConcealedKanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConcealedKan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConcealedKanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConcealedKanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConcealedKan).
func (m *ConcealedKanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConcealedKanMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConcealedKanMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConcealedKanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ConcealedKan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConcealedKanMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConcealedKan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConcealedKanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConcealedKanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConcealedKanMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ConcealedKan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConcealedKanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConcealedKanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConcealedKanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConcealedKan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConcealedKanMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ConcealedKan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConcealedKanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.call != nil {
		edges = append(edges, concealedkan.EdgeCall)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConcealedKanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case concealedkan.EdgeCall:
		if id := m.call; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConcealedKanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConcealedKanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConcealedKanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcall {
		edges = append(edges, concealedkan.EdgeCall)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConcealedKanMutation) EdgeCleared(name string) bool {
	switch name {
	case concealedkan.EdgeCall:
		return m.clearedcall
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConcealedKanMutation) ClearEdge(name string) error {
	switch name {
	case concealedkan.EdgeCall:
		m.ClearCall()
		return nil
	}
	return fmt.Errorf("unknown ConcealedKan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConcealedKanMutation) ResetEdge(name string) error {
	switch name {
	case concealedkan.EdgeCall:
		m.ResetCall()
		return nil
	}
	return fmt.Errorf("unknown ConcealedKan edge %s", name)
}

// DanMutation represents an operation that mutates the Dan nodes in the graph.
type DanMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	clearedFields       map[string]struct{}
	game_players        map[uuid.UUID]struct{}
	removedgame_players map[uuid.UUID]struct{}
	clearedgame_players bool
	done                bool
	oldValue            func(context.Context) (*Dan, error)
	predicates          []predicate.Dan
}

var _ ent.Mutation = (*DanMutation)(nil)

// danOption allows management of the mutation configuration using functional options.
type danOption func(*DanMutation)

// newDanMutation creates new mutation for the Dan entity.
func newDanMutation(c config, op Op, opts ...danOption) *DanMutation {
	m := &DanMutation{
		config:        c,
		op:            op,
		typ:           TypeDan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDanID sets the ID field of the mutation.
func withDanID(id uuid.UUID) danOption {
	return func(m *DanMutation) {
		var (
			err   error
			once  sync.Once
			value *Dan
		)
		m.oldValue = func(ctx context.Context) (*Dan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDan sets the old Dan of the mutation.
func withDan(node *Dan) danOption {
	return func(m *DanMutation) {
		m.oldValue = func(context.Context) (*Dan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dan entities.
func (m *DanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dan entity.
// If the Dan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DanMutation) ResetName() {
	m.name = nil
}

// AddGamePlayerIDs adds the "game_players" edge to the GamePlayer entity by ids.
func (m *DanMutation) AddGamePlayerIDs(ids ...uuid.UUID) {
	if m.game_players == nil {
		m.game_players = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.game_players[ids[i]] = struct{}{}
	}
}

// ClearGamePlayers clears the "game_players" edge to the GamePlayer entity.
func (m *DanMutation) ClearGamePlayers() {
	m.clearedgame_players = true
}

// GamePlayersCleared reports if the "game_players" edge to the GamePlayer entity was cleared.
func (m *DanMutation) GamePlayersCleared() bool {
	return m.clearedgame_players
}

// RemoveGamePlayerIDs removes the "game_players" edge to the GamePlayer entity by IDs.
func (m *DanMutation) RemoveGamePlayerIDs(ids ...uuid.UUID) {
	if m.removedgame_players == nil {
		m.removedgame_players = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.game_players, ids[i])
		m.removedgame_players[ids[i]] = struct{}{}
	}
}

// RemovedGamePlayers returns the removed IDs of the "game_players" edge to the GamePlayer entity.
func (m *DanMutation) RemovedGamePlayersIDs() (ids []uuid.UUID) {
	for id := range m.removedgame_players {
		ids = append(ids, id)
	}
	return
}

// GamePlayersIDs returns the "game_players" edge IDs in the mutation.
func (m *DanMutation) GamePlayersIDs() (ids []uuid.UUID) {
	for id := range m.game_players {
		ids = append(ids, id)
	}
	return
}

// ResetGamePlayers resets all changes to the "game_players" edge.
func (m *DanMutation) ResetGamePlayers() {
	m.game_players = nil
	m.clearedgame_players = false
	m.removedgame_players = nil
}

// Where appends a list predicates to the DanMutation builder.
func (m *DanMutation) Where(ps ...predicate.Dan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dan).
func (m *DanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DanMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, dan.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dan.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dan.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Dan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Dan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Dan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Dan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DanMutation) ResetField(name string) error {
	switch name {
	case dan.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Dan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.game_players != nil {
		edges = append(edges, dan.EdgeGamePlayers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dan.EdgeGamePlayers:
		ids := make([]ent.Value, 0, len(m.game_players))
		for id := range m.game_players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgame_players != nil {
		edges = append(edges, dan.EdgeGamePlayers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dan.EdgeGamePlayers:
		ids := make([]ent.Value, 0, len(m.removedgame_players))
		for id := range m.removedgame_players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgame_players {
		edges = append(edges, dan.EdgeGamePlayers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DanMutation) EdgeCleared(name string) bool {
	switch name {
	case dan.EdgeGamePlayers:
		return m.clearedgame_players
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DanMutation) ResetEdge(name string) error {
	switch name {
	case dan.EdgeGamePlayers:
		m.ResetGamePlayers()
		return nil
	}
	return fmt.Errorf("unknown Dan edge %s", name)
}

// DiscardMutation represents an operation that mutates the Discard nodes in the graph.
type DiscardMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	reach         *uuid.UUID
	clearedreach  bool
	call          *uuid.UUID
	clearedcall   bool
	draw          *uuid.UUID
	cleareddraw   bool
	done          bool
	oldValue      func(context.Context) (*Discard, error)
	predicates    []predicate.Discard
}

var _ ent.Mutation = (*DiscardMutation)(nil)

// discardOption allows management of the mutation configuration using functional options.
type discardOption func(*DiscardMutation)

// newDiscardMutation creates new mutation for the Discard entity.
func newDiscardMutation(c config, op Op, opts ...discardOption) *DiscardMutation {
	m := &DiscardMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscardID sets the ID field of the mutation.
func withDiscardID(id uuid.UUID) discardOption {
	return func(m *DiscardMutation) {
		var (
			err   error
			once  sync.Once
			value *Discard
		)
		m.oldValue = func(ctx context.Context) (*Discard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Discard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscard sets the old Discard of the mutation.
func withDiscard(node *Discard) discardOption {
	return func(m *DiscardMutation) {
		m.oldValue = func(context.Context) (*Discard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Discard entities.
func (m *DiscardMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscardMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscardMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Discard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReachID sets the "reach" edge to the Reach entity by id.
func (m *DiscardMutation) SetReachID(id uuid.UUID) {
	m.reach = &id
}

// ClearReach clears the "reach" edge to the Reach entity.
func (m *DiscardMutation) ClearReach() {
	m.clearedreach = true
}

// ReachCleared reports if the "reach" edge to the Reach entity was cleared.
func (m *DiscardMutation) ReachCleared() bool {
	return m.clearedreach
}

// ReachID returns the "reach" edge ID in the mutation.
func (m *DiscardMutation) ReachID() (id uuid.UUID, exists bool) {
	if m.reach != nil {
		return *m.reach, true
	}
	return
}

// ReachIDs returns the "reach" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReachID instead. It exists only for internal usage by the builders.
func (m *DiscardMutation) ReachIDs() (ids []uuid.UUID) {
	if id := m.reach; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReach resets all changes to the "reach" edge.
func (m *DiscardMutation) ResetReach() {
	m.reach = nil
	m.clearedreach = false
}

// SetCallID sets the "call" edge to the Call entity by id.
func (m *DiscardMutation) SetCallID(id uuid.UUID) {
	m.call = &id
}

// ClearCall clears the "call" edge to the Call entity.
func (m *DiscardMutation) ClearCall() {
	m.clearedcall = true
}

// CallCleared reports if the "call" edge to the Call entity was cleared.
func (m *DiscardMutation) CallCleared() bool {
	return m.clearedcall
}

// CallID returns the "call" edge ID in the mutation.
func (m *DiscardMutation) CallID() (id uuid.UUID, exists bool) {
	if m.call != nil {
		return *m.call, true
	}
	return
}

// CallIDs returns the "call" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallID instead. It exists only for internal usage by the builders.
func (m *DiscardMutation) CallIDs() (ids []uuid.UUID) {
	if id := m.call; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCall resets all changes to the "call" edge.
func (m *DiscardMutation) ResetCall() {
	m.call = nil
	m.clearedcall = false
}

// SetDrawID sets the "draw" edge to the Drawn entity by id.
func (m *DiscardMutation) SetDrawID(id uuid.UUID) {
	m.draw = &id
}

// ClearDraw clears the "draw" edge to the Drawn entity.
func (m *DiscardMutation) ClearDraw() {
	m.cleareddraw = true
}

// DrawCleared reports if the "draw" edge to the Drawn entity was cleared.
func (m *DiscardMutation) DrawCleared() bool {
	return m.cleareddraw
}

// DrawID returns the "draw" edge ID in the mutation.
func (m *DiscardMutation) DrawID() (id uuid.UUID, exists bool) {
	if m.draw != nil {
		return *m.draw, true
	}
	return
}

// DrawIDs returns the "draw" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DrawID instead. It exists only for internal usage by the builders.
func (m *DiscardMutation) DrawIDs() (ids []uuid.UUID) {
	if id := m.draw; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDraw resets all changes to the "draw" edge.
func (m *DiscardMutation) ResetDraw() {
	m.draw = nil
	m.cleareddraw = false
}

// Where appends a list predicates to the DiscardMutation builder.
func (m *DiscardMutation) Where(ps ...predicate.Discard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Discard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Discard).
func (m *DiscardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscardMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscardMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Discard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscardMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Discard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscardMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscardMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscardMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Discard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscardMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscardMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Discard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscardMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Discard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscardMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.reach != nil {
		edges = append(edges, discard.EdgeReach)
	}
	if m.call != nil {
		edges = append(edges, discard.EdgeCall)
	}
	if m.draw != nil {
		edges = append(edges, discard.EdgeDraw)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discard.EdgeReach:
		if id := m.reach; id != nil {
			return []ent.Value{*id}
		}
	case discard.EdgeCall:
		if id := m.call; id != nil {
			return []ent.Value{*id}
		}
	case discard.EdgeDraw:
		if id := m.draw; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreach {
		edges = append(edges, discard.EdgeReach)
	}
	if m.clearedcall {
		edges = append(edges, discard.EdgeCall)
	}
	if m.cleareddraw {
		edges = append(edges, discard.EdgeDraw)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscardMutation) EdgeCleared(name string) bool {
	switch name {
	case discard.EdgeReach:
		return m.clearedreach
	case discard.EdgeCall:
		return m.clearedcall
	case discard.EdgeDraw:
		return m.cleareddraw
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscardMutation) ClearEdge(name string) error {
	switch name {
	case discard.EdgeReach:
		m.ClearReach()
		return nil
	case discard.EdgeCall:
		m.ClearCall()
		return nil
	case discard.EdgeDraw:
		m.ClearDraw()
		return nil
	}
	return fmt.Errorf("unknown Discard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscardMutation) ResetEdge(name string) error {
	switch name {
	case discard.EdgeReach:
		m.ResetReach()
		return nil
	case discard.EdgeCall:
		m.ResetCall()
		return nil
	case discard.EdgeDraw:
		m.ResetDraw()
		return nil
	}
	return fmt.Errorf("unknown Discard edge %s", name)
}

// DrawnMutation represents an operation that mutates the Drawn nodes in the graph.
type DrawnMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	clearedFields  map[string]struct{}
	event          *uuid.UUID
	clearedevent   bool
	discard        *uuid.UUID
	cleareddiscard bool
	done           bool
	oldValue       func(context.Context) (*Drawn, error)
	predicates     []predicate.Drawn
}

var _ ent.Mutation = (*DrawnMutation)(nil)

// drawnOption allows management of the mutation configuration using functional options.
type drawnOption func(*DrawnMutation)

// newDrawnMutation creates new mutation for the Drawn entity.
func newDrawnMutation(c config, op Op, opts ...drawnOption) *DrawnMutation {
	m := &DrawnMutation{
		config:        c,
		op:            op,
		typ:           TypeDrawn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDrawnID sets the ID field of the mutation.
func withDrawnID(id uuid.UUID) drawnOption {
	return func(m *DrawnMutation) {
		var (
			err   error
			once  sync.Once
			value *Drawn
		)
		m.oldValue = func(ctx context.Context) (*Drawn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Drawn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDrawn sets the old Drawn of the mutation.
func withDrawn(node *Drawn) drawnOption {
	return func(m *DrawnMutation) {
		m.oldValue = func(context.Context) (*Drawn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DrawnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DrawnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Drawn entities.
func (m *DrawnMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DrawnMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DrawnMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Drawn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *DrawnMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *DrawnMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *DrawnMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *DrawnMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *DrawnMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *DrawnMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetDiscardID sets the "discard" edge to the Discard entity by id.
func (m *DrawnMutation) SetDiscardID(id uuid.UUID) {
	m.discard = &id
}

// ClearDiscard clears the "discard" edge to the Discard entity.
func (m *DrawnMutation) ClearDiscard() {
	m.cleareddiscard = true
}

// DiscardCleared reports if the "discard" edge to the Discard entity was cleared.
func (m *DrawnMutation) DiscardCleared() bool {
	return m.cleareddiscard
}

// DiscardID returns the "discard" edge ID in the mutation.
func (m *DrawnMutation) DiscardID() (id uuid.UUID, exists bool) {
	if m.discard != nil {
		return *m.discard, true
	}
	return
}

// DiscardIDs returns the "discard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscardID instead. It exists only for internal usage by the builders.
func (m *DrawnMutation) DiscardIDs() (ids []uuid.UUID) {
	if id := m.discard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscard resets all changes to the "discard" edge.
func (m *DrawnMutation) ResetDiscard() {
	m.discard = nil
	m.cleareddiscard = false
}

// Where appends a list predicates to the DrawnMutation builder.
func (m *DrawnMutation) Where(ps ...predicate.Drawn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DrawnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DrawnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Drawn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DrawnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DrawnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Drawn).
func (m *DrawnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DrawnMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DrawnMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DrawnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Drawn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DrawnMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Drawn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DrawnMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DrawnMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DrawnMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Drawn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DrawnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DrawnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DrawnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Drawn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DrawnMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Drawn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DrawnMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, drawn.EdgeEvent)
	}
	if m.discard != nil {
		edges = append(edges, drawn.EdgeDiscard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DrawnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case drawn.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case drawn.EdgeDiscard:
		if id := m.discard; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DrawnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DrawnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DrawnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, drawn.EdgeEvent)
	}
	if m.cleareddiscard {
		edges = append(edges, drawn.EdgeDiscard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DrawnMutation) EdgeCleared(name string) bool {
	switch name {
	case drawn.EdgeEvent:
		return m.clearedevent
	case drawn.EdgeDiscard:
		return m.cleareddiscard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DrawnMutation) ClearEdge(name string) error {
	switch name {
	case drawn.EdgeEvent:
		m.ClearEvent()
		return nil
	case drawn.EdgeDiscard:
		m.ClearDiscard()
		return nil
	}
	return fmt.Errorf("unknown Drawn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DrawnMutation) ResetEdge(name string) error {
	switch name {
	case drawn.EdgeEvent:
		m.ResetEvent()
		return nil
	case drawn.EdgeDiscard:
		m.ResetDiscard()
		return nil
	}
	return fmt.Errorf("unknown Drawn edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	turn          *uuid.UUID
	clearedturn   bool
	win           map[uuid.UUID]struct{}
	removedwin    map[uuid.UUID]struct{}
	clearedwin    bool
	call          map[uuid.UUID]struct{}
	removedcall   map[uuid.UUID]struct{}
	clearedcall   bool
	draw          map[uuid.UUID]struct{}
	removeddraw   map[uuid.UUID]struct{}
	cleareddraw   bool
	reach         map[uuid.UUID]struct{}
	removedreach  map[uuid.UUID]struct{}
	clearedreach  bool
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id uuid.UUID) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Event entities.
func (m *EventMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTurnID sets the "turn" edge to the Turn entity by id.
func (m *EventMutation) SetTurnID(id uuid.UUID) {
	m.turn = &id
}

// ClearTurn clears the "turn" edge to the Turn entity.
func (m *EventMutation) ClearTurn() {
	m.clearedturn = true
}

// TurnCleared reports if the "turn" edge to the Turn entity was cleared.
func (m *EventMutation) TurnCleared() bool {
	return m.clearedturn
}

// TurnID returns the "turn" edge ID in the mutation.
func (m *EventMutation) TurnID() (id uuid.UUID, exists bool) {
	if m.turn != nil {
		return *m.turn, true
	}
	return
}

// TurnIDs returns the "turn" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TurnID instead. It exists only for internal usage by the builders.
func (m *EventMutation) TurnIDs() (ids []uuid.UUID) {
	if id := m.turn; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTurn resets all changes to the "turn" edge.
func (m *EventMutation) ResetTurn() {
	m.turn = nil
	m.clearedturn = false
}

// AddWinIDs adds the "win" edge to the Win entity by ids.
func (m *EventMutation) AddWinIDs(ids ...uuid.UUID) {
	if m.win == nil {
		m.win = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.win[ids[i]] = struct{}{}
	}
}

// ClearWin clears the "win" edge to the Win entity.
func (m *EventMutation) ClearWin() {
	m.clearedwin = true
}

// WinCleared reports if the "win" edge to the Win entity was cleared.
func (m *EventMutation) WinCleared() bool {
	return m.clearedwin
}

// RemoveWinIDs removes the "win" edge to the Win entity by IDs.
func (m *EventMutation) RemoveWinIDs(ids ...uuid.UUID) {
	if m.removedwin == nil {
		m.removedwin = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.win, ids[i])
		m.removedwin[ids[i]] = struct{}{}
	}
}

// RemovedWin returns the removed IDs of the "win" edge to the Win entity.
func (m *EventMutation) RemovedWinIDs() (ids []uuid.UUID) {
	for id := range m.removedwin {
		ids = append(ids, id)
	}
	return
}

// WinIDs returns the "win" edge IDs in the mutation.
func (m *EventMutation) WinIDs() (ids []uuid.UUID) {
	for id := range m.win {
		ids = append(ids, id)
	}
	return
}

// ResetWin resets all changes to the "win" edge.
func (m *EventMutation) ResetWin() {
	m.win = nil
	m.clearedwin = false
	m.removedwin = nil
}

// AddCallIDs adds the "call" edge to the Call entity by ids.
func (m *EventMutation) AddCallIDs(ids ...uuid.UUID) {
	if m.call == nil {
		m.call = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.call[ids[i]] = struct{}{}
	}
}

// ClearCall clears the "call" edge to the Call entity.
func (m *EventMutation) ClearCall() {
	m.clearedcall = true
}

// CallCleared reports if the "call" edge to the Call entity was cleared.
func (m *EventMutation) CallCleared() bool {
	return m.clearedcall
}

// RemoveCallIDs removes the "call" edge to the Call entity by IDs.
func (m *EventMutation) RemoveCallIDs(ids ...uuid.UUID) {
	if m.removedcall == nil {
		m.removedcall = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.call, ids[i])
		m.removedcall[ids[i]] = struct{}{}
	}
}

// RemovedCall returns the removed IDs of the "call" edge to the Call entity.
func (m *EventMutation) RemovedCallIDs() (ids []uuid.UUID) {
	for id := range m.removedcall {
		ids = append(ids, id)
	}
	return
}

// CallIDs returns the "call" edge IDs in the mutation.
func (m *EventMutation) CallIDs() (ids []uuid.UUID) {
	for id := range m.call {
		ids = append(ids, id)
	}
	return
}

// ResetCall resets all changes to the "call" edge.
func (m *EventMutation) ResetCall() {
	m.call = nil
	m.clearedcall = false
	m.removedcall = nil
}

// AddDrawIDs adds the "draw" edge to the Drawn entity by ids.
func (m *EventMutation) AddDrawIDs(ids ...uuid.UUID) {
	if m.draw == nil {
		m.draw = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.draw[ids[i]] = struct{}{}
	}
}

// ClearDraw clears the "draw" edge to the Drawn entity.
func (m *EventMutation) ClearDraw() {
	m.cleareddraw = true
}

// DrawCleared reports if the "draw" edge to the Drawn entity was cleared.
func (m *EventMutation) DrawCleared() bool {
	return m.cleareddraw
}

// RemoveDrawIDs removes the "draw" edge to the Drawn entity by IDs.
func (m *EventMutation) RemoveDrawIDs(ids ...uuid.UUID) {
	if m.removeddraw == nil {
		m.removeddraw = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.draw, ids[i])
		m.removeddraw[ids[i]] = struct{}{}
	}
}

// RemovedDraw returns the removed IDs of the "draw" edge to the Drawn entity.
func (m *EventMutation) RemovedDrawIDs() (ids []uuid.UUID) {
	for id := range m.removeddraw {
		ids = append(ids, id)
	}
	return
}

// DrawIDs returns the "draw" edge IDs in the mutation.
func (m *EventMutation) DrawIDs() (ids []uuid.UUID) {
	for id := range m.draw {
		ids = append(ids, id)
	}
	return
}

// ResetDraw resets all changes to the "draw" edge.
func (m *EventMutation) ResetDraw() {
	m.draw = nil
	m.cleareddraw = false
	m.removeddraw = nil
}

// AddReachIDs adds the "reach" edge to the Reach entity by ids.
func (m *EventMutation) AddReachIDs(ids ...uuid.UUID) {
	if m.reach == nil {
		m.reach = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reach[ids[i]] = struct{}{}
	}
}

// ClearReach clears the "reach" edge to the Reach entity.
func (m *EventMutation) ClearReach() {
	m.clearedreach = true
}

// ReachCleared reports if the "reach" edge to the Reach entity was cleared.
func (m *EventMutation) ReachCleared() bool {
	return m.clearedreach
}

// RemoveReachIDs removes the "reach" edge to the Reach entity by IDs.
func (m *EventMutation) RemoveReachIDs(ids ...uuid.UUID) {
	if m.removedreach == nil {
		m.removedreach = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reach, ids[i])
		m.removedreach[ids[i]] = struct{}{}
	}
}

// RemovedReach returns the removed IDs of the "reach" edge to the Reach entity.
func (m *EventMutation) RemovedReachIDs() (ids []uuid.UUID) {
	for id := range m.removedreach {
		ids = append(ids, id)
	}
	return
}

// ReachIDs returns the "reach" edge IDs in the mutation.
func (m *EventMutation) ReachIDs() (ids []uuid.UUID) {
	for id := range m.reach {
		ids = append(ids, id)
	}
	return
}

// ResetReach resets all changes to the "reach" edge.
func (m *EventMutation) ResetReach() {
	m.reach = nil
	m.clearedreach = false
	m.removedreach = nil
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.turn != nil {
		edges = append(edges, event.EdgeTurn)
	}
	if m.win != nil {
		edges = append(edges, event.EdgeWin)
	}
	if m.call != nil {
		edges = append(edges, event.EdgeCall)
	}
	if m.draw != nil {
		edges = append(edges, event.EdgeDraw)
	}
	if m.reach != nil {
		edges = append(edges, event.EdgeReach)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeTurn:
		if id := m.turn; id != nil {
			return []ent.Value{*id}
		}
	case event.EdgeWin:
		ids := make([]ent.Value, 0, len(m.win))
		for id := range m.win {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeCall:
		ids := make([]ent.Value, 0, len(m.call))
		for id := range m.call {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeDraw:
		ids := make([]ent.Value, 0, len(m.draw))
		for id := range m.draw {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeReach:
		ids := make([]ent.Value, 0, len(m.reach))
		for id := range m.reach {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedwin != nil {
		edges = append(edges, event.EdgeWin)
	}
	if m.removedcall != nil {
		edges = append(edges, event.EdgeCall)
	}
	if m.removeddraw != nil {
		edges = append(edges, event.EdgeDraw)
	}
	if m.removedreach != nil {
		edges = append(edges, event.EdgeReach)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeWin:
		ids := make([]ent.Value, 0, len(m.removedwin))
		for id := range m.removedwin {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeCall:
		ids := make([]ent.Value, 0, len(m.removedcall))
		for id := range m.removedcall {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeDraw:
		ids := make([]ent.Value, 0, len(m.removeddraw))
		for id := range m.removeddraw {
			ids = append(ids, id)
		}
		return ids
	case event.EdgeReach:
		ids := make([]ent.Value, 0, len(m.removedreach))
		for id := range m.removedreach {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedturn {
		edges = append(edges, event.EdgeTurn)
	}
	if m.clearedwin {
		edges = append(edges, event.EdgeWin)
	}
	if m.clearedcall {
		edges = append(edges, event.EdgeCall)
	}
	if m.cleareddraw {
		edges = append(edges, event.EdgeDraw)
	}
	if m.clearedreach {
		edges = append(edges, event.EdgeReach)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeTurn:
		return m.clearedturn
	case event.EdgeWin:
		return m.clearedwin
	case event.EdgeCall:
		return m.clearedcall
	case event.EdgeDraw:
		return m.cleareddraw
	case event.EdgeReach:
		return m.clearedreach
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeTurn:
		m.ClearTurn()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeTurn:
		m.ResetTurn()
		return nil
	case event.EdgeWin:
		m.ResetWin()
		return nil
	case event.EdgeCall:
		m.ResetCall()
		return nil
	case event.EdgeDraw:
		m.ResetDraw()
		return nil
	case event.EdgeReach:
		m.ResetReach()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// GameMutation represents an operation that mutates the Game nodes in the graph.
type GameMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	started_at          *time.Time
	clearedFields       map[string]struct{}
	mjlogs              *uuid.UUID
	clearedmjlogs       bool
	game_players        map[uuid.UUID]struct{}
	removedgame_players map[uuid.UUID]struct{}
	clearedgame_players bool
	rooms               *uuid.UUID
	clearedrooms        bool
	rounds              map[uuid.UUID]struct{}
	removedrounds       map[uuid.UUID]struct{}
	clearedrounds       bool
	done                bool
	oldValue            func(context.Context) (*Game, error)
	predicates          []predicate.Game
}

var _ ent.Mutation = (*GameMutation)(nil)

// gameOption allows management of the mutation configuration using functional options.
type gameOption func(*GameMutation)

// newGameMutation creates new mutation for the Game entity.
func newGameMutation(c config, op Op, opts ...gameOption) *GameMutation {
	m := &GameMutation{
		config:        c,
		op:            op,
		typ:           TypeGame,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameID sets the ID field of the mutation.
func withGameID(id uuid.UUID) gameOption {
	return func(m *GameMutation) {
		var (
			err   error
			once  sync.Once
			value *Game
		)
		m.oldValue = func(ctx context.Context) (*Game, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Game.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGame sets the old Game of the mutation.
func withGame(node *Game) gameOption {
	return func(m *GameMutation) {
		m.oldValue = func(context.Context) (*Game, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Game entities.
func (m *GameMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Game.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GameMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GameMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GameMutation) ResetName() {
	m.name = nil
}

// SetStartedAt sets the "started_at" field.
func (m *GameMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *GameMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the Game entity.
// If the Game object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *GameMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetMjlogsID sets the "mjlogs" edge to the MJLog entity by id.
func (m *GameMutation) SetMjlogsID(id uuid.UUID) {
	m.mjlogs = &id
}

// ClearMjlogs clears the "mjlogs" edge to the MJLog entity.
func (m *GameMutation) ClearMjlogs() {
	m.clearedmjlogs = true
}

// MjlogsCleared reports if the "mjlogs" edge to the MJLog entity was cleared.
func (m *GameMutation) MjlogsCleared() bool {
	return m.clearedmjlogs
}

// MjlogsID returns the "mjlogs" edge ID in the mutation.
func (m *GameMutation) MjlogsID() (id uuid.UUID, exists bool) {
	if m.mjlogs != nil {
		return *m.mjlogs, true
	}
	return
}

// MjlogsIDs returns the "mjlogs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MjlogsID instead. It exists only for internal usage by the builders.
func (m *GameMutation) MjlogsIDs() (ids []uuid.UUID) {
	if id := m.mjlogs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMjlogs resets all changes to the "mjlogs" edge.
func (m *GameMutation) ResetMjlogs() {
	m.mjlogs = nil
	m.clearedmjlogs = false
}

// AddGamePlayerIDs adds the "game_players" edge to the GamePlayer entity by ids.
func (m *GameMutation) AddGamePlayerIDs(ids ...uuid.UUID) {
	if m.game_players == nil {
		m.game_players = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.game_players[ids[i]] = struct{}{}
	}
}

// ClearGamePlayers clears the "game_players" edge to the GamePlayer entity.
func (m *GameMutation) ClearGamePlayers() {
	m.clearedgame_players = true
}

// GamePlayersCleared reports if the "game_players" edge to the GamePlayer entity was cleared.
func (m *GameMutation) GamePlayersCleared() bool {
	return m.clearedgame_players
}

// RemoveGamePlayerIDs removes the "game_players" edge to the GamePlayer entity by IDs.
func (m *GameMutation) RemoveGamePlayerIDs(ids ...uuid.UUID) {
	if m.removedgame_players == nil {
		m.removedgame_players = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.game_players, ids[i])
		m.removedgame_players[ids[i]] = struct{}{}
	}
}

// RemovedGamePlayers returns the removed IDs of the "game_players" edge to the GamePlayer entity.
func (m *GameMutation) RemovedGamePlayersIDs() (ids []uuid.UUID) {
	for id := range m.removedgame_players {
		ids = append(ids, id)
	}
	return
}

// GamePlayersIDs returns the "game_players" edge IDs in the mutation.
func (m *GameMutation) GamePlayersIDs() (ids []uuid.UUID) {
	for id := range m.game_players {
		ids = append(ids, id)
	}
	return
}

// ResetGamePlayers resets all changes to the "game_players" edge.
func (m *GameMutation) ResetGamePlayers() {
	m.game_players = nil
	m.clearedgame_players = false
	m.removedgame_players = nil
}

// SetRoomsID sets the "rooms" edge to the Room entity by id.
func (m *GameMutation) SetRoomsID(id uuid.UUID) {
	m.rooms = &id
}

// ClearRooms clears the "rooms" edge to the Room entity.
func (m *GameMutation) ClearRooms() {
	m.clearedrooms = true
}

// RoomsCleared reports if the "rooms" edge to the Room entity was cleared.
func (m *GameMutation) RoomsCleared() bool {
	return m.clearedrooms
}

// RoomsID returns the "rooms" edge ID in the mutation.
func (m *GameMutation) RoomsID() (id uuid.UUID, exists bool) {
	if m.rooms != nil {
		return *m.rooms, true
	}
	return
}

// RoomsIDs returns the "rooms" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoomsID instead. It exists only for internal usage by the builders.
func (m *GameMutation) RoomsIDs() (ids []uuid.UUID) {
	if id := m.rooms; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRooms resets all changes to the "rooms" edge.
func (m *GameMutation) ResetRooms() {
	m.rooms = nil
	m.clearedrooms = false
}

// AddRoundIDs adds the "rounds" edge to the Round entity by ids.
func (m *GameMutation) AddRoundIDs(ids ...uuid.UUID) {
	if m.rounds == nil {
		m.rounds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.rounds[ids[i]] = struct{}{}
	}
}

// ClearRounds clears the "rounds" edge to the Round entity.
func (m *GameMutation) ClearRounds() {
	m.clearedrounds = true
}

// RoundsCleared reports if the "rounds" edge to the Round entity was cleared.
func (m *GameMutation) RoundsCleared() bool {
	return m.clearedrounds
}

// RemoveRoundIDs removes the "rounds" edge to the Round entity by IDs.
func (m *GameMutation) RemoveRoundIDs(ids ...uuid.UUID) {
	if m.removedrounds == nil {
		m.removedrounds = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.rounds, ids[i])
		m.removedrounds[ids[i]] = struct{}{}
	}
}

// RemovedRounds returns the removed IDs of the "rounds" edge to the Round entity.
func (m *GameMutation) RemovedRoundsIDs() (ids []uuid.UUID) {
	for id := range m.removedrounds {
		ids = append(ids, id)
	}
	return
}

// RoundsIDs returns the "rounds" edge IDs in the mutation.
func (m *GameMutation) RoundsIDs() (ids []uuid.UUID) {
	for id := range m.rounds {
		ids = append(ids, id)
	}
	return
}

// ResetRounds resets all changes to the "rounds" edge.
func (m *GameMutation) ResetRounds() {
	m.rounds = nil
	m.clearedrounds = false
	m.removedrounds = nil
}

// Where appends a list predicates to the GameMutation builder.
func (m *GameMutation) Where(ps ...predicate.Game) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Game, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Game).
func (m *GameMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, game.FieldName)
	}
	if m.started_at != nil {
		fields = append(fields, game.FieldStartedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case game.FieldName:
		return m.Name()
	case game.FieldStartedAt:
		return m.StartedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case game.FieldName:
		return m.OldName(ctx)
	case game.FieldStartedAt:
		return m.OldStartedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Game field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) SetField(name string, value ent.Value) error {
	switch name {
	case game.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case game.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Game numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Game nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameMutation) ResetField(name string) error {
	switch name {
	case game.FieldName:
		m.ResetName()
		return nil
	case game.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	}
	return fmt.Errorf("unknown Game field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.mjlogs != nil {
		edges = append(edges, game.EdgeMjlogs)
	}
	if m.game_players != nil {
		edges = append(edges, game.EdgeGamePlayers)
	}
	if m.rooms != nil {
		edges = append(edges, game.EdgeRooms)
	}
	if m.rounds != nil {
		edges = append(edges, game.EdgeRounds)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeMjlogs:
		if id := m.mjlogs; id != nil {
			return []ent.Value{*id}
		}
	case game.EdgeGamePlayers:
		ids := make([]ent.Value, 0, len(m.game_players))
		for id := range m.game_players {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeRooms:
		if id := m.rooms; id != nil {
			return []ent.Value{*id}
		}
	case game.EdgeRounds:
		ids := make([]ent.Value, 0, len(m.rounds))
		for id := range m.rounds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedgame_players != nil {
		edges = append(edges, game.EdgeGamePlayers)
	}
	if m.removedrounds != nil {
		edges = append(edges, game.EdgeRounds)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case game.EdgeGamePlayers:
		ids := make([]ent.Value, 0, len(m.removedgame_players))
		for id := range m.removedgame_players {
			ids = append(ids, id)
		}
		return ids
	case game.EdgeRounds:
		ids := make([]ent.Value, 0, len(m.removedrounds))
		for id := range m.removedrounds {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmjlogs {
		edges = append(edges, game.EdgeMjlogs)
	}
	if m.clearedgame_players {
		edges = append(edges, game.EdgeGamePlayers)
	}
	if m.clearedrooms {
		edges = append(edges, game.EdgeRooms)
	}
	if m.clearedrounds {
		edges = append(edges, game.EdgeRounds)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameMutation) EdgeCleared(name string) bool {
	switch name {
	case game.EdgeMjlogs:
		return m.clearedmjlogs
	case game.EdgeGamePlayers:
		return m.clearedgame_players
	case game.EdgeRooms:
		return m.clearedrooms
	case game.EdgeRounds:
		return m.clearedrounds
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameMutation) ClearEdge(name string) error {
	switch name {
	case game.EdgeMjlogs:
		m.ClearMjlogs()
		return nil
	case game.EdgeRooms:
		m.ClearRooms()
		return nil
	}
	return fmt.Errorf("unknown Game unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameMutation) ResetEdge(name string) error {
	switch name {
	case game.EdgeMjlogs:
		m.ResetMjlogs()
		return nil
	case game.EdgeGamePlayers:
		m.ResetGamePlayers()
		return nil
	case game.EdgeRooms:
		m.ResetRooms()
		return nil
	case game.EdgeRounds:
		m.ResetRounds()
		return nil
	}
	return fmt.Errorf("unknown Game edge %s", name)
}

// GamePlayerMutation represents an operation that mutates the GamePlayer nodes in the graph.
type GamePlayerMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	rate           *float64
	addrate        *float64
	start_position *string
	clearedFields  map[string]struct{}
	games          map[uuid.UUID]struct{}
	removedgames   map[uuid.UUID]struct{}
	clearedgames   bool
	players        *uuid.UUID
	clearedplayers bool
	dans           *uuid.UUID
	cleareddans    bool
	done           bool
	oldValue       func(context.Context) (*GamePlayer, error)
	predicates     []predicate.GamePlayer
}

var _ ent.Mutation = (*GamePlayerMutation)(nil)

// gameplayerOption allows management of the mutation configuration using functional options.
type gameplayerOption func(*GamePlayerMutation)

// newGamePlayerMutation creates new mutation for the GamePlayer entity.
func newGamePlayerMutation(c config, op Op, opts ...gameplayerOption) *GamePlayerMutation {
	m := &GamePlayerMutation{
		config:        c,
		op:            op,
		typ:           TypeGamePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGamePlayerID sets the ID field of the mutation.
func withGamePlayerID(id uuid.UUID) gameplayerOption {
	return func(m *GamePlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *GamePlayer
		)
		m.oldValue = func(ctx context.Context) (*GamePlayer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GamePlayer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGamePlayer sets the old GamePlayer of the mutation.
func withGamePlayer(node *GamePlayer) gameplayerOption {
	return func(m *GamePlayerMutation) {
		m.oldValue = func(context.Context) (*GamePlayer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GamePlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GamePlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GamePlayer entities.
func (m *GamePlayerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GamePlayerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GamePlayerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GamePlayer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRate sets the "rate" field.
func (m *GamePlayerMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *GamePlayerMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the GamePlayer entity.
// If the GamePlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GamePlayerMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *GamePlayerMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *GamePlayerMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *GamePlayerMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetStartPosition sets the "start_position" field.
func (m *GamePlayerMutation) SetStartPosition(s string) {
	m.start_position = &s
}

// StartPosition returns the value of the "start_position" field in the mutation.
func (m *GamePlayerMutation) StartPosition() (r string, exists bool) {
	v := m.start_position
	if v == nil {
		return
	}
	return *v, true
}

// OldStartPosition returns the old "start_position" field's value of the GamePlayer entity.
// If the GamePlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GamePlayerMutation) OldStartPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartPosition: %w", err)
	}
	return oldValue.StartPosition, nil
}

// ResetStartPosition resets all changes to the "start_position" field.
func (m *GamePlayerMutation) ResetStartPosition() {
	m.start_position = nil
}

// AddGameIDs adds the "games" edge to the Game entity by ids.
func (m *GamePlayerMutation) AddGameIDs(ids ...uuid.UUID) {
	if m.games == nil {
		m.games = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.games[ids[i]] = struct{}{}
	}
}

// ClearGames clears the "games" edge to the Game entity.
func (m *GamePlayerMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *GamePlayerMutation) GamesCleared() bool {
	return m.clearedgames
}

// RemoveGameIDs removes the "games" edge to the Game entity by IDs.
func (m *GamePlayerMutation) RemoveGameIDs(ids ...uuid.UUID) {
	if m.removedgames == nil {
		m.removedgames = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.games, ids[i])
		m.removedgames[ids[i]] = struct{}{}
	}
}

// RemovedGames returns the removed IDs of the "games" edge to the Game entity.
func (m *GamePlayerMutation) RemovedGamesIDs() (ids []uuid.UUID) {
	for id := range m.removedgames {
		ids = append(ids, id)
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
func (m *GamePlayerMutation) GamesIDs() (ids []uuid.UUID) {
	for id := range m.games {
		ids = append(ids, id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *GamePlayerMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
	m.removedgames = nil
}

// SetPlayersID sets the "players" edge to the Player entity by id.
func (m *GamePlayerMutation) SetPlayersID(id uuid.UUID) {
	m.players = &id
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *GamePlayerMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *GamePlayerMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// PlayersID returns the "players" edge ID in the mutation.
func (m *GamePlayerMutation) PlayersID() (id uuid.UUID, exists bool) {
	if m.players != nil {
		return *m.players, true
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayersID instead. It exists only for internal usage by the builders.
func (m *GamePlayerMutation) PlayersIDs() (ids []uuid.UUID) {
	if id := m.players; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *GamePlayerMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
}

// SetDansID sets the "dans" edge to the Dan entity by id.
func (m *GamePlayerMutation) SetDansID(id uuid.UUID) {
	m.dans = &id
}

// ClearDans clears the "dans" edge to the Dan entity.
func (m *GamePlayerMutation) ClearDans() {
	m.cleareddans = true
}

// DansCleared reports if the "dans" edge to the Dan entity was cleared.
func (m *GamePlayerMutation) DansCleared() bool {
	return m.cleareddans
}

// DansID returns the "dans" edge ID in the mutation.
func (m *GamePlayerMutation) DansID() (id uuid.UUID, exists bool) {
	if m.dans != nil {
		return *m.dans, true
	}
	return
}

// DansIDs returns the "dans" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DansID instead. It exists only for internal usage by the builders.
func (m *GamePlayerMutation) DansIDs() (ids []uuid.UUID) {
	if id := m.dans; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDans resets all changes to the "dans" edge.
func (m *GamePlayerMutation) ResetDans() {
	m.dans = nil
	m.cleareddans = false
}

// Where appends a list predicates to the GamePlayerMutation builder.
func (m *GamePlayerMutation) Where(ps ...predicate.GamePlayer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GamePlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GamePlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GamePlayer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GamePlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GamePlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GamePlayer).
func (m *GamePlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GamePlayerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.rate != nil {
		fields = append(fields, gameplayer.FieldRate)
	}
	if m.start_position != nil {
		fields = append(fields, gameplayer.FieldStartPosition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GamePlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameplayer.FieldRate:
		return m.Rate()
	case gameplayer.FieldStartPosition:
		return m.StartPosition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GamePlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameplayer.FieldRate:
		return m.OldRate(ctx)
	case gameplayer.FieldStartPosition:
		return m.OldStartPosition(ctx)
	}
	return nil, fmt.Errorf("unknown GamePlayer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GamePlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameplayer.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case gameplayer.FieldStartPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartPosition(v)
		return nil
	}
	return fmt.Errorf("unknown GamePlayer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GamePlayerMutation) AddedFields() []string {
	var fields []string
	if m.addrate != nil {
		fields = append(fields, gameplayer.FieldRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GamePlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gameplayer.FieldRate:
		return m.AddedRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GamePlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gameplayer.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	}
	return fmt.Errorf("unknown GamePlayer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GamePlayerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GamePlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GamePlayerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GamePlayer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GamePlayerMutation) ResetField(name string) error {
	switch name {
	case gameplayer.FieldRate:
		m.ResetRate()
		return nil
	case gameplayer.FieldStartPosition:
		m.ResetStartPosition()
		return nil
	}
	return fmt.Errorf("unknown GamePlayer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GamePlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.games != nil {
		edges = append(edges, gameplayer.EdgeGames)
	}
	if m.players != nil {
		edges = append(edges, gameplayer.EdgePlayers)
	}
	if m.dans != nil {
		edges = append(edges, gameplayer.EdgeDans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GamePlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameplayer.EdgeGames:
		ids := make([]ent.Value, 0, len(m.games))
		for id := range m.games {
			ids = append(ids, id)
		}
		return ids
	case gameplayer.EdgePlayers:
		if id := m.players; id != nil {
			return []ent.Value{*id}
		}
	case gameplayer.EdgeDans:
		if id := m.dans; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GamePlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgames != nil {
		edges = append(edges, gameplayer.EdgeGames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GamePlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gameplayer.EdgeGames:
		ids := make([]ent.Value, 0, len(m.removedgames))
		for id := range m.removedgames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GamePlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgames {
		edges = append(edges, gameplayer.EdgeGames)
	}
	if m.clearedplayers {
		edges = append(edges, gameplayer.EdgePlayers)
	}
	if m.cleareddans {
		edges = append(edges, gameplayer.EdgeDans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GamePlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case gameplayer.EdgeGames:
		return m.clearedgames
	case gameplayer.EdgePlayers:
		return m.clearedplayers
	case gameplayer.EdgeDans:
		return m.cleareddans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GamePlayerMutation) ClearEdge(name string) error {
	switch name {
	case gameplayer.EdgePlayers:
		m.ClearPlayers()
		return nil
	case gameplayer.EdgeDans:
		m.ClearDans()
		return nil
	}
	return fmt.Errorf("unknown GamePlayer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GamePlayerMutation) ResetEdge(name string) error {
	switch name {
	case gameplayer.EdgeGames:
		m.ResetGames()
		return nil
	case gameplayer.EdgePlayers:
		m.ResetPlayers()
		return nil
	case gameplayer.EdgeDans:
		m.ResetDans()
		return nil
	}
	return fmt.Errorf("unknown GamePlayer edge %s", name)
}

// GamePlayerHandHaiMutation represents an operation that mutates the GamePlayerHandHai nodes in the graph.
type GamePlayerHandHaiMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	hais          *[]int
	appendhais    []int
	clearedFields map[string]struct{}
	turn          *uuid.UUID
	clearedturn   bool
	done          bool
	oldValue      func(context.Context) (*GamePlayerHandHai, error)
	predicates    []predicate.GamePlayerHandHai
}

var _ ent.Mutation = (*GamePlayerHandHaiMutation)(nil)

// gameplayerhandhaiOption allows management of the mutation configuration using functional options.
type gameplayerhandhaiOption func(*GamePlayerHandHaiMutation)

// newGamePlayerHandHaiMutation creates new mutation for the GamePlayerHandHai entity.
func newGamePlayerHandHaiMutation(c config, op Op, opts ...gameplayerhandhaiOption) *GamePlayerHandHaiMutation {
	m := &GamePlayerHandHaiMutation{
		config:        c,
		op:            op,
		typ:           TypeGamePlayerHandHai,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGamePlayerHandHaiID sets the ID field of the mutation.
func withGamePlayerHandHaiID(id uuid.UUID) gameplayerhandhaiOption {
	return func(m *GamePlayerHandHaiMutation) {
		var (
			err   error
			once  sync.Once
			value *GamePlayerHandHai
		)
		m.oldValue = func(ctx context.Context) (*GamePlayerHandHai, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GamePlayerHandHai.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGamePlayerHandHai sets the old GamePlayerHandHai of the mutation.
func withGamePlayerHandHai(node *GamePlayerHandHai) gameplayerhandhaiOption {
	return func(m *GamePlayerHandHaiMutation) {
		m.oldValue = func(context.Context) (*GamePlayerHandHai, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GamePlayerHandHaiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GamePlayerHandHaiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GamePlayerHandHai entities.
func (m *GamePlayerHandHaiMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GamePlayerHandHaiMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GamePlayerHandHaiMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GamePlayerHandHai.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHais sets the "hais" field.
func (m *GamePlayerHandHaiMutation) SetHais(i []int) {
	m.hais = &i
	m.appendhais = nil
}

// Hais returns the value of the "hais" field in the mutation.
func (m *GamePlayerHandHaiMutation) Hais() (r []int, exists bool) {
	v := m.hais
	if v == nil {
		return
	}
	return *v, true
}

// OldHais returns the old "hais" field's value of the GamePlayerHandHai entity.
// If the GamePlayerHandHai object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GamePlayerHandHaiMutation) OldHais(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHais is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHais requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHais: %w", err)
	}
	return oldValue.Hais, nil
}

// AppendHais adds i to the "hais" field.
func (m *GamePlayerHandHaiMutation) AppendHais(i []int) {
	m.appendhais = append(m.appendhais, i...)
}

// AppendedHais returns the list of values that were appended to the "hais" field in this mutation.
func (m *GamePlayerHandHaiMutation) AppendedHais() ([]int, bool) {
	if len(m.appendhais) == 0 {
		return nil, false
	}
	return m.appendhais, true
}

// ResetHais resets all changes to the "hais" field.
func (m *GamePlayerHandHaiMutation) ResetHais() {
	m.hais = nil
	m.appendhais = nil
}

// SetTurnID sets the "turn" edge to the Turn entity by id.
func (m *GamePlayerHandHaiMutation) SetTurnID(id uuid.UUID) {
	m.turn = &id
}

// ClearTurn clears the "turn" edge to the Turn entity.
func (m *GamePlayerHandHaiMutation) ClearTurn() {
	m.clearedturn = true
}

// TurnCleared reports if the "turn" edge to the Turn entity was cleared.
func (m *GamePlayerHandHaiMutation) TurnCleared() bool {
	return m.clearedturn
}

// TurnID returns the "turn" edge ID in the mutation.
func (m *GamePlayerHandHaiMutation) TurnID() (id uuid.UUID, exists bool) {
	if m.turn != nil {
		return *m.turn, true
	}
	return
}

// TurnIDs returns the "turn" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TurnID instead. It exists only for internal usage by the builders.
func (m *GamePlayerHandHaiMutation) TurnIDs() (ids []uuid.UUID) {
	if id := m.turn; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTurn resets all changes to the "turn" edge.
func (m *GamePlayerHandHaiMutation) ResetTurn() {
	m.turn = nil
	m.clearedturn = false
}

// Where appends a list predicates to the GamePlayerHandHaiMutation builder.
func (m *GamePlayerHandHaiMutation) Where(ps ...predicate.GamePlayerHandHai) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GamePlayerHandHaiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GamePlayerHandHaiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GamePlayerHandHai, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GamePlayerHandHaiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GamePlayerHandHaiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GamePlayerHandHai).
func (m *GamePlayerHandHaiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GamePlayerHandHaiMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.hais != nil {
		fields = append(fields, gameplayerhandhai.FieldHais)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GamePlayerHandHaiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameplayerhandhai.FieldHais:
		return m.Hais()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GamePlayerHandHaiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameplayerhandhai.FieldHais:
		return m.OldHais(ctx)
	}
	return nil, fmt.Errorf("unknown GamePlayerHandHai field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GamePlayerHandHaiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameplayerhandhai.FieldHais:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHais(v)
		return nil
	}
	return fmt.Errorf("unknown GamePlayerHandHai field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GamePlayerHandHaiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GamePlayerHandHaiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GamePlayerHandHaiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GamePlayerHandHai numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GamePlayerHandHaiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GamePlayerHandHaiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GamePlayerHandHaiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GamePlayerHandHai nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GamePlayerHandHaiMutation) ResetField(name string) error {
	switch name {
	case gameplayerhandhai.FieldHais:
		m.ResetHais()
		return nil
	}
	return fmt.Errorf("unknown GamePlayerHandHai field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GamePlayerHandHaiMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.turn != nil {
		edges = append(edges, gameplayerhandhai.EdgeTurn)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GamePlayerHandHaiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameplayerhandhai.EdgeTurn:
		if id := m.turn; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GamePlayerHandHaiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GamePlayerHandHaiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GamePlayerHandHaiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedturn {
		edges = append(edges, gameplayerhandhai.EdgeTurn)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GamePlayerHandHaiMutation) EdgeCleared(name string) bool {
	switch name {
	case gameplayerhandhai.EdgeTurn:
		return m.clearedturn
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GamePlayerHandHaiMutation) ClearEdge(name string) error {
	switch name {
	case gameplayerhandhai.EdgeTurn:
		m.ClearTurn()
		return nil
	}
	return fmt.Errorf("unknown GamePlayerHandHai unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GamePlayerHandHaiMutation) ResetEdge(name string) error {
	switch name {
	case gameplayerhandhai.EdgeTurn:
		m.ResetTurn()
		return nil
	}
	return fmt.Errorf("unknown GamePlayerHandHai edge %s", name)
}

// GamePlayerPointMutation represents an operation that mutates the GamePlayerPoint nodes in the graph.
type GamePlayerPointMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	point         *uint
	addpoint      *int
	clearedFields map[string]struct{}
	turns         map[uuid.UUID]struct{}
	removedturns  map[uuid.UUID]struct{}
	clearedturns  bool
	done          bool
	oldValue      func(context.Context) (*GamePlayerPoint, error)
	predicates    []predicate.GamePlayerPoint
}

var _ ent.Mutation = (*GamePlayerPointMutation)(nil)

// gameplayerpointOption allows management of the mutation configuration using functional options.
type gameplayerpointOption func(*GamePlayerPointMutation)

// newGamePlayerPointMutation creates new mutation for the GamePlayerPoint entity.
func newGamePlayerPointMutation(c config, op Op, opts ...gameplayerpointOption) *GamePlayerPointMutation {
	m := &GamePlayerPointMutation{
		config:        c,
		op:            op,
		typ:           TypeGamePlayerPoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGamePlayerPointID sets the ID field of the mutation.
func withGamePlayerPointID(id uuid.UUID) gameplayerpointOption {
	return func(m *GamePlayerPointMutation) {
		var (
			err   error
			once  sync.Once
			value *GamePlayerPoint
		)
		m.oldValue = func(ctx context.Context) (*GamePlayerPoint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GamePlayerPoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGamePlayerPoint sets the old GamePlayerPoint of the mutation.
func withGamePlayerPoint(node *GamePlayerPoint) gameplayerpointOption {
	return func(m *GamePlayerPointMutation) {
		m.oldValue = func(context.Context) (*GamePlayerPoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GamePlayerPointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GamePlayerPointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GamePlayerPoint entities.
func (m *GamePlayerPointMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GamePlayerPointMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GamePlayerPointMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GamePlayerPoint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPoint sets the "point" field.
func (m *GamePlayerPointMutation) SetPoint(u uint) {
	m.point = &u
	m.addpoint = nil
}

// Point returns the value of the "point" field in the mutation.
func (m *GamePlayerPointMutation) Point() (r uint, exists bool) {
	v := m.point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "point" field's value of the GamePlayerPoint entity.
// If the GamePlayerPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GamePlayerPointMutation) OldPoint(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds u to the "point" field.
func (m *GamePlayerPointMutation) AddPoint(u int) {
	if m.addpoint != nil {
		*m.addpoint += u
	} else {
		m.addpoint = &u
	}
}

// AddedPoint returns the value that was added to the "point" field in this mutation.
func (m *GamePlayerPointMutation) AddedPoint() (r int, exists bool) {
	v := m.addpoint
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoint resets all changes to the "point" field.
func (m *GamePlayerPointMutation) ResetPoint() {
	m.point = nil
	m.addpoint = nil
}

// AddTurnIDs adds the "turns" edge to the Turn entity by ids.
func (m *GamePlayerPointMutation) AddTurnIDs(ids ...uuid.UUID) {
	if m.turns == nil {
		m.turns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.turns[ids[i]] = struct{}{}
	}
}

// ClearTurns clears the "turns" edge to the Turn entity.
func (m *GamePlayerPointMutation) ClearTurns() {
	m.clearedturns = true
}

// TurnsCleared reports if the "turns" edge to the Turn entity was cleared.
func (m *GamePlayerPointMutation) TurnsCleared() bool {
	return m.clearedturns
}

// RemoveTurnIDs removes the "turns" edge to the Turn entity by IDs.
func (m *GamePlayerPointMutation) RemoveTurnIDs(ids ...uuid.UUID) {
	if m.removedturns == nil {
		m.removedturns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.turns, ids[i])
		m.removedturns[ids[i]] = struct{}{}
	}
}

// RemovedTurns returns the removed IDs of the "turns" edge to the Turn entity.
func (m *GamePlayerPointMutation) RemovedTurnsIDs() (ids []uuid.UUID) {
	for id := range m.removedturns {
		ids = append(ids, id)
	}
	return
}

// TurnsIDs returns the "turns" edge IDs in the mutation.
func (m *GamePlayerPointMutation) TurnsIDs() (ids []uuid.UUID) {
	for id := range m.turns {
		ids = append(ids, id)
	}
	return
}

// ResetTurns resets all changes to the "turns" edge.
func (m *GamePlayerPointMutation) ResetTurns() {
	m.turns = nil
	m.clearedturns = false
	m.removedturns = nil
}

// Where appends a list predicates to the GamePlayerPointMutation builder.
func (m *GamePlayerPointMutation) Where(ps ...predicate.GamePlayerPoint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GamePlayerPointMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GamePlayerPointMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GamePlayerPoint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GamePlayerPointMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GamePlayerPointMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GamePlayerPoint).
func (m *GamePlayerPointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GamePlayerPointMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.point != nil {
		fields = append(fields, gameplayerpoint.FieldPoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GamePlayerPointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameplayerpoint.FieldPoint:
		return m.Point()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GamePlayerPointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameplayerpoint.FieldPoint:
		return m.OldPoint(ctx)
	}
	return nil, fmt.Errorf("unknown GamePlayerPoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GamePlayerPointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameplayerpoint.FieldPoint:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	}
	return fmt.Errorf("unknown GamePlayerPoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GamePlayerPointMutation) AddedFields() []string {
	var fields []string
	if m.addpoint != nil {
		fields = append(fields, gameplayerpoint.FieldPoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GamePlayerPointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gameplayerpoint.FieldPoint:
		return m.AddedPoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GamePlayerPointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gameplayerpoint.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	}
	return fmt.Errorf("unknown GamePlayerPoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GamePlayerPointMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GamePlayerPointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GamePlayerPointMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GamePlayerPoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GamePlayerPointMutation) ResetField(name string) error {
	switch name {
	case gameplayerpoint.FieldPoint:
		m.ResetPoint()
		return nil
	}
	return fmt.Errorf("unknown GamePlayerPoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GamePlayerPointMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.turns != nil {
		edges = append(edges, gameplayerpoint.EdgeTurns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GamePlayerPointMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameplayerpoint.EdgeTurns:
		ids := make([]ent.Value, 0, len(m.turns))
		for id := range m.turns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GamePlayerPointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedturns != nil {
		edges = append(edges, gameplayerpoint.EdgeTurns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GamePlayerPointMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gameplayerpoint.EdgeTurns:
		ids := make([]ent.Value, 0, len(m.removedturns))
		for id := range m.removedturns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GamePlayerPointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedturns {
		edges = append(edges, gameplayerpoint.EdgeTurns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GamePlayerPointMutation) EdgeCleared(name string) bool {
	switch name {
	case gameplayerpoint.EdgeTurns:
		return m.clearedturns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GamePlayerPointMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GamePlayerPoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GamePlayerPointMutation) ResetEdge(name string) error {
	switch name {
	case gameplayerpoint.EdgeTurns:
		m.ResetTurns()
		return nil
	}
	return fmt.Errorf("unknown GamePlayerPoint edge %s", name)
}

// HandMutation represents an operation that mutates the Hand nodes in the graph.
type HandMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	num               *uint
	addnum            *int
	continue_point    *uint
	addcontinue_point *int
	reach_point       *uint
	addreach_point    *int
	clearedFields     map[string]struct{}
	rounds            *uuid.UUID
	clearedrounds     bool
	turns             map[uuid.UUID]struct{}
	removedturns      map[uuid.UUID]struct{}
	clearedturns      bool
	done              bool
	oldValue          func(context.Context) (*Hand, error)
	predicates        []predicate.Hand
}

var _ ent.Mutation = (*HandMutation)(nil)

// handOption allows management of the mutation configuration using functional options.
type handOption func(*HandMutation)

// newHandMutation creates new mutation for the Hand entity.
func newHandMutation(c config, op Op, opts ...handOption) *HandMutation {
	m := &HandMutation{
		config:        c,
		op:            op,
		typ:           TypeHand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHandID sets the ID field of the mutation.
func withHandID(id uuid.UUID) handOption {
	return func(m *HandMutation) {
		var (
			err   error
			once  sync.Once
			value *Hand
		)
		m.oldValue = func(ctx context.Context) (*Hand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHand sets the old Hand of the mutation.
func withHand(node *Hand) handOption {
	return func(m *HandMutation) {
		m.oldValue = func(context.Context) (*Hand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Hand entities.
func (m *HandMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HandMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HandMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNum sets the "num" field.
func (m *HandMutation) SetNum(u uint) {
	m.num = &u
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *HandMutation) Num() (r uint, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Hand entity.
// If the Hand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HandMutation) OldNum(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds u to the "num" field.
func (m *HandMutation) AddNum(u int) {
	if m.addnum != nil {
		*m.addnum += u
	} else {
		m.addnum = &u
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *HandMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *HandMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetContinuePoint sets the "continue_point" field.
func (m *HandMutation) SetContinuePoint(u uint) {
	m.continue_point = &u
	m.addcontinue_point = nil
}

// ContinuePoint returns the value of the "continue_point" field in the mutation.
func (m *HandMutation) ContinuePoint() (r uint, exists bool) {
	v := m.continue_point
	if v == nil {
		return
	}
	return *v, true
}

// OldContinuePoint returns the old "continue_point" field's value of the Hand entity.
// If the Hand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HandMutation) OldContinuePoint(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinuePoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinuePoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinuePoint: %w", err)
	}
	return oldValue.ContinuePoint, nil
}

// AddContinuePoint adds u to the "continue_point" field.
func (m *HandMutation) AddContinuePoint(u int) {
	if m.addcontinue_point != nil {
		*m.addcontinue_point += u
	} else {
		m.addcontinue_point = &u
	}
}

// AddedContinuePoint returns the value that was added to the "continue_point" field in this mutation.
func (m *HandMutation) AddedContinuePoint() (r int, exists bool) {
	v := m.addcontinue_point
	if v == nil {
		return
	}
	return *v, true
}

// ResetContinuePoint resets all changes to the "continue_point" field.
func (m *HandMutation) ResetContinuePoint() {
	m.continue_point = nil
	m.addcontinue_point = nil
}

// SetReachPoint sets the "reach_point" field.
func (m *HandMutation) SetReachPoint(u uint) {
	m.reach_point = &u
	m.addreach_point = nil
}

// ReachPoint returns the value of the "reach_point" field in the mutation.
func (m *HandMutation) ReachPoint() (r uint, exists bool) {
	v := m.reach_point
	if v == nil {
		return
	}
	return *v, true
}

// OldReachPoint returns the old "reach_point" field's value of the Hand entity.
// If the Hand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HandMutation) OldReachPoint(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReachPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReachPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReachPoint: %w", err)
	}
	return oldValue.ReachPoint, nil
}

// AddReachPoint adds u to the "reach_point" field.
func (m *HandMutation) AddReachPoint(u int) {
	if m.addreach_point != nil {
		*m.addreach_point += u
	} else {
		m.addreach_point = &u
	}
}

// AddedReachPoint returns the value that was added to the "reach_point" field in this mutation.
func (m *HandMutation) AddedReachPoint() (r int, exists bool) {
	v := m.addreach_point
	if v == nil {
		return
	}
	return *v, true
}

// ResetReachPoint resets all changes to the "reach_point" field.
func (m *HandMutation) ResetReachPoint() {
	m.reach_point = nil
	m.addreach_point = nil
}

// SetRoundsID sets the "rounds" edge to the Round entity by id.
func (m *HandMutation) SetRoundsID(id uuid.UUID) {
	m.rounds = &id
}

// ClearRounds clears the "rounds" edge to the Round entity.
func (m *HandMutation) ClearRounds() {
	m.clearedrounds = true
}

// RoundsCleared reports if the "rounds" edge to the Round entity was cleared.
func (m *HandMutation) RoundsCleared() bool {
	return m.clearedrounds
}

// RoundsID returns the "rounds" edge ID in the mutation.
func (m *HandMutation) RoundsID() (id uuid.UUID, exists bool) {
	if m.rounds != nil {
		return *m.rounds, true
	}
	return
}

// RoundsIDs returns the "rounds" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoundsID instead. It exists only for internal usage by the builders.
func (m *HandMutation) RoundsIDs() (ids []uuid.UUID) {
	if id := m.rounds; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRounds resets all changes to the "rounds" edge.
func (m *HandMutation) ResetRounds() {
	m.rounds = nil
	m.clearedrounds = false
}

// AddTurnIDs adds the "turns" edge to the Turn entity by ids.
func (m *HandMutation) AddTurnIDs(ids ...uuid.UUID) {
	if m.turns == nil {
		m.turns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.turns[ids[i]] = struct{}{}
	}
}

// ClearTurns clears the "turns" edge to the Turn entity.
func (m *HandMutation) ClearTurns() {
	m.clearedturns = true
}

// TurnsCleared reports if the "turns" edge to the Turn entity was cleared.
func (m *HandMutation) TurnsCleared() bool {
	return m.clearedturns
}

// RemoveTurnIDs removes the "turns" edge to the Turn entity by IDs.
func (m *HandMutation) RemoveTurnIDs(ids ...uuid.UUID) {
	if m.removedturns == nil {
		m.removedturns = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.turns, ids[i])
		m.removedturns[ids[i]] = struct{}{}
	}
}

// RemovedTurns returns the removed IDs of the "turns" edge to the Turn entity.
func (m *HandMutation) RemovedTurnsIDs() (ids []uuid.UUID) {
	for id := range m.removedturns {
		ids = append(ids, id)
	}
	return
}

// TurnsIDs returns the "turns" edge IDs in the mutation.
func (m *HandMutation) TurnsIDs() (ids []uuid.UUID) {
	for id := range m.turns {
		ids = append(ids, id)
	}
	return
}

// ResetTurns resets all changes to the "turns" edge.
func (m *HandMutation) ResetTurns() {
	m.turns = nil
	m.clearedturns = false
	m.removedturns = nil
}

// Where appends a list predicates to the HandMutation builder.
func (m *HandMutation) Where(ps ...predicate.Hand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Hand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Hand).
func (m *HandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HandMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.num != nil {
		fields = append(fields, hand.FieldNum)
	}
	if m.continue_point != nil {
		fields = append(fields, hand.FieldContinuePoint)
	}
	if m.reach_point != nil {
		fields = append(fields, hand.FieldReachPoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hand.FieldNum:
		return m.Num()
	case hand.FieldContinuePoint:
		return m.ContinuePoint()
	case hand.FieldReachPoint:
		return m.ReachPoint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hand.FieldNum:
		return m.OldNum(ctx)
	case hand.FieldContinuePoint:
		return m.OldContinuePoint(ctx)
	case hand.FieldReachPoint:
		return m.OldReachPoint(ctx)
	}
	return nil, fmt.Errorf("unknown Hand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hand.FieldNum:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case hand.FieldContinuePoint:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinuePoint(v)
		return nil
	case hand.FieldReachPoint:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReachPoint(v)
		return nil
	}
	return fmt.Errorf("unknown Hand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HandMutation) AddedFields() []string {
	var fields []string
	if m.addnum != nil {
		fields = append(fields, hand.FieldNum)
	}
	if m.addcontinue_point != nil {
		fields = append(fields, hand.FieldContinuePoint)
	}
	if m.addreach_point != nil {
		fields = append(fields, hand.FieldReachPoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HandMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hand.FieldNum:
		return m.AddedNum()
	case hand.FieldContinuePoint:
		return m.AddedContinuePoint()
	case hand.FieldReachPoint:
		return m.AddedReachPoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HandMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hand.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case hand.FieldContinuePoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContinuePoint(v)
		return nil
	case hand.FieldReachPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReachPoint(v)
		return nil
	}
	return fmt.Errorf("unknown Hand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HandMutation) ResetField(name string) error {
	switch name {
	case hand.FieldNum:
		m.ResetNum()
		return nil
	case hand.FieldContinuePoint:
		m.ResetContinuePoint()
		return nil
	case hand.FieldReachPoint:
		m.ResetReachPoint()
		return nil
	}
	return fmt.Errorf("unknown Hand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HandMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rounds != nil {
		edges = append(edges, hand.EdgeRounds)
	}
	if m.turns != nil {
		edges = append(edges, hand.EdgeTurns)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hand.EdgeRounds:
		if id := m.rounds; id != nil {
			return []ent.Value{*id}
		}
	case hand.EdgeTurns:
		ids := make([]ent.Value, 0, len(m.turns))
		for id := range m.turns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedturns != nil {
		edges = append(edges, hand.EdgeTurns)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hand.EdgeTurns:
		ids := make([]ent.Value, 0, len(m.removedturns))
		for id := range m.removedturns {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrounds {
		edges = append(edges, hand.EdgeRounds)
	}
	if m.clearedturns {
		edges = append(edges, hand.EdgeTurns)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HandMutation) EdgeCleared(name string) bool {
	switch name {
	case hand.EdgeRounds:
		return m.clearedrounds
	case hand.EdgeTurns:
		return m.clearedturns
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HandMutation) ClearEdge(name string) error {
	switch name {
	case hand.EdgeRounds:
		m.ClearRounds()
		return nil
	}
	return fmt.Errorf("unknown Hand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HandMutation) ResetEdge(name string) error {
	switch name {
	case hand.EdgeRounds:
		m.ResetRounds()
		return nil
	case hand.EdgeTurns:
		m.ResetTurns()
		return nil
	}
	return fmt.Errorf("unknown Hand edge %s", name)
}

// MJLogMutation represents an operation that mutates the MJLog nodes in the graph.
type MJLogMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	version            *float64
	addversion         *float64
	seed               *string
	started_at         *time.Time
	inserted_at        *time.Time
	clearedFields      map[string]struct{}
	mjlog_files        *uuid.UUID
	clearedmjlog_files bool
	games              *uuid.UUID
	clearedgames       bool
	done               bool
	oldValue           func(context.Context) (*MJLog, error)
	predicates         []predicate.MJLog
}

var _ ent.Mutation = (*MJLogMutation)(nil)

// mjlogOption allows management of the mutation configuration using functional options.
type mjlogOption func(*MJLogMutation)

// newMJLogMutation creates new mutation for the MJLog entity.
func newMJLogMutation(c config, op Op, opts ...mjlogOption) *MJLogMutation {
	m := &MJLogMutation{
		config:        c,
		op:            op,
		typ:           TypeMJLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMJLogID sets the ID field of the mutation.
func withMJLogID(id uuid.UUID) mjlogOption {
	return func(m *MJLogMutation) {
		var (
			err   error
			once  sync.Once
			value *MJLog
		)
		m.oldValue = func(ctx context.Context) (*MJLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MJLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMJLog sets the old MJLog of the mutation.
func withMJLog(node *MJLog) mjlogOption {
	return func(m *MJLogMutation) {
		m.oldValue = func(context.Context) (*MJLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MJLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MJLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MJLog entities.
func (m *MJLogMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MJLogMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MJLogMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MJLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersion sets the "version" field.
func (m *MJLogMutation) SetVersion(f float64) {
	m.version = &f
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *MJLogMutation) Version() (r float64, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the MJLog entity.
// If the MJLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MJLogMutation) OldVersion(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds f to the "version" field.
func (m *MJLogMutation) AddVersion(f float64) {
	if m.addversion != nil {
		*m.addversion += f
	} else {
		m.addversion = &f
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *MJLogMutation) AddedVersion() (r float64, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *MJLogMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetSeed sets the "seed" field.
func (m *MJLogMutation) SetSeed(s string) {
	m.seed = &s
}

// Seed returns the value of the "seed" field in the mutation.
func (m *MJLogMutation) Seed() (r string, exists bool) {
	v := m.seed
	if v == nil {
		return
	}
	return *v, true
}

// OldSeed returns the old "seed" field's value of the MJLog entity.
// If the MJLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MJLogMutation) OldSeed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeed: %w", err)
	}
	return oldValue.Seed, nil
}

// ResetSeed resets all changes to the "seed" field.
func (m *MJLogMutation) ResetSeed() {
	m.seed = nil
}

// SetStartedAt sets the "started_at" field.
func (m *MJLogMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *MJLogMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the MJLog entity.
// If the MJLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MJLogMutation) OldStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *MJLogMutation) ResetStartedAt() {
	m.started_at = nil
}

// SetInsertedAt sets the "inserted_at" field.
func (m *MJLogMutation) SetInsertedAt(t time.Time) {
	m.inserted_at = &t
}

// InsertedAt returns the value of the "inserted_at" field in the mutation.
func (m *MJLogMutation) InsertedAt() (r time.Time, exists bool) {
	v := m.inserted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInsertedAt returns the old "inserted_at" field's value of the MJLog entity.
// If the MJLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MJLogMutation) OldInsertedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInsertedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInsertedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInsertedAt: %w", err)
	}
	return oldValue.InsertedAt, nil
}

// ResetInsertedAt resets all changes to the "inserted_at" field.
func (m *MJLogMutation) ResetInsertedAt() {
	m.inserted_at = nil
}

// SetMjlogFilesID sets the "mjlog_files" edge to the MJLogFile entity by id.
func (m *MJLogMutation) SetMjlogFilesID(id uuid.UUID) {
	m.mjlog_files = &id
}

// ClearMjlogFiles clears the "mjlog_files" edge to the MJLogFile entity.
func (m *MJLogMutation) ClearMjlogFiles() {
	m.clearedmjlog_files = true
}

// MjlogFilesCleared reports if the "mjlog_files" edge to the MJLogFile entity was cleared.
func (m *MJLogMutation) MjlogFilesCleared() bool {
	return m.clearedmjlog_files
}

// MjlogFilesID returns the "mjlog_files" edge ID in the mutation.
func (m *MJLogMutation) MjlogFilesID() (id uuid.UUID, exists bool) {
	if m.mjlog_files != nil {
		return *m.mjlog_files, true
	}
	return
}

// MjlogFilesIDs returns the "mjlog_files" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MjlogFilesID instead. It exists only for internal usage by the builders.
func (m *MJLogMutation) MjlogFilesIDs() (ids []uuid.UUID) {
	if id := m.mjlog_files; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMjlogFiles resets all changes to the "mjlog_files" edge.
func (m *MJLogMutation) ResetMjlogFiles() {
	m.mjlog_files = nil
	m.clearedmjlog_files = false
}

// SetGamesID sets the "games" edge to the Game entity by id.
func (m *MJLogMutation) SetGamesID(id uuid.UUID) {
	m.games = &id
}

// ClearGames clears the "games" edge to the Game entity.
func (m *MJLogMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *MJLogMutation) GamesCleared() bool {
	return m.clearedgames
}

// GamesID returns the "games" edge ID in the mutation.
func (m *MJLogMutation) GamesID() (id uuid.UUID, exists bool) {
	if m.games != nil {
		return *m.games, true
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GamesID instead. It exists only for internal usage by the builders.
func (m *MJLogMutation) GamesIDs() (ids []uuid.UUID) {
	if id := m.games; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *MJLogMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
}

// Where appends a list predicates to the MJLogMutation builder.
func (m *MJLogMutation) Where(ps ...predicate.MJLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MJLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MJLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MJLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MJLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MJLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MJLog).
func (m *MJLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MJLogMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.version != nil {
		fields = append(fields, mjlog.FieldVersion)
	}
	if m.seed != nil {
		fields = append(fields, mjlog.FieldSeed)
	}
	if m.started_at != nil {
		fields = append(fields, mjlog.FieldStartedAt)
	}
	if m.inserted_at != nil {
		fields = append(fields, mjlog.FieldInsertedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MJLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mjlog.FieldVersion:
		return m.Version()
	case mjlog.FieldSeed:
		return m.Seed()
	case mjlog.FieldStartedAt:
		return m.StartedAt()
	case mjlog.FieldInsertedAt:
		return m.InsertedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MJLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mjlog.FieldVersion:
		return m.OldVersion(ctx)
	case mjlog.FieldSeed:
		return m.OldSeed(ctx)
	case mjlog.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case mjlog.FieldInsertedAt:
		return m.OldInsertedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MJLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MJLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mjlog.FieldVersion:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case mjlog.FieldSeed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeed(v)
		return nil
	case mjlog.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case mjlog.FieldInsertedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInsertedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MJLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MJLogMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, mjlog.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MJLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mjlog.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MJLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mjlog.FieldVersion:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown MJLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MJLogMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MJLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MJLogMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MJLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MJLogMutation) ResetField(name string) error {
	switch name {
	case mjlog.FieldVersion:
		m.ResetVersion()
		return nil
	case mjlog.FieldSeed:
		m.ResetSeed()
		return nil
	case mjlog.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case mjlog.FieldInsertedAt:
		m.ResetInsertedAt()
		return nil
	}
	return fmt.Errorf("unknown MJLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MJLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.mjlog_files != nil {
		edges = append(edges, mjlog.EdgeMjlogFiles)
	}
	if m.games != nil {
		edges = append(edges, mjlog.EdgeGames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MJLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mjlog.EdgeMjlogFiles:
		if id := m.mjlog_files; id != nil {
			return []ent.Value{*id}
		}
	case mjlog.EdgeGames:
		if id := m.games; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MJLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MJLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MJLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmjlog_files {
		edges = append(edges, mjlog.EdgeMjlogFiles)
	}
	if m.clearedgames {
		edges = append(edges, mjlog.EdgeGames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MJLogMutation) EdgeCleared(name string) bool {
	switch name {
	case mjlog.EdgeMjlogFiles:
		return m.clearedmjlog_files
	case mjlog.EdgeGames:
		return m.clearedgames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MJLogMutation) ClearEdge(name string) error {
	switch name {
	case mjlog.EdgeMjlogFiles:
		m.ClearMjlogFiles()
		return nil
	case mjlog.EdgeGames:
		m.ClearGames()
		return nil
	}
	return fmt.Errorf("unknown MJLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MJLogMutation) ResetEdge(name string) error {
	switch name {
	case mjlog.EdgeMjlogFiles:
		m.ResetMjlogFiles()
		return nil
	case mjlog.EdgeGames:
		m.ResetGames()
		return nil
	}
	return fmt.Errorf("unknown MJLog edge %s", name)
}

// MJLogFileMutation represents an operation that mutates the MJLogFile nodes in the graph.
type MJLogFileMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	name                          *string
	clearedFields                 map[string]struct{}
	compressed_mjlog_files        *uuid.UUID
	clearedcompressed_mjlog_files bool
	mjlogs                        *uuid.UUID
	clearedmjlogs                 bool
	done                          bool
	oldValue                      func(context.Context) (*MJLogFile, error)
	predicates                    []predicate.MJLogFile
}

var _ ent.Mutation = (*MJLogFileMutation)(nil)

// mjlogfileOption allows management of the mutation configuration using functional options.
type mjlogfileOption func(*MJLogFileMutation)

// newMJLogFileMutation creates new mutation for the MJLogFile entity.
func newMJLogFileMutation(c config, op Op, opts ...mjlogfileOption) *MJLogFileMutation {
	m := &MJLogFileMutation{
		config:        c,
		op:            op,
		typ:           TypeMJLogFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMJLogFileID sets the ID field of the mutation.
func withMJLogFileID(id uuid.UUID) mjlogfileOption {
	return func(m *MJLogFileMutation) {
		var (
			err   error
			once  sync.Once
			value *MJLogFile
		)
		m.oldValue = func(ctx context.Context) (*MJLogFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MJLogFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMJLogFile sets the old MJLogFile of the mutation.
func withMJLogFile(node *MJLogFile) mjlogfileOption {
	return func(m *MJLogFileMutation) {
		m.oldValue = func(context.Context) (*MJLogFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MJLogFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MJLogFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MJLogFile entities.
func (m *MJLogFileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MJLogFileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MJLogFileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MJLogFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MJLogFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MJLogFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MJLogFile entity.
// If the MJLogFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MJLogFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MJLogFileMutation) ResetName() {
	m.name = nil
}

// SetCompressedMjlogFilesID sets the "compressed_mjlog_files" edge to the CompressedMJLog entity by id.
func (m *MJLogFileMutation) SetCompressedMjlogFilesID(id uuid.UUID) {
	m.compressed_mjlog_files = &id
}

// ClearCompressedMjlogFiles clears the "compressed_mjlog_files" edge to the CompressedMJLog entity.
func (m *MJLogFileMutation) ClearCompressedMjlogFiles() {
	m.clearedcompressed_mjlog_files = true
}

// CompressedMjlogFilesCleared reports if the "compressed_mjlog_files" edge to the CompressedMJLog entity was cleared.
func (m *MJLogFileMutation) CompressedMjlogFilesCleared() bool {
	return m.clearedcompressed_mjlog_files
}

// CompressedMjlogFilesID returns the "compressed_mjlog_files" edge ID in the mutation.
func (m *MJLogFileMutation) CompressedMjlogFilesID() (id uuid.UUID, exists bool) {
	if m.compressed_mjlog_files != nil {
		return *m.compressed_mjlog_files, true
	}
	return
}

// CompressedMjlogFilesIDs returns the "compressed_mjlog_files" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompressedMjlogFilesID instead. It exists only for internal usage by the builders.
func (m *MJLogFileMutation) CompressedMjlogFilesIDs() (ids []uuid.UUID) {
	if id := m.compressed_mjlog_files; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompressedMjlogFiles resets all changes to the "compressed_mjlog_files" edge.
func (m *MJLogFileMutation) ResetCompressedMjlogFiles() {
	m.compressed_mjlog_files = nil
	m.clearedcompressed_mjlog_files = false
}

// SetMjlogsID sets the "mjlogs" edge to the MJLog entity by id.
func (m *MJLogFileMutation) SetMjlogsID(id uuid.UUID) {
	m.mjlogs = &id
}

// ClearMjlogs clears the "mjlogs" edge to the MJLog entity.
func (m *MJLogFileMutation) ClearMjlogs() {
	m.clearedmjlogs = true
}

// MjlogsCleared reports if the "mjlogs" edge to the MJLog entity was cleared.
func (m *MJLogFileMutation) MjlogsCleared() bool {
	return m.clearedmjlogs
}

// MjlogsID returns the "mjlogs" edge ID in the mutation.
func (m *MJLogFileMutation) MjlogsID() (id uuid.UUID, exists bool) {
	if m.mjlogs != nil {
		return *m.mjlogs, true
	}
	return
}

// MjlogsIDs returns the "mjlogs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MjlogsID instead. It exists only for internal usage by the builders.
func (m *MJLogFileMutation) MjlogsIDs() (ids []uuid.UUID) {
	if id := m.mjlogs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMjlogs resets all changes to the "mjlogs" edge.
func (m *MJLogFileMutation) ResetMjlogs() {
	m.mjlogs = nil
	m.clearedmjlogs = false
}

// Where appends a list predicates to the MJLogFileMutation builder.
func (m *MJLogFileMutation) Where(ps ...predicate.MJLogFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MJLogFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MJLogFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MJLogFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MJLogFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MJLogFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MJLogFile).
func (m *MJLogFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MJLogFileMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, mjlogfile.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MJLogFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mjlogfile.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MJLogFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mjlogfile.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown MJLogFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MJLogFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mjlogfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown MJLogFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MJLogFileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MJLogFileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MJLogFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MJLogFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MJLogFileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MJLogFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MJLogFileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MJLogFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MJLogFileMutation) ResetField(name string) error {
	switch name {
	case mjlogfile.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown MJLogFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MJLogFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.compressed_mjlog_files != nil {
		edges = append(edges, mjlogfile.EdgeCompressedMjlogFiles)
	}
	if m.mjlogs != nil {
		edges = append(edges, mjlogfile.EdgeMjlogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MJLogFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mjlogfile.EdgeCompressedMjlogFiles:
		if id := m.compressed_mjlog_files; id != nil {
			return []ent.Value{*id}
		}
	case mjlogfile.EdgeMjlogs:
		if id := m.mjlogs; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MJLogFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MJLogFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MJLogFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompressed_mjlog_files {
		edges = append(edges, mjlogfile.EdgeCompressedMjlogFiles)
	}
	if m.clearedmjlogs {
		edges = append(edges, mjlogfile.EdgeMjlogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MJLogFileMutation) EdgeCleared(name string) bool {
	switch name {
	case mjlogfile.EdgeCompressedMjlogFiles:
		return m.clearedcompressed_mjlog_files
	case mjlogfile.EdgeMjlogs:
		return m.clearedmjlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MJLogFileMutation) ClearEdge(name string) error {
	switch name {
	case mjlogfile.EdgeCompressedMjlogFiles:
		m.ClearCompressedMjlogFiles()
		return nil
	case mjlogfile.EdgeMjlogs:
		m.ClearMjlogs()
		return nil
	}
	return fmt.Errorf("unknown MJLogFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MJLogFileMutation) ResetEdge(name string) error {
	switch name {
	case mjlogfile.EdgeCompressedMjlogFiles:
		m.ResetCompressedMjlogFiles()
		return nil
	case mjlogfile.EdgeMjlogs:
		m.ResetMjlogs()
		return nil
	}
	return fmt.Errorf("unknown MJLogFile edge %s", name)
}

// MeldedKanMutation represents an operation that mutates the MeldedKan nodes in the graph.
type MeldedKanMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	call          *uuid.UUID
	clearedcall   bool
	done          bool
	oldValue      func(context.Context) (*MeldedKan, error)
	predicates    []predicate.MeldedKan
}

var _ ent.Mutation = (*MeldedKanMutation)(nil)

// meldedkanOption allows management of the mutation configuration using functional options.
type meldedkanOption func(*MeldedKanMutation)

// newMeldedKanMutation creates new mutation for the MeldedKan entity.
func newMeldedKanMutation(c config, op Op, opts ...meldedkanOption) *MeldedKanMutation {
	m := &MeldedKanMutation{
		config:        c,
		op:            op,
		typ:           TypeMeldedKan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMeldedKanID sets the ID field of the mutation.
func withMeldedKanID(id uuid.UUID) meldedkanOption {
	return func(m *MeldedKanMutation) {
		var (
			err   error
			once  sync.Once
			value *MeldedKan
		)
		m.oldValue = func(ctx context.Context) (*MeldedKan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MeldedKan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeldedKan sets the old MeldedKan of the mutation.
func withMeldedKan(node *MeldedKan) meldedkanOption {
	return func(m *MeldedKanMutation) {
		m.oldValue = func(context.Context) (*MeldedKan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MeldedKanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MeldedKanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MeldedKan entities.
func (m *MeldedKanMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MeldedKanMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MeldedKanMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MeldedKan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallID sets the "call" edge to the Call entity by id.
func (m *MeldedKanMutation) SetCallID(id uuid.UUID) {
	m.call = &id
}

// ClearCall clears the "call" edge to the Call entity.
func (m *MeldedKanMutation) ClearCall() {
	m.clearedcall = true
}

// CallCleared reports if the "call" edge to the Call entity was cleared.
func (m *MeldedKanMutation) CallCleared() bool {
	return m.clearedcall
}

// CallID returns the "call" edge ID in the mutation.
func (m *MeldedKanMutation) CallID() (id uuid.UUID, exists bool) {
	if m.call != nil {
		return *m.call, true
	}
	return
}

// CallIDs returns the "call" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallID instead. It exists only for internal usage by the builders.
func (m *MeldedKanMutation) CallIDs() (ids []uuid.UUID) {
	if id := m.call; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCall resets all changes to the "call" edge.
func (m *MeldedKanMutation) ResetCall() {
	m.call = nil
	m.clearedcall = false
}

// Where appends a list predicates to the MeldedKanMutation builder.
func (m *MeldedKanMutation) Where(ps ...predicate.MeldedKan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MeldedKanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MeldedKanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MeldedKan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MeldedKanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MeldedKanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MeldedKan).
func (m *MeldedKanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MeldedKanMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MeldedKanMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MeldedKanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown MeldedKan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeldedKanMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MeldedKan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MeldedKanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MeldedKanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MeldedKanMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown MeldedKan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MeldedKanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MeldedKanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MeldedKanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MeldedKan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MeldedKanMutation) ResetField(name string) error {
	return fmt.Errorf("unknown MeldedKan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MeldedKanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.call != nil {
		edges = append(edges, meldedkan.EdgeCall)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MeldedKanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case meldedkan.EdgeCall:
		if id := m.call; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MeldedKanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MeldedKanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MeldedKanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcall {
		edges = append(edges, meldedkan.EdgeCall)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MeldedKanMutation) EdgeCleared(name string) bool {
	switch name {
	case meldedkan.EdgeCall:
		return m.clearedcall
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MeldedKanMutation) ClearEdge(name string) error {
	switch name {
	case meldedkan.EdgeCall:
		m.ClearCall()
		return nil
	}
	return fmt.Errorf("unknown MeldedKan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MeldedKanMutation) ResetEdge(name string) error {
	switch name {
	case meldedkan.EdgeCall:
		m.ResetCall()
		return nil
	}
	return fmt.Errorf("unknown MeldedKan edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	name                *string
	sex                 *string
	clearedFields       map[string]struct{}
	game_players        map[uuid.UUID]struct{}
	removedgame_players map[uuid.UUID]struct{}
	clearedgame_players bool
	done                bool
	oldValue            func(context.Context) (*Player, error)
	predicates          []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id uuid.UUID) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Player entities.
func (m *PlayerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Player.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlayerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlayerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlayerMutation) ResetName() {
	m.name = nil
}

// SetSex sets the "sex" field.
func (m *PlayerMutation) SetSex(s string) {
	m.sex = &s
}

// Sex returns the value of the "sex" field in the mutation.
func (m *PlayerMutation) Sex() (r string, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldSex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ResetSex resets all changes to the "sex" field.
func (m *PlayerMutation) ResetSex() {
	m.sex = nil
}

// AddGamePlayerIDs adds the "game_players" edge to the GamePlayer entity by ids.
func (m *PlayerMutation) AddGamePlayerIDs(ids ...uuid.UUID) {
	if m.game_players == nil {
		m.game_players = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.game_players[ids[i]] = struct{}{}
	}
}

// ClearGamePlayers clears the "game_players" edge to the GamePlayer entity.
func (m *PlayerMutation) ClearGamePlayers() {
	m.clearedgame_players = true
}

// GamePlayersCleared reports if the "game_players" edge to the GamePlayer entity was cleared.
func (m *PlayerMutation) GamePlayersCleared() bool {
	return m.clearedgame_players
}

// RemoveGamePlayerIDs removes the "game_players" edge to the GamePlayer entity by IDs.
func (m *PlayerMutation) RemoveGamePlayerIDs(ids ...uuid.UUID) {
	if m.removedgame_players == nil {
		m.removedgame_players = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.game_players, ids[i])
		m.removedgame_players[ids[i]] = struct{}{}
	}
}

// RemovedGamePlayers returns the removed IDs of the "game_players" edge to the GamePlayer entity.
func (m *PlayerMutation) RemovedGamePlayersIDs() (ids []uuid.UUID) {
	for id := range m.removedgame_players {
		ids = append(ids, id)
	}
	return
}

// GamePlayersIDs returns the "game_players" edge IDs in the mutation.
func (m *PlayerMutation) GamePlayersIDs() (ids []uuid.UUID) {
	for id := range m.game_players {
		ids = append(ids, id)
	}
	return
}

// ResetGamePlayers resets all changes to the "game_players" edge.
func (m *PlayerMutation) ResetGamePlayers() {
	m.game_players = nil
	m.clearedgame_players = false
	m.removedgame_players = nil
}

// Where appends a list predicates to the PlayerMutation builder.
func (m *PlayerMutation) Where(ps ...predicate.Player) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Player, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, player.FieldName)
	}
	if m.sex != nil {
		fields = append(fields, player.FieldSex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldName:
		return m.Name()
	case player.FieldSex:
		return m.Sex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldName:
		return m.OldName(ctx)
	case player.FieldSex:
		return m.OldSex(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case player.FieldSex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldName:
		m.ResetName()
		return nil
	case player.FieldSex:
		m.ResetSex()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.game_players != nil {
		edges = append(edges, player.EdgeGamePlayers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeGamePlayers:
		ids := make([]ent.Value, 0, len(m.game_players))
		for id := range m.game_players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgame_players != nil {
		edges = append(edges, player.EdgeGamePlayers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeGamePlayers:
		ids := make([]ent.Value, 0, len(m.removedgame_players))
		for id := range m.removedgame_players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgame_players {
		edges = append(edges, player.EdgeGamePlayers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeGamePlayers:
		return m.clearedgame_players
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeGamePlayers:
		m.ResetGamePlayers()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// PonMutation represents an operation that mutates the Pon nodes in the graph.
type PonMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	call          *uuid.UUID
	clearedcall   bool
	done          bool
	oldValue      func(context.Context) (*Pon, error)
	predicates    []predicate.Pon
}

var _ ent.Mutation = (*PonMutation)(nil)

// ponOption allows management of the mutation configuration using functional options.
type ponOption func(*PonMutation)

// newPonMutation creates new mutation for the Pon entity.
func newPonMutation(c config, op Op, opts ...ponOption) *PonMutation {
	m := &PonMutation{
		config:        c,
		op:            op,
		typ:           TypePon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPonID sets the ID field of the mutation.
func withPonID(id uuid.UUID) ponOption {
	return func(m *PonMutation) {
		var (
			err   error
			once  sync.Once
			value *Pon
		)
		m.oldValue = func(ctx context.Context) (*Pon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPon sets the old Pon of the mutation.
func withPon(node *Pon) ponOption {
	return func(m *PonMutation) {
		m.oldValue = func(context.Context) (*Pon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pon entities.
func (m *PonMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PonMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PonMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallID sets the "call" edge to the Call entity by id.
func (m *PonMutation) SetCallID(id uuid.UUID) {
	m.call = &id
}

// ClearCall clears the "call" edge to the Call entity.
func (m *PonMutation) ClearCall() {
	m.clearedcall = true
}

// CallCleared reports if the "call" edge to the Call entity was cleared.
func (m *PonMutation) CallCleared() bool {
	return m.clearedcall
}

// CallID returns the "call" edge ID in the mutation.
func (m *PonMutation) CallID() (id uuid.UUID, exists bool) {
	if m.call != nil {
		return *m.call, true
	}
	return
}

// CallIDs returns the "call" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallID instead. It exists only for internal usage by the builders.
func (m *PonMutation) CallIDs() (ids []uuid.UUID) {
	if id := m.call; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCall resets all changes to the "call" edge.
func (m *PonMutation) ResetCall() {
	m.call = nil
	m.clearedcall = false
}

// Where appends a list predicates to the PonMutation builder.
func (m *PonMutation) Where(ps ...predicate.Pon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pon).
func (m *PonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PonMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PonMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Pon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PonMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PonMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Pon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PonMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Pon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.call != nil {
		edges = append(edges, pon.EdgeCall)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pon.EdgeCall:
		if id := m.call; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcall {
		edges = append(edges, pon.EdgeCall)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PonMutation) EdgeCleared(name string) bool {
	switch name {
	case pon.EdgeCall:
		return m.clearedcall
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PonMutation) ClearEdge(name string) error {
	switch name {
	case pon.EdgeCall:
		m.ClearCall()
		return nil
	}
	return fmt.Errorf("unknown Pon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PonMutation) ResetEdge(name string) error {
	switch name {
	case pon.EdgeCall:
		m.ResetCall()
		return nil
	}
	return fmt.Errorf("unknown Pon edge %s", name)
}

// ReachMutation represents an operation that mutates the Reach nodes in the graph.
type ReachMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	clearedFields  map[string]struct{}
	event          *uuid.UUID
	clearedevent   bool
	discard        *uuid.UUID
	cleareddiscard bool
	done           bool
	oldValue       func(context.Context) (*Reach, error)
	predicates     []predicate.Reach
}

var _ ent.Mutation = (*ReachMutation)(nil)

// reachOption allows management of the mutation configuration using functional options.
type reachOption func(*ReachMutation)

// newReachMutation creates new mutation for the Reach entity.
func newReachMutation(c config, op Op, opts ...reachOption) *ReachMutation {
	m := &ReachMutation{
		config:        c,
		op:            op,
		typ:           TypeReach,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReachID sets the ID field of the mutation.
func withReachID(id uuid.UUID) reachOption {
	return func(m *ReachMutation) {
		var (
			err   error
			once  sync.Once
			value *Reach
		)
		m.oldValue = func(ctx context.Context) (*Reach, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reach.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReach sets the old Reach of the mutation.
func withReach(node *Reach) reachOption {
	return func(m *ReachMutation) {
		m.oldValue = func(context.Context) (*Reach, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReachMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReachMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reach entities.
func (m *ReachMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReachMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReachMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reach.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *ReachMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *ReachMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *ReachMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *ReachMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *ReachMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *ReachMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetDiscardID sets the "discard" edge to the Discard entity by id.
func (m *ReachMutation) SetDiscardID(id uuid.UUID) {
	m.discard = &id
}

// ClearDiscard clears the "discard" edge to the Discard entity.
func (m *ReachMutation) ClearDiscard() {
	m.cleareddiscard = true
}

// DiscardCleared reports if the "discard" edge to the Discard entity was cleared.
func (m *ReachMutation) DiscardCleared() bool {
	return m.cleareddiscard
}

// DiscardID returns the "discard" edge ID in the mutation.
func (m *ReachMutation) DiscardID() (id uuid.UUID, exists bool) {
	if m.discard != nil {
		return *m.discard, true
	}
	return
}

// DiscardIDs returns the "discard" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DiscardID instead. It exists only for internal usage by the builders.
func (m *ReachMutation) DiscardIDs() (ids []uuid.UUID) {
	if id := m.discard; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDiscard resets all changes to the "discard" edge.
func (m *ReachMutation) ResetDiscard() {
	m.discard = nil
	m.cleareddiscard = false
}

// Where appends a list predicates to the ReachMutation builder.
func (m *ReachMutation) Where(ps ...predicate.Reach) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReachMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReachMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reach, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReachMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReachMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reach).
func (m *ReachMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReachMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReachMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReachMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Reach field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReachMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Reach field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReachMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReachMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReachMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Reach numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReachMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReachMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReachMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Reach nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReachMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Reach field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReachMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.event != nil {
		edges = append(edges, reach.EdgeEvent)
	}
	if m.discard != nil {
		edges = append(edges, reach.EdgeDiscard)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReachMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reach.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case reach.EdgeDiscard:
		if id := m.discard; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReachMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReachMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReachMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedevent {
		edges = append(edges, reach.EdgeEvent)
	}
	if m.cleareddiscard {
		edges = append(edges, reach.EdgeDiscard)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReachMutation) EdgeCleared(name string) bool {
	switch name {
	case reach.EdgeEvent:
		return m.clearedevent
	case reach.EdgeDiscard:
		return m.cleareddiscard
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReachMutation) ClearEdge(name string) error {
	switch name {
	case reach.EdgeEvent:
		m.ClearEvent()
		return nil
	case reach.EdgeDiscard:
		m.ClearDiscard()
		return nil
	}
	return fmt.Errorf("unknown Reach unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReachMutation) ResetEdge(name string) error {
	switch name {
	case reach.EdgeEvent:
		m.ResetEvent()
		return nil
	case reach.EdgeDiscard:
		m.ResetDiscard()
		return nil
	}
	return fmt.Errorf("unknown Reach edge %s", name)
}

// RoomMutation represents an operation that mutates the Room nodes in the graph.
type RoomMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	name          *string
	clearedFields map[string]struct{}
	games         map[uuid.UUID]struct{}
	removedgames  map[uuid.UUID]struct{}
	clearedgames  bool
	done          bool
	oldValue      func(context.Context) (*Room, error)
	predicates    []predicate.Room
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows management of the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for the Room entity.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the ID field of the mutation.
func withRoomID(id uuid.UUID) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Room entities.
func (m *RoomMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoomMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoomMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Room.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoomMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoomMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Room entity.
// If the Room object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoomMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoomMutation) ResetName() {
	m.name = nil
}

// AddGameIDs adds the "games" edge to the Game entity by ids.
func (m *RoomMutation) AddGameIDs(ids ...uuid.UUID) {
	if m.games == nil {
		m.games = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.games[ids[i]] = struct{}{}
	}
}

// ClearGames clears the "games" edge to the Game entity.
func (m *RoomMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *RoomMutation) GamesCleared() bool {
	return m.clearedgames
}

// RemoveGameIDs removes the "games" edge to the Game entity by IDs.
func (m *RoomMutation) RemoveGameIDs(ids ...uuid.UUID) {
	if m.removedgames == nil {
		m.removedgames = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.games, ids[i])
		m.removedgames[ids[i]] = struct{}{}
	}
}

// RemovedGames returns the removed IDs of the "games" edge to the Game entity.
func (m *RoomMutation) RemovedGamesIDs() (ids []uuid.UUID) {
	for id := range m.removedgames {
		ids = append(ids, id)
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
func (m *RoomMutation) GamesIDs() (ids []uuid.UUID) {
	for id := range m.games {
		ids = append(ids, id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *RoomMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
	m.removedgames = nil
}

// Where appends a list predicates to the RoomMutation builder.
func (m *RoomMutation) Where(ps ...predicate.Room) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoomMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoomMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Room, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoomMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, room.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.games != nil {
		edges = append(edges, room.EdgeGames)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeGames:
		ids := make([]ent.Value, 0, len(m.games))
		for id := range m.games {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedgames != nil {
		edges = append(edges, room.EdgeGames)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeGames:
		ids := make([]ent.Value, 0, len(m.removedgames))
		for id := range m.removedgames {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedgames {
		edges = append(edges, room.EdgeGames)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeGames:
		return m.clearedgames
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeGames:
		m.ResetGames()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// RoundMutation represents an operation that mutates the Round nodes in the graph.
type RoundMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	wind          *string
	clearedFields map[string]struct{}
	games         *uuid.UUID
	clearedgames  bool
	hands         map[uuid.UUID]struct{}
	removedhands  map[uuid.UUID]struct{}
	clearedhands  bool
	done          bool
	oldValue      func(context.Context) (*Round, error)
	predicates    []predicate.Round
}

var _ ent.Mutation = (*RoundMutation)(nil)

// roundOption allows management of the mutation configuration using functional options.
type roundOption func(*RoundMutation)

// newRoundMutation creates new mutation for the Round entity.
func newRoundMutation(c config, op Op, opts ...roundOption) *RoundMutation {
	m := &RoundMutation{
		config:        c,
		op:            op,
		typ:           TypeRound,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoundID sets the ID field of the mutation.
func withRoundID(id uuid.UUID) roundOption {
	return func(m *RoundMutation) {
		var (
			err   error
			once  sync.Once
			value *Round
		)
		m.oldValue = func(ctx context.Context) (*Round, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Round.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRound sets the old Round of the mutation.
func withRound(node *Round) roundOption {
	return func(m *RoundMutation) {
		m.oldValue = func(context.Context) (*Round, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Round entities.
func (m *RoundMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoundMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoundMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Round.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWind sets the "wind" field.
func (m *RoundMutation) SetWind(s string) {
	m.wind = &s
}

// Wind returns the value of the "wind" field in the mutation.
func (m *RoundMutation) Wind() (r string, exists bool) {
	v := m.wind
	if v == nil {
		return
	}
	return *v, true
}

// OldWind returns the old "wind" field's value of the Round entity.
// If the Round object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoundMutation) OldWind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWind: %w", err)
	}
	return oldValue.Wind, nil
}

// ResetWind resets all changes to the "wind" field.
func (m *RoundMutation) ResetWind() {
	m.wind = nil
}

// SetGamesID sets the "games" edge to the Game entity by id.
func (m *RoundMutation) SetGamesID(id uuid.UUID) {
	m.games = &id
}

// ClearGames clears the "games" edge to the Game entity.
func (m *RoundMutation) ClearGames() {
	m.clearedgames = true
}

// GamesCleared reports if the "games" edge to the Game entity was cleared.
func (m *RoundMutation) GamesCleared() bool {
	return m.clearedgames
}

// GamesID returns the "games" edge ID in the mutation.
func (m *RoundMutation) GamesID() (id uuid.UUID, exists bool) {
	if m.games != nil {
		return *m.games, true
	}
	return
}

// GamesIDs returns the "games" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GamesID instead. It exists only for internal usage by the builders.
func (m *RoundMutation) GamesIDs() (ids []uuid.UUID) {
	if id := m.games; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGames resets all changes to the "games" edge.
func (m *RoundMutation) ResetGames() {
	m.games = nil
	m.clearedgames = false
}

// AddHandIDs adds the "hands" edge to the Hand entity by ids.
func (m *RoundMutation) AddHandIDs(ids ...uuid.UUID) {
	if m.hands == nil {
		m.hands = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hands[ids[i]] = struct{}{}
	}
}

// ClearHands clears the "hands" edge to the Hand entity.
func (m *RoundMutation) ClearHands() {
	m.clearedhands = true
}

// HandsCleared reports if the "hands" edge to the Hand entity was cleared.
func (m *RoundMutation) HandsCleared() bool {
	return m.clearedhands
}

// RemoveHandIDs removes the "hands" edge to the Hand entity by IDs.
func (m *RoundMutation) RemoveHandIDs(ids ...uuid.UUID) {
	if m.removedhands == nil {
		m.removedhands = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hands, ids[i])
		m.removedhands[ids[i]] = struct{}{}
	}
}

// RemovedHands returns the removed IDs of the "hands" edge to the Hand entity.
func (m *RoundMutation) RemovedHandsIDs() (ids []uuid.UUID) {
	for id := range m.removedhands {
		ids = append(ids, id)
	}
	return
}

// HandsIDs returns the "hands" edge IDs in the mutation.
func (m *RoundMutation) HandsIDs() (ids []uuid.UUID) {
	for id := range m.hands {
		ids = append(ids, id)
	}
	return
}

// ResetHands resets all changes to the "hands" edge.
func (m *RoundMutation) ResetHands() {
	m.hands = nil
	m.clearedhands = false
	m.removedhands = nil
}

// Where appends a list predicates to the RoundMutation builder.
func (m *RoundMutation) Where(ps ...predicate.Round) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Round, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Round).
func (m *RoundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoundMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.wind != nil {
		fields = append(fields, round.FieldWind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case round.FieldWind:
		return m.Wind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case round.FieldWind:
		return m.OldWind(ctx)
	}
	return nil, fmt.Errorf("unknown Round field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case round.FieldWind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWind(v)
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoundMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoundMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoundMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Round numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoundMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoundMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Round nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoundMutation) ResetField(name string) error {
	switch name {
	case round.FieldWind:
		m.ResetWind()
		return nil
	}
	return fmt.Errorf("unknown Round field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoundMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.games != nil {
		edges = append(edges, round.EdgeGames)
	}
	if m.hands != nil {
		edges = append(edges, round.EdgeHands)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeGames:
		if id := m.games; id != nil {
			return []ent.Value{*id}
		}
	case round.EdgeHands:
		ids := make([]ent.Value, 0, len(m.hands))
		for id := range m.hands {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhands != nil {
		edges = append(edges, round.EdgeHands)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case round.EdgeHands:
		ids := make([]ent.Value, 0, len(m.removedhands))
		for id := range m.removedhands {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedgames {
		edges = append(edges, round.EdgeGames)
	}
	if m.clearedhands {
		edges = append(edges, round.EdgeHands)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoundMutation) EdgeCleared(name string) bool {
	switch name {
	case round.EdgeGames:
		return m.clearedgames
	case round.EdgeHands:
		return m.clearedhands
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoundMutation) ClearEdge(name string) error {
	switch name {
	case round.EdgeGames:
		m.ClearGames()
		return nil
	}
	return fmt.Errorf("unknown Round unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoundMutation) ResetEdge(name string) error {
	switch name {
	case round.EdgeGames:
		m.ResetGames()
		return nil
	case round.EdgeHands:
		m.ResetHands()
		return nil
	}
	return fmt.Errorf("unknown Round edge %s", name)
}

// TurnMutation represents an operation that mutates the Turn nodes in the graph.
type TurnMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	num                       *uint
	addnum                    *int
	clearedFields             map[string]struct{}
	hands                     map[uuid.UUID]struct{}
	removedhands              map[uuid.UUID]struct{}
	clearedhands              bool
	game_player_points        map[uuid.UUID]struct{}
	removedgame_player_points map[uuid.UUID]struct{}
	clearedgame_player_points bool
	event                     *uuid.UUID
	clearedevent              bool
	gameplayerhandhai         *uuid.UUID
	clearedgameplayerhandhai  bool
	done                      bool
	oldValue                  func(context.Context) (*Turn, error)
	predicates                []predicate.Turn
}

var _ ent.Mutation = (*TurnMutation)(nil)

// turnOption allows management of the mutation configuration using functional options.
type turnOption func(*TurnMutation)

// newTurnMutation creates new mutation for the Turn entity.
func newTurnMutation(c config, op Op, opts ...turnOption) *TurnMutation {
	m := &TurnMutation{
		config:        c,
		op:            op,
		typ:           TypeTurn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTurnID sets the ID field of the mutation.
func withTurnID(id uuid.UUID) turnOption {
	return func(m *TurnMutation) {
		var (
			err   error
			once  sync.Once
			value *Turn
		)
		m.oldValue = func(ctx context.Context) (*Turn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Turn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTurn sets the old Turn of the mutation.
func withTurn(node *Turn) turnOption {
	return func(m *TurnMutation) {
		m.oldValue = func(context.Context) (*Turn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TurnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TurnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Turn entities.
func (m *TurnMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TurnMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TurnMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Turn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNum sets the "num" field.
func (m *TurnMutation) SetNum(u uint) {
	m.num = &u
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *TurnMutation) Num() (r uint, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Turn entity.
// If the Turn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TurnMutation) OldNum(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds u to the "num" field.
func (m *TurnMutation) AddNum(u int) {
	if m.addnum != nil {
		*m.addnum += u
	} else {
		m.addnum = &u
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *TurnMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *TurnMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// AddHandIDs adds the "hands" edge to the Hand entity by ids.
func (m *TurnMutation) AddHandIDs(ids ...uuid.UUID) {
	if m.hands == nil {
		m.hands = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.hands[ids[i]] = struct{}{}
	}
}

// ClearHands clears the "hands" edge to the Hand entity.
func (m *TurnMutation) ClearHands() {
	m.clearedhands = true
}

// HandsCleared reports if the "hands" edge to the Hand entity was cleared.
func (m *TurnMutation) HandsCleared() bool {
	return m.clearedhands
}

// RemoveHandIDs removes the "hands" edge to the Hand entity by IDs.
func (m *TurnMutation) RemoveHandIDs(ids ...uuid.UUID) {
	if m.removedhands == nil {
		m.removedhands = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.hands, ids[i])
		m.removedhands[ids[i]] = struct{}{}
	}
}

// RemovedHands returns the removed IDs of the "hands" edge to the Hand entity.
func (m *TurnMutation) RemovedHandsIDs() (ids []uuid.UUID) {
	for id := range m.removedhands {
		ids = append(ids, id)
	}
	return
}

// HandsIDs returns the "hands" edge IDs in the mutation.
func (m *TurnMutation) HandsIDs() (ids []uuid.UUID) {
	for id := range m.hands {
		ids = append(ids, id)
	}
	return
}

// ResetHands resets all changes to the "hands" edge.
func (m *TurnMutation) ResetHands() {
	m.hands = nil
	m.clearedhands = false
	m.removedhands = nil
}

// AddGamePlayerPointIDs adds the "game_player_points" edge to the GamePlayerPoint entity by ids.
func (m *TurnMutation) AddGamePlayerPointIDs(ids ...uuid.UUID) {
	if m.game_player_points == nil {
		m.game_player_points = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.game_player_points[ids[i]] = struct{}{}
	}
}

// ClearGamePlayerPoints clears the "game_player_points" edge to the GamePlayerPoint entity.
func (m *TurnMutation) ClearGamePlayerPoints() {
	m.clearedgame_player_points = true
}

// GamePlayerPointsCleared reports if the "game_player_points" edge to the GamePlayerPoint entity was cleared.
func (m *TurnMutation) GamePlayerPointsCleared() bool {
	return m.clearedgame_player_points
}

// RemoveGamePlayerPointIDs removes the "game_player_points" edge to the GamePlayerPoint entity by IDs.
func (m *TurnMutation) RemoveGamePlayerPointIDs(ids ...uuid.UUID) {
	if m.removedgame_player_points == nil {
		m.removedgame_player_points = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.game_player_points, ids[i])
		m.removedgame_player_points[ids[i]] = struct{}{}
	}
}

// RemovedGamePlayerPoints returns the removed IDs of the "game_player_points" edge to the GamePlayerPoint entity.
func (m *TurnMutation) RemovedGamePlayerPointsIDs() (ids []uuid.UUID) {
	for id := range m.removedgame_player_points {
		ids = append(ids, id)
	}
	return
}

// GamePlayerPointsIDs returns the "game_player_points" edge IDs in the mutation.
func (m *TurnMutation) GamePlayerPointsIDs() (ids []uuid.UUID) {
	for id := range m.game_player_points {
		ids = append(ids, id)
	}
	return
}

// ResetGamePlayerPoints resets all changes to the "game_player_points" edge.
func (m *TurnMutation) ResetGamePlayerPoints() {
	m.game_player_points = nil
	m.clearedgame_player_points = false
	m.removedgame_player_points = nil
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *TurnMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *TurnMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *TurnMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *TurnMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *TurnMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *TurnMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// SetGameplayerhandhaiID sets the "gameplayerhandhai" edge to the GamePlayerHandHai entity by id.
func (m *TurnMutation) SetGameplayerhandhaiID(id uuid.UUID) {
	m.gameplayerhandhai = &id
}

// ClearGameplayerhandhai clears the "gameplayerhandhai" edge to the GamePlayerHandHai entity.
func (m *TurnMutation) ClearGameplayerhandhai() {
	m.clearedgameplayerhandhai = true
}

// GameplayerhandhaiCleared reports if the "gameplayerhandhai" edge to the GamePlayerHandHai entity was cleared.
func (m *TurnMutation) GameplayerhandhaiCleared() bool {
	return m.clearedgameplayerhandhai
}

// GameplayerhandhaiID returns the "gameplayerhandhai" edge ID in the mutation.
func (m *TurnMutation) GameplayerhandhaiID() (id uuid.UUID, exists bool) {
	if m.gameplayerhandhai != nil {
		return *m.gameplayerhandhai, true
	}
	return
}

// GameplayerhandhaiIDs returns the "gameplayerhandhai" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GameplayerhandhaiID instead. It exists only for internal usage by the builders.
func (m *TurnMutation) GameplayerhandhaiIDs() (ids []uuid.UUID) {
	if id := m.gameplayerhandhai; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGameplayerhandhai resets all changes to the "gameplayerhandhai" edge.
func (m *TurnMutation) ResetGameplayerhandhai() {
	m.gameplayerhandhai = nil
	m.clearedgameplayerhandhai = false
}

// Where appends a list predicates to the TurnMutation builder.
func (m *TurnMutation) Where(ps ...predicate.Turn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TurnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TurnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Turn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TurnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TurnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Turn).
func (m *TurnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TurnMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.num != nil {
		fields = append(fields, turn.FieldNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TurnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case turn.FieldNum:
		return m.Num()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TurnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case turn.FieldNum:
		return m.OldNum(ctx)
	}
	return nil, fmt.Errorf("unknown Turn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TurnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case turn.FieldNum:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	}
	return fmt.Errorf("unknown Turn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TurnMutation) AddedFields() []string {
	var fields []string
	if m.addnum != nil {
		fields = append(fields, turn.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TurnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case turn.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TurnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case turn.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown Turn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TurnMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TurnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TurnMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Turn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TurnMutation) ResetField(name string) error {
	switch name {
	case turn.FieldNum:
		m.ResetNum()
		return nil
	}
	return fmt.Errorf("unknown Turn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TurnMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.hands != nil {
		edges = append(edges, turn.EdgeHands)
	}
	if m.game_player_points != nil {
		edges = append(edges, turn.EdgeGamePlayerPoints)
	}
	if m.event != nil {
		edges = append(edges, turn.EdgeEvent)
	}
	if m.gameplayerhandhai != nil {
		edges = append(edges, turn.EdgeGameplayerhandhai)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TurnMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case turn.EdgeHands:
		ids := make([]ent.Value, 0, len(m.hands))
		for id := range m.hands {
			ids = append(ids, id)
		}
		return ids
	case turn.EdgeGamePlayerPoints:
		ids := make([]ent.Value, 0, len(m.game_player_points))
		for id := range m.game_player_points {
			ids = append(ids, id)
		}
		return ids
	case turn.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	case turn.EdgeGameplayerhandhai:
		if id := m.gameplayerhandhai; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TurnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedhands != nil {
		edges = append(edges, turn.EdgeHands)
	}
	if m.removedgame_player_points != nil {
		edges = append(edges, turn.EdgeGamePlayerPoints)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TurnMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case turn.EdgeHands:
		ids := make([]ent.Value, 0, len(m.removedhands))
		for id := range m.removedhands {
			ids = append(ids, id)
		}
		return ids
	case turn.EdgeGamePlayerPoints:
		ids := make([]ent.Value, 0, len(m.removedgame_player_points))
		for id := range m.removedgame_player_points {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TurnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedhands {
		edges = append(edges, turn.EdgeHands)
	}
	if m.clearedgame_player_points {
		edges = append(edges, turn.EdgeGamePlayerPoints)
	}
	if m.clearedevent {
		edges = append(edges, turn.EdgeEvent)
	}
	if m.clearedgameplayerhandhai {
		edges = append(edges, turn.EdgeGameplayerhandhai)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TurnMutation) EdgeCleared(name string) bool {
	switch name {
	case turn.EdgeHands:
		return m.clearedhands
	case turn.EdgeGamePlayerPoints:
		return m.clearedgame_player_points
	case turn.EdgeEvent:
		return m.clearedevent
	case turn.EdgeGameplayerhandhai:
		return m.clearedgameplayerhandhai
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TurnMutation) ClearEdge(name string) error {
	switch name {
	case turn.EdgeEvent:
		m.ClearEvent()
		return nil
	case turn.EdgeGameplayerhandhai:
		m.ClearGameplayerhandhai()
		return nil
	}
	return fmt.Errorf("unknown Turn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TurnMutation) ResetEdge(name string) error {
	switch name {
	case turn.EdgeHands:
		m.ResetHands()
		return nil
	case turn.EdgeGamePlayerPoints:
		m.ResetGamePlayerPoints()
		return nil
	case turn.EdgeEvent:
		m.ResetEvent()
		return nil
	case turn.EdgeGameplayerhandhai:
		m.ResetGameplayerhandhai()
		return nil
	}
	return fmt.Errorf("unknown Turn edge %s", name)
}

// WinMutation represents an operation that mutates the Win nodes in the graph.
type WinMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	clearedFields map[string]struct{}
	event         *uuid.UUID
	clearedevent  bool
	done          bool
	oldValue      func(context.Context) (*Win, error)
	predicates    []predicate.Win
}

var _ ent.Mutation = (*WinMutation)(nil)

// winOption allows management of the mutation configuration using functional options.
type winOption func(*WinMutation)

// newWinMutation creates new mutation for the Win entity.
func newWinMutation(c config, op Op, opts ...winOption) *WinMutation {
	m := &WinMutation{
		config:        c,
		op:            op,
		typ:           TypeWin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWinID sets the ID field of the mutation.
func withWinID(id uuid.UUID) winOption {
	return func(m *WinMutation) {
		var (
			err   error
			once  sync.Once
			value *Win
		)
		m.oldValue = func(ctx context.Context) (*Win, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Win.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWin sets the old Win of the mutation.
func withWin(node *Win) winOption {
	return func(m *WinMutation) {
		m.oldValue = func(context.Context) (*Win, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Win entities.
func (m *WinMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WinMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WinMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Win.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventID sets the "event" edge to the Event entity by id.
func (m *WinMutation) SetEventID(id uuid.UUID) {
	m.event = &id
}

// ClearEvent clears the "event" edge to the Event entity.
func (m *WinMutation) ClearEvent() {
	m.clearedevent = true
}

// EventCleared reports if the "event" edge to the Event entity was cleared.
func (m *WinMutation) EventCleared() bool {
	return m.clearedevent
}

// EventID returns the "event" edge ID in the mutation.
func (m *WinMutation) EventID() (id uuid.UUID, exists bool) {
	if m.event != nil {
		return *m.event, true
	}
	return
}

// EventIDs returns the "event" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EventID instead. It exists only for internal usage by the builders.
func (m *WinMutation) EventIDs() (ids []uuid.UUID) {
	if id := m.event; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEvent resets all changes to the "event" edge.
func (m *WinMutation) ResetEvent() {
	m.event = nil
	m.clearedevent = false
}

// Where appends a list predicates to the WinMutation builder.
func (m *WinMutation) Where(ps ...predicate.Win) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WinMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WinMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Win, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WinMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WinMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Win).
func (m *WinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WinMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WinMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Win field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Win field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WinMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WinMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WinMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Win numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WinMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WinMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Win nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WinMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Win field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WinMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.event != nil {
		edges = append(edges, win.EdgeEvent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WinMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case win.EdgeEvent:
		if id := m.event; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevent {
		edges = append(edges, win.EdgeEvent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WinMutation) EdgeCleared(name string) bool {
	switch name {
	case win.EdgeEvent:
		return m.clearedevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WinMutation) ClearEdge(name string) error {
	switch name {
	case win.EdgeEvent:
		m.ClearEvent()
		return nil
	}
	return fmt.Errorf("unknown Win unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WinMutation) ResetEdge(name string) error {
	switch name {
	case win.EdgeEvent:
		m.ResetEvent()
		return nil
	}
	return fmt.Errorf("unknown Win edge %s", name)
}
