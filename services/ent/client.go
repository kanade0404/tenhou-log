// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/kanade0404/tenhou-log/services/ent/migrate"

	"github.com/kanade0404/tenhou-log/services/ent/chakan"
	"github.com/kanade0404/tenhou-log/services/ent/chii"
	"github.com/kanade0404/tenhou-log/services/ent/compressedmjlog"
	"github.com/kanade0404/tenhou-log/services/ent/concealedkan"
	"github.com/kanade0404/tenhou-log/services/ent/dan"
	"github.com/kanade0404/tenhou-log/services/ent/drawn"
	"github.com/kanade0404/tenhou-log/services/ent/game"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayer"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerhandhai"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerpoint"
	"github.com/kanade0404/tenhou-log/services/ent/hand"
	"github.com/kanade0404/tenhou-log/services/ent/meldedkan"
	"github.com/kanade0404/tenhou-log/services/ent/mjlog"
	"github.com/kanade0404/tenhou-log/services/ent/mjlogfile"
	"github.com/kanade0404/tenhou-log/services/ent/player"
	"github.com/kanade0404/tenhou-log/services/ent/pon"
	"github.com/kanade0404/tenhou-log/services/ent/room"
	"github.com/kanade0404/tenhou-log/services/ent/round"
	"github.com/kanade0404/tenhou-log/services/ent/turn"
	"github.com/kanade0404/tenhou-log/services/ent/win"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Chakan is the client for interacting with the Chakan builders.
	Chakan *ChakanClient
	// Chii is the client for interacting with the Chii builders.
	Chii *ChiiClient
	// CompressedMJLog is the client for interacting with the CompressedMJLog builders.
	CompressedMJLog *CompressedMJLogClient
	// ConcealedKan is the client for interacting with the ConcealedKan builders.
	ConcealedKan *ConcealedKanClient
	// Dan is the client for interacting with the Dan builders.
	Dan *DanClient
	// Drawn is the client for interacting with the Drawn builders.
	Drawn *DrawnClient
	// Game is the client for interacting with the Game builders.
	Game *GameClient
	// GamePlayer is the client for interacting with the GamePlayer builders.
	GamePlayer *GamePlayerClient
	// GamePlayerHandHai is the client for interacting with the GamePlayerHandHai builders.
	GamePlayerHandHai *GamePlayerHandHaiClient
	// GamePlayerPoint is the client for interacting with the GamePlayerPoint builders.
	GamePlayerPoint *GamePlayerPointClient
	// Hand is the client for interacting with the Hand builders.
	Hand *HandClient
	// MJLog is the client for interacting with the MJLog builders.
	MJLog *MJLogClient
	// MJLogFile is the client for interacting with the MJLogFile builders.
	MJLogFile *MJLogFileClient
	// MeldedKan is the client for interacting with the MeldedKan builders.
	MeldedKan *MeldedKanClient
	// Player is the client for interacting with the Player builders.
	Player *PlayerClient
	// Pon is the client for interacting with the Pon builders.
	Pon *PonClient
	// Room is the client for interacting with the Room builders.
	Room *RoomClient
	// Round is the client for interacting with the Round builders.
	Round *RoundClient
	// Turn is the client for interacting with the Turn builders.
	Turn *TurnClient
	// Win is the client for interacting with the Win builders.
	Win *WinClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Chakan = NewChakanClient(c.config)
	c.Chii = NewChiiClient(c.config)
	c.CompressedMJLog = NewCompressedMJLogClient(c.config)
	c.ConcealedKan = NewConcealedKanClient(c.config)
	c.Dan = NewDanClient(c.config)
	c.Drawn = NewDrawnClient(c.config)
	c.Game = NewGameClient(c.config)
	c.GamePlayer = NewGamePlayerClient(c.config)
	c.GamePlayerHandHai = NewGamePlayerHandHaiClient(c.config)
	c.GamePlayerPoint = NewGamePlayerPointClient(c.config)
	c.Hand = NewHandClient(c.config)
	c.MJLog = NewMJLogClient(c.config)
	c.MJLogFile = NewMJLogFileClient(c.config)
	c.MeldedKan = NewMeldedKanClient(c.config)
	c.Player = NewPlayerClient(c.config)
	c.Pon = NewPonClient(c.config)
	c.Room = NewRoomClient(c.config)
	c.Round = NewRoundClient(c.config)
	c.Turn = NewTurnClient(c.config)
	c.Win = NewWinClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Chakan:            NewChakanClient(cfg),
		Chii:              NewChiiClient(cfg),
		CompressedMJLog:   NewCompressedMJLogClient(cfg),
		ConcealedKan:      NewConcealedKanClient(cfg),
		Dan:               NewDanClient(cfg),
		Drawn:             NewDrawnClient(cfg),
		Game:              NewGameClient(cfg),
		GamePlayer:        NewGamePlayerClient(cfg),
		GamePlayerHandHai: NewGamePlayerHandHaiClient(cfg),
		GamePlayerPoint:   NewGamePlayerPointClient(cfg),
		Hand:              NewHandClient(cfg),
		MJLog:             NewMJLogClient(cfg),
		MJLogFile:         NewMJLogFileClient(cfg),
		MeldedKan:         NewMeldedKanClient(cfg),
		Player:            NewPlayerClient(cfg),
		Pon:               NewPonClient(cfg),
		Room:              NewRoomClient(cfg),
		Round:             NewRoundClient(cfg),
		Turn:              NewTurnClient(cfg),
		Win:               NewWinClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Chakan:            NewChakanClient(cfg),
		Chii:              NewChiiClient(cfg),
		CompressedMJLog:   NewCompressedMJLogClient(cfg),
		ConcealedKan:      NewConcealedKanClient(cfg),
		Dan:               NewDanClient(cfg),
		Drawn:             NewDrawnClient(cfg),
		Game:              NewGameClient(cfg),
		GamePlayer:        NewGamePlayerClient(cfg),
		GamePlayerHandHai: NewGamePlayerHandHaiClient(cfg),
		GamePlayerPoint:   NewGamePlayerPointClient(cfg),
		Hand:              NewHandClient(cfg),
		MJLog:             NewMJLogClient(cfg),
		MJLogFile:         NewMJLogFileClient(cfg),
		MeldedKan:         NewMeldedKanClient(cfg),
		Player:            NewPlayerClient(cfg),
		Pon:               NewPonClient(cfg),
		Room:              NewRoomClient(cfg),
		Round:             NewRoundClient(cfg),
		Turn:              NewTurnClient(cfg),
		Win:               NewWinClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Chakan.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Chakan.Use(hooks...)
	c.Chii.Use(hooks...)
	c.CompressedMJLog.Use(hooks...)
	c.ConcealedKan.Use(hooks...)
	c.Dan.Use(hooks...)
	c.Drawn.Use(hooks...)
	c.Game.Use(hooks...)
	c.GamePlayer.Use(hooks...)
	c.GamePlayerHandHai.Use(hooks...)
	c.GamePlayerPoint.Use(hooks...)
	c.Hand.Use(hooks...)
	c.MJLog.Use(hooks...)
	c.MJLogFile.Use(hooks...)
	c.MeldedKan.Use(hooks...)
	c.Player.Use(hooks...)
	c.Pon.Use(hooks...)
	c.Room.Use(hooks...)
	c.Round.Use(hooks...)
	c.Turn.Use(hooks...)
	c.Win.Use(hooks...)
}

// ChakanClient is a client for the Chakan schema.
type ChakanClient struct {
	config
}

// NewChakanClient returns a client for the Chakan from the given config.
func NewChakanClient(c config) *ChakanClient {
	return &ChakanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chakan.Hooks(f(g(h())))`.
func (c *ChakanClient) Use(hooks ...Hook) {
	c.hooks.Chakan = append(c.hooks.Chakan, hooks...)
}

// Create returns a builder for creating a Chakan entity.
func (c *ChakanClient) Create() *ChakanCreate {
	mutation := newChakanMutation(c.config, OpCreate)
	return &ChakanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Chakan entities.
func (c *ChakanClient) CreateBulk(builders ...*ChakanCreate) *ChakanCreateBulk {
	return &ChakanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Chakan.
func (c *ChakanClient) Update() *ChakanUpdate {
	mutation := newChakanMutation(c.config, OpUpdate)
	return &ChakanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChakanClient) UpdateOne(ch *Chakan) *ChakanUpdateOne {
	mutation := newChakanMutation(c.config, OpUpdateOne, withChakan(ch))
	return &ChakanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChakanClient) UpdateOneID(id int) *ChakanUpdateOne {
	mutation := newChakanMutation(c.config, OpUpdateOne, withChakanID(id))
	return &ChakanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Chakan.
func (c *ChakanClient) Delete() *ChakanDelete {
	mutation := newChakanMutation(c.config, OpDelete)
	return &ChakanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChakanClient) DeleteOne(ch *Chakan) *ChakanDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChakanClient) DeleteOneID(id int) *ChakanDeleteOne {
	builder := c.Delete().Where(chakan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChakanDeleteOne{builder}
}

// Query returns a query builder for Chakan.
func (c *ChakanClient) Query() *ChakanQuery {
	return &ChakanQuery{
		config: c.config,
	}
}

// Get returns a Chakan entity by its id.
func (c *ChakanClient) Get(ctx context.Context, id int) (*Chakan, error) {
	return c.Query().Where(chakan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChakanClient) GetX(ctx context.Context, id int) *Chakan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ChakanClient) Hooks() []Hook {
	return c.hooks.Chakan
}

// ChiiClient is a client for the Chii schema.
type ChiiClient struct {
	config
}

// NewChiiClient returns a client for the Chii from the given config.
func NewChiiClient(c config) *ChiiClient {
	return &ChiiClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chii.Hooks(f(g(h())))`.
func (c *ChiiClient) Use(hooks ...Hook) {
	c.hooks.Chii = append(c.hooks.Chii, hooks...)
}

// Create returns a builder for creating a Chii entity.
func (c *ChiiClient) Create() *ChiiCreate {
	mutation := newChiiMutation(c.config, OpCreate)
	return &ChiiCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Chii entities.
func (c *ChiiClient) CreateBulk(builders ...*ChiiCreate) *ChiiCreateBulk {
	return &ChiiCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Chii.
func (c *ChiiClient) Update() *ChiiUpdate {
	mutation := newChiiMutation(c.config, OpUpdate)
	return &ChiiUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChiiClient) UpdateOne(ch *Chii) *ChiiUpdateOne {
	mutation := newChiiMutation(c.config, OpUpdateOne, withChii(ch))
	return &ChiiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChiiClient) UpdateOneID(id int) *ChiiUpdateOne {
	mutation := newChiiMutation(c.config, OpUpdateOne, withChiiID(id))
	return &ChiiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Chii.
func (c *ChiiClient) Delete() *ChiiDelete {
	mutation := newChiiMutation(c.config, OpDelete)
	return &ChiiDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChiiClient) DeleteOne(ch *Chii) *ChiiDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChiiClient) DeleteOneID(id int) *ChiiDeleteOne {
	builder := c.Delete().Where(chii.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChiiDeleteOne{builder}
}

// Query returns a query builder for Chii.
func (c *ChiiClient) Query() *ChiiQuery {
	return &ChiiQuery{
		config: c.config,
	}
}

// Get returns a Chii entity by its id.
func (c *ChiiClient) Get(ctx context.Context, id int) (*Chii, error) {
	return c.Query().Where(chii.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChiiClient) GetX(ctx context.Context, id int) *Chii {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ChiiClient) Hooks() []Hook {
	return c.hooks.Chii
}

// CompressedMJLogClient is a client for the CompressedMJLog schema.
type CompressedMJLogClient struct {
	config
}

// NewCompressedMJLogClient returns a client for the CompressedMJLog from the given config.
func NewCompressedMJLogClient(c config) *CompressedMJLogClient {
	return &CompressedMJLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `compressedmjlog.Hooks(f(g(h())))`.
func (c *CompressedMJLogClient) Use(hooks ...Hook) {
	c.hooks.CompressedMJLog = append(c.hooks.CompressedMJLog, hooks...)
}

// Create returns a builder for creating a CompressedMJLog entity.
func (c *CompressedMJLogClient) Create() *CompressedMJLogCreate {
	mutation := newCompressedMJLogMutation(c.config, OpCreate)
	return &CompressedMJLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CompressedMJLog entities.
func (c *CompressedMJLogClient) CreateBulk(builders ...*CompressedMJLogCreate) *CompressedMJLogCreateBulk {
	return &CompressedMJLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CompressedMJLog.
func (c *CompressedMJLogClient) Update() *CompressedMJLogUpdate {
	mutation := newCompressedMJLogMutation(c.config, OpUpdate)
	return &CompressedMJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompressedMJLogClient) UpdateOne(cml *CompressedMJLog) *CompressedMJLogUpdateOne {
	mutation := newCompressedMJLogMutation(c.config, OpUpdateOne, withCompressedMJLog(cml))
	return &CompressedMJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompressedMJLogClient) UpdateOneID(id uuid.UUID) *CompressedMJLogUpdateOne {
	mutation := newCompressedMJLogMutation(c.config, OpUpdateOne, withCompressedMJLogID(id))
	return &CompressedMJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CompressedMJLog.
func (c *CompressedMJLogClient) Delete() *CompressedMJLogDelete {
	mutation := newCompressedMJLogMutation(c.config, OpDelete)
	return &CompressedMJLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompressedMJLogClient) DeleteOne(cml *CompressedMJLog) *CompressedMJLogDeleteOne {
	return c.DeleteOneID(cml.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompressedMJLogClient) DeleteOneID(id uuid.UUID) *CompressedMJLogDeleteOne {
	builder := c.Delete().Where(compressedmjlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompressedMJLogDeleteOne{builder}
}

// Query returns a query builder for CompressedMJLog.
func (c *CompressedMJLogClient) Query() *CompressedMJLogQuery {
	return &CompressedMJLogQuery{
		config: c.config,
	}
}

// Get returns a CompressedMJLog entity by its id.
func (c *CompressedMJLogClient) Get(ctx context.Context, id uuid.UUID) (*CompressedMJLog, error) {
	return c.Query().Where(compressedmjlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompressedMJLogClient) GetX(ctx context.Context, id uuid.UUID) *CompressedMJLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogFiles queries the mjlog_files edge of a CompressedMJLog.
func (c *CompressedMJLogClient) QueryMjlogFiles(cml *CompressedMJLog) *MJLogFileQuery {
	query := &MJLogFileQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(compressedmjlog.Table, compressedmjlog.FieldID, id),
			sqlgraph.To(mjlogfile.Table, mjlogfile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, compressedmjlog.MjlogFilesTable, compressedmjlog.MjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(cml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompressedMJLogClient) Hooks() []Hook {
	return c.hooks.CompressedMJLog
}

// ConcealedKanClient is a client for the ConcealedKan schema.
type ConcealedKanClient struct {
	config
}

// NewConcealedKanClient returns a client for the ConcealedKan from the given config.
func NewConcealedKanClient(c config) *ConcealedKanClient {
	return &ConcealedKanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `concealedkan.Hooks(f(g(h())))`.
func (c *ConcealedKanClient) Use(hooks ...Hook) {
	c.hooks.ConcealedKan = append(c.hooks.ConcealedKan, hooks...)
}

// Create returns a builder for creating a ConcealedKan entity.
func (c *ConcealedKanClient) Create() *ConcealedKanCreate {
	mutation := newConcealedKanMutation(c.config, OpCreate)
	return &ConcealedKanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConcealedKan entities.
func (c *ConcealedKanClient) CreateBulk(builders ...*ConcealedKanCreate) *ConcealedKanCreateBulk {
	return &ConcealedKanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConcealedKan.
func (c *ConcealedKanClient) Update() *ConcealedKanUpdate {
	mutation := newConcealedKanMutation(c.config, OpUpdate)
	return &ConcealedKanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConcealedKanClient) UpdateOne(ck *ConcealedKan) *ConcealedKanUpdateOne {
	mutation := newConcealedKanMutation(c.config, OpUpdateOne, withConcealedKan(ck))
	return &ConcealedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConcealedKanClient) UpdateOneID(id int) *ConcealedKanUpdateOne {
	mutation := newConcealedKanMutation(c.config, OpUpdateOne, withConcealedKanID(id))
	return &ConcealedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConcealedKan.
func (c *ConcealedKanClient) Delete() *ConcealedKanDelete {
	mutation := newConcealedKanMutation(c.config, OpDelete)
	return &ConcealedKanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConcealedKanClient) DeleteOne(ck *ConcealedKan) *ConcealedKanDeleteOne {
	return c.DeleteOneID(ck.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConcealedKanClient) DeleteOneID(id int) *ConcealedKanDeleteOne {
	builder := c.Delete().Where(concealedkan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConcealedKanDeleteOne{builder}
}

// Query returns a query builder for ConcealedKan.
func (c *ConcealedKanClient) Query() *ConcealedKanQuery {
	return &ConcealedKanQuery{
		config: c.config,
	}
}

// Get returns a ConcealedKan entity by its id.
func (c *ConcealedKanClient) Get(ctx context.Context, id int) (*ConcealedKan, error) {
	return c.Query().Where(concealedkan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConcealedKanClient) GetX(ctx context.Context, id int) *ConcealedKan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConcealedKanClient) Hooks() []Hook {
	return c.hooks.ConcealedKan
}

// DanClient is a client for the Dan schema.
type DanClient struct {
	config
}

// NewDanClient returns a client for the Dan from the given config.
func NewDanClient(c config) *DanClient {
	return &DanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dan.Hooks(f(g(h())))`.
func (c *DanClient) Use(hooks ...Hook) {
	c.hooks.Dan = append(c.hooks.Dan, hooks...)
}

// Create returns a builder for creating a Dan entity.
func (c *DanClient) Create() *DanCreate {
	mutation := newDanMutation(c.config, OpCreate)
	return &DanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dan entities.
func (c *DanClient) CreateBulk(builders ...*DanCreate) *DanCreateBulk {
	return &DanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dan.
func (c *DanClient) Update() *DanUpdate {
	mutation := newDanMutation(c.config, OpUpdate)
	return &DanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DanClient) UpdateOne(d *Dan) *DanUpdateOne {
	mutation := newDanMutation(c.config, OpUpdateOne, withDan(d))
	return &DanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DanClient) UpdateOneID(id uuid.UUID) *DanUpdateOne {
	mutation := newDanMutation(c.config, OpUpdateOne, withDanID(id))
	return &DanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dan.
func (c *DanClient) Delete() *DanDelete {
	mutation := newDanMutation(c.config, OpDelete)
	return &DanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DanClient) DeleteOne(d *Dan) *DanDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DanClient) DeleteOneID(id uuid.UUID) *DanDeleteOne {
	builder := c.Delete().Where(dan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DanDeleteOne{builder}
}

// Query returns a query builder for Dan.
func (c *DanClient) Query() *DanQuery {
	return &DanQuery{
		config: c.config,
	}
}

// Get returns a Dan entity by its id.
func (c *DanClient) Get(ctx context.Context, id uuid.UUID) (*Dan, error) {
	return c.Query().Where(dan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DanClient) GetX(ctx context.Context, id uuid.UUID) *Dan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGamePlayers queries the game_players edge of a Dan.
func (c *DanClient) QueryGamePlayers(d *Dan) *GamePlayerQuery {
	query := &GamePlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dan.Table, dan.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dan.GamePlayersTable, dan.GamePlayersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DanClient) Hooks() []Hook {
	return c.hooks.Dan
}

// DrawnClient is a client for the Drawn schema.
type DrawnClient struct {
	config
}

// NewDrawnClient returns a client for the Drawn from the given config.
func NewDrawnClient(c config) *DrawnClient {
	return &DrawnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `drawn.Hooks(f(g(h())))`.
func (c *DrawnClient) Use(hooks ...Hook) {
	c.hooks.Drawn = append(c.hooks.Drawn, hooks...)
}

// Create returns a builder for creating a Drawn entity.
func (c *DrawnClient) Create() *DrawnCreate {
	mutation := newDrawnMutation(c.config, OpCreate)
	return &DrawnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Drawn entities.
func (c *DrawnClient) CreateBulk(builders ...*DrawnCreate) *DrawnCreateBulk {
	return &DrawnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Drawn.
func (c *DrawnClient) Update() *DrawnUpdate {
	mutation := newDrawnMutation(c.config, OpUpdate)
	return &DrawnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DrawnClient) UpdateOne(d *Drawn) *DrawnUpdateOne {
	mutation := newDrawnMutation(c.config, OpUpdateOne, withDrawn(d))
	return &DrawnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DrawnClient) UpdateOneID(id int) *DrawnUpdateOne {
	mutation := newDrawnMutation(c.config, OpUpdateOne, withDrawnID(id))
	return &DrawnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Drawn.
func (c *DrawnClient) Delete() *DrawnDelete {
	mutation := newDrawnMutation(c.config, OpDelete)
	return &DrawnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DrawnClient) DeleteOne(d *Drawn) *DrawnDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DrawnClient) DeleteOneID(id int) *DrawnDeleteOne {
	builder := c.Delete().Where(drawn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DrawnDeleteOne{builder}
}

// Query returns a query builder for Drawn.
func (c *DrawnClient) Query() *DrawnQuery {
	return &DrawnQuery{
		config: c.config,
	}
}

// Get returns a Drawn entity by its id.
func (c *DrawnClient) Get(ctx context.Context, id int) (*Drawn, error) {
	return c.Query().Where(drawn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DrawnClient) GetX(ctx context.Context, id int) *Drawn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DrawnClient) Hooks() []Hook {
	return c.hooks.Drawn
}

// GameClient is a client for the Game schema.
type GameClient struct {
	config
}

// NewGameClient returns a client for the Game from the given config.
func NewGameClient(c config) *GameClient {
	return &GameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `game.Hooks(f(g(h())))`.
func (c *GameClient) Use(hooks ...Hook) {
	c.hooks.Game = append(c.hooks.Game, hooks...)
}

// Create returns a builder for creating a Game entity.
func (c *GameClient) Create() *GameCreate {
	mutation := newGameMutation(c.config, OpCreate)
	return &GameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Game entities.
func (c *GameClient) CreateBulk(builders ...*GameCreate) *GameCreateBulk {
	return &GameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Game.
func (c *GameClient) Update() *GameUpdate {
	mutation := newGameMutation(c.config, OpUpdate)
	return &GameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameClient) UpdateOne(ga *Game) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGame(ga))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameClient) UpdateOneID(id uuid.UUID) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGameID(id))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Game.
func (c *GameClient) Delete() *GameDelete {
	mutation := newGameMutation(c.config, OpDelete)
	return &GameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameClient) DeleteOne(ga *Game) *GameDeleteOne {
	return c.DeleteOneID(ga.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameClient) DeleteOneID(id uuid.UUID) *GameDeleteOne {
	builder := c.Delete().Where(game.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameDeleteOne{builder}
}

// Query returns a query builder for Game.
func (c *GameClient) Query() *GameQuery {
	return &GameQuery{
		config: c.config,
	}
}

// Get returns a Game entity by its id.
func (c *GameClient) Get(ctx context.Context, id uuid.UUID) (*Game, error) {
	return c.Query().Where(game.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameClient) GetX(ctx context.Context, id uuid.UUID) *Game {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogs queries the mjlogs edge of a Game.
func (c *GameClient) QueryMjlogs(ga *Game) *MJLogQuery {
	query := &MJLogQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(mjlog.Table, mjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, game.MjlogsTable, game.MjlogsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGamePlayers queries the game_players edge of a Game.
func (c *GameClient) QueryGamePlayers(ga *Game) *GamePlayerQuery {
	query := &GamePlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, game.GamePlayersTable, game.GamePlayersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRooms queries the rooms edge of a Game.
func (c *GameClient) QueryRooms(ga *Game) *RoomQuery {
	query := &RoomQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, game.RoomsTable, game.RoomsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRounds queries the rounds edge of a Game.
func (c *GameClient) QueryRounds(ga *Game) *RoundQuery {
	query := &RoundQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, game.RoundsTable, game.RoundsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameClient) Hooks() []Hook {
	return c.hooks.Game
}

// GamePlayerClient is a client for the GamePlayer schema.
type GamePlayerClient struct {
	config
}

// NewGamePlayerClient returns a client for the GamePlayer from the given config.
func NewGamePlayerClient(c config) *GamePlayerClient {
	return &GamePlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayer.Hooks(f(g(h())))`.
func (c *GamePlayerClient) Use(hooks ...Hook) {
	c.hooks.GamePlayer = append(c.hooks.GamePlayer, hooks...)
}

// Create returns a builder for creating a GamePlayer entity.
func (c *GamePlayerClient) Create() *GamePlayerCreate {
	mutation := newGamePlayerMutation(c.config, OpCreate)
	return &GamePlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayer entities.
func (c *GamePlayerClient) CreateBulk(builders ...*GamePlayerCreate) *GamePlayerCreateBulk {
	return &GamePlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayer.
func (c *GamePlayerClient) Update() *GamePlayerUpdate {
	mutation := newGamePlayerMutation(c.config, OpUpdate)
	return &GamePlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerClient) UpdateOne(gp *GamePlayer) *GamePlayerUpdateOne {
	mutation := newGamePlayerMutation(c.config, OpUpdateOne, withGamePlayer(gp))
	return &GamePlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerClient) UpdateOneID(id uuid.UUID) *GamePlayerUpdateOne {
	mutation := newGamePlayerMutation(c.config, OpUpdateOne, withGamePlayerID(id))
	return &GamePlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayer.
func (c *GamePlayerClient) Delete() *GamePlayerDelete {
	mutation := newGamePlayerMutation(c.config, OpDelete)
	return &GamePlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerClient) DeleteOne(gp *GamePlayer) *GamePlayerDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerClient) DeleteOneID(id uuid.UUID) *GamePlayerDeleteOne {
	builder := c.Delete().Where(gameplayer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerDeleteOne{builder}
}

// Query returns a query builder for GamePlayer.
func (c *GamePlayerClient) Query() *GamePlayerQuery {
	return &GamePlayerQuery{
		config: c.config,
	}
}

// Get returns a GamePlayer entity by its id.
func (c *GamePlayerClient) Get(ctx context.Context, id uuid.UUID) (*GamePlayer, error) {
	return c.Query().Where(gameplayer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerClient) GetX(ctx context.Context, id uuid.UUID) *GamePlayer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a GamePlayer.
func (c *GamePlayerClient) QueryGames(gp *GamePlayer) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, gameplayer.GamesTable, gameplayer.GamesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayers queries the players edge of a GamePlayer.
func (c *GamePlayerClient) QueryPlayers(gp *GamePlayer) *PlayerQuery {
	query := &PlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameplayer.PlayersTable, gameplayer.PlayersColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDans queries the dans edge of a GamePlayer.
func (c *GamePlayerClient) QueryDans(gp *GamePlayer) *DanQuery {
	query := &DanQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(dan.Table, dan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameplayer.DansTable, gameplayer.DansColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GamePlayerClient) Hooks() []Hook {
	return c.hooks.GamePlayer
}

// GamePlayerHandHaiClient is a client for the GamePlayerHandHai schema.
type GamePlayerHandHaiClient struct {
	config
}

// NewGamePlayerHandHaiClient returns a client for the GamePlayerHandHai from the given config.
func NewGamePlayerHandHaiClient(c config) *GamePlayerHandHaiClient {
	return &GamePlayerHandHaiClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayerhandhai.Hooks(f(g(h())))`.
func (c *GamePlayerHandHaiClient) Use(hooks ...Hook) {
	c.hooks.GamePlayerHandHai = append(c.hooks.GamePlayerHandHai, hooks...)
}

// Create returns a builder for creating a GamePlayerHandHai entity.
func (c *GamePlayerHandHaiClient) Create() *GamePlayerHandHaiCreate {
	mutation := newGamePlayerHandHaiMutation(c.config, OpCreate)
	return &GamePlayerHandHaiCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayerHandHai entities.
func (c *GamePlayerHandHaiClient) CreateBulk(builders ...*GamePlayerHandHaiCreate) *GamePlayerHandHaiCreateBulk {
	return &GamePlayerHandHaiCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Update() *GamePlayerHandHaiUpdate {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdate)
	return &GamePlayerHandHaiUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerHandHaiClient) UpdateOne(gphh *GamePlayerHandHai) *GamePlayerHandHaiUpdateOne {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdateOne, withGamePlayerHandHai(gphh))
	return &GamePlayerHandHaiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerHandHaiClient) UpdateOneID(id int) *GamePlayerHandHaiUpdateOne {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdateOne, withGamePlayerHandHaiID(id))
	return &GamePlayerHandHaiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Delete() *GamePlayerHandHaiDelete {
	mutation := newGamePlayerHandHaiMutation(c.config, OpDelete)
	return &GamePlayerHandHaiDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerHandHaiClient) DeleteOne(gphh *GamePlayerHandHai) *GamePlayerHandHaiDeleteOne {
	return c.DeleteOneID(gphh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerHandHaiClient) DeleteOneID(id int) *GamePlayerHandHaiDeleteOne {
	builder := c.Delete().Where(gameplayerhandhai.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerHandHaiDeleteOne{builder}
}

// Query returns a query builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Query() *GamePlayerHandHaiQuery {
	return &GamePlayerHandHaiQuery{
		config: c.config,
	}
}

// Get returns a GamePlayerHandHai entity by its id.
func (c *GamePlayerHandHaiClient) Get(ctx context.Context, id int) (*GamePlayerHandHai, error) {
	return c.Query().Where(gameplayerhandhai.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerHandHaiClient) GetX(ctx context.Context, id int) *GamePlayerHandHai {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GamePlayerHandHaiClient) Hooks() []Hook {
	return c.hooks.GamePlayerHandHai
}

// GamePlayerPointClient is a client for the GamePlayerPoint schema.
type GamePlayerPointClient struct {
	config
}

// NewGamePlayerPointClient returns a client for the GamePlayerPoint from the given config.
func NewGamePlayerPointClient(c config) *GamePlayerPointClient {
	return &GamePlayerPointClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayerpoint.Hooks(f(g(h())))`.
func (c *GamePlayerPointClient) Use(hooks ...Hook) {
	c.hooks.GamePlayerPoint = append(c.hooks.GamePlayerPoint, hooks...)
}

// Create returns a builder for creating a GamePlayerPoint entity.
func (c *GamePlayerPointClient) Create() *GamePlayerPointCreate {
	mutation := newGamePlayerPointMutation(c.config, OpCreate)
	return &GamePlayerPointCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayerPoint entities.
func (c *GamePlayerPointClient) CreateBulk(builders ...*GamePlayerPointCreate) *GamePlayerPointCreateBulk {
	return &GamePlayerPointCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Update() *GamePlayerPointUpdate {
	mutation := newGamePlayerPointMutation(c.config, OpUpdate)
	return &GamePlayerPointUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerPointClient) UpdateOne(gpp *GamePlayerPoint) *GamePlayerPointUpdateOne {
	mutation := newGamePlayerPointMutation(c.config, OpUpdateOne, withGamePlayerPoint(gpp))
	return &GamePlayerPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerPointClient) UpdateOneID(id uuid.UUID) *GamePlayerPointUpdateOne {
	mutation := newGamePlayerPointMutation(c.config, OpUpdateOne, withGamePlayerPointID(id))
	return &GamePlayerPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Delete() *GamePlayerPointDelete {
	mutation := newGamePlayerPointMutation(c.config, OpDelete)
	return &GamePlayerPointDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerPointClient) DeleteOne(gpp *GamePlayerPoint) *GamePlayerPointDeleteOne {
	return c.DeleteOneID(gpp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerPointClient) DeleteOneID(id uuid.UUID) *GamePlayerPointDeleteOne {
	builder := c.Delete().Where(gameplayerpoint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerPointDeleteOne{builder}
}

// Query returns a query builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Query() *GamePlayerPointQuery {
	return &GamePlayerPointQuery{
		config: c.config,
	}
}

// Get returns a GamePlayerPoint entity by its id.
func (c *GamePlayerPointClient) Get(ctx context.Context, id uuid.UUID) (*GamePlayerPoint, error) {
	return c.Query().Where(gameplayerpoint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerPointClient) GetX(ctx context.Context, id uuid.UUID) *GamePlayerPoint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTurns queries the turns edge of a GamePlayerPoint.
func (c *GamePlayerPointClient) QueryTurns(gpp *GamePlayerPoint) *TurnQuery {
	query := &TurnQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gpp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayerpoint.Table, gameplayerpoint.FieldID, id),
			sqlgraph.To(turn.Table, turn.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, gameplayerpoint.TurnsTable, gameplayerpoint.TurnsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gpp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GamePlayerPointClient) Hooks() []Hook {
	return c.hooks.GamePlayerPoint
}

// HandClient is a client for the Hand schema.
type HandClient struct {
	config
}

// NewHandClient returns a client for the Hand from the given config.
func NewHandClient(c config) *HandClient {
	return &HandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hand.Hooks(f(g(h())))`.
func (c *HandClient) Use(hooks ...Hook) {
	c.hooks.Hand = append(c.hooks.Hand, hooks...)
}

// Create returns a builder for creating a Hand entity.
func (c *HandClient) Create() *HandCreate {
	mutation := newHandMutation(c.config, OpCreate)
	return &HandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hand entities.
func (c *HandClient) CreateBulk(builders ...*HandCreate) *HandCreateBulk {
	return &HandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hand.
func (c *HandClient) Update() *HandUpdate {
	mutation := newHandMutation(c.config, OpUpdate)
	return &HandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HandClient) UpdateOne(h *Hand) *HandUpdateOne {
	mutation := newHandMutation(c.config, OpUpdateOne, withHand(h))
	return &HandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HandClient) UpdateOneID(id uuid.UUID) *HandUpdateOne {
	mutation := newHandMutation(c.config, OpUpdateOne, withHandID(id))
	return &HandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hand.
func (c *HandClient) Delete() *HandDelete {
	mutation := newHandMutation(c.config, OpDelete)
	return &HandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HandClient) DeleteOne(h *Hand) *HandDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HandClient) DeleteOneID(id uuid.UUID) *HandDeleteOne {
	builder := c.Delete().Where(hand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HandDeleteOne{builder}
}

// Query returns a query builder for Hand.
func (c *HandClient) Query() *HandQuery {
	return &HandQuery{
		config: c.config,
	}
}

// Get returns a Hand entity by its id.
func (c *HandClient) Get(ctx context.Context, id uuid.UUID) (*Hand, error) {
	return c.Query().Where(hand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HandClient) GetX(ctx context.Context, id uuid.UUID) *Hand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRounds queries the rounds edge of a Hand.
func (c *HandClient) QueryRounds(h *Hand) *RoundQuery {
	query := &RoundQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hand.Table, hand.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hand.RoundsTable, hand.RoundsColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTurns queries the turns edge of a Hand.
func (c *HandClient) QueryTurns(h *Hand) *TurnQuery {
	query := &TurnQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hand.Table, hand.FieldID, id),
			sqlgraph.To(turn.Table, turn.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, hand.TurnsTable, hand.TurnsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HandClient) Hooks() []Hook {
	return c.hooks.Hand
}

// MJLogClient is a client for the MJLog schema.
type MJLogClient struct {
	config
}

// NewMJLogClient returns a client for the MJLog from the given config.
func NewMJLogClient(c config) *MJLogClient {
	return &MJLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mjlog.Hooks(f(g(h())))`.
func (c *MJLogClient) Use(hooks ...Hook) {
	c.hooks.MJLog = append(c.hooks.MJLog, hooks...)
}

// Create returns a builder for creating a MJLog entity.
func (c *MJLogClient) Create() *MJLogCreate {
	mutation := newMJLogMutation(c.config, OpCreate)
	return &MJLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MJLog entities.
func (c *MJLogClient) CreateBulk(builders ...*MJLogCreate) *MJLogCreateBulk {
	return &MJLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MJLog.
func (c *MJLogClient) Update() *MJLogUpdate {
	mutation := newMJLogMutation(c.config, OpUpdate)
	return &MJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MJLogClient) UpdateOne(ml *MJLog) *MJLogUpdateOne {
	mutation := newMJLogMutation(c.config, OpUpdateOne, withMJLog(ml))
	return &MJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MJLogClient) UpdateOneID(id uuid.UUID) *MJLogUpdateOne {
	mutation := newMJLogMutation(c.config, OpUpdateOne, withMJLogID(id))
	return &MJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MJLog.
func (c *MJLogClient) Delete() *MJLogDelete {
	mutation := newMJLogMutation(c.config, OpDelete)
	return &MJLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MJLogClient) DeleteOne(ml *MJLog) *MJLogDeleteOne {
	return c.DeleteOneID(ml.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MJLogClient) DeleteOneID(id uuid.UUID) *MJLogDeleteOne {
	builder := c.Delete().Where(mjlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MJLogDeleteOne{builder}
}

// Query returns a query builder for MJLog.
func (c *MJLogClient) Query() *MJLogQuery {
	return &MJLogQuery{
		config: c.config,
	}
}

// Get returns a MJLog entity by its id.
func (c *MJLogClient) Get(ctx context.Context, id uuid.UUID) (*MJLog, error) {
	return c.Query().Where(mjlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MJLogClient) GetX(ctx context.Context, id uuid.UUID) *MJLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogFiles queries the mjlog_files edge of a MJLog.
func (c *MJLogClient) QueryMjlogFiles(ml *MJLog) *MJLogFileQuery {
	query := &MJLogFileQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlog.Table, mjlog.FieldID, id),
			sqlgraph.To(mjlogfile.Table, mjlogfile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlog.MjlogFilesTable, mjlog.MjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGames queries the games edge of a MJLog.
func (c *MJLogClient) QueryGames(ml *MJLog) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlog.Table, mjlog.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlog.GamesTable, mjlog.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MJLogClient) Hooks() []Hook {
	return c.hooks.MJLog
}

// MJLogFileClient is a client for the MJLogFile schema.
type MJLogFileClient struct {
	config
}

// NewMJLogFileClient returns a client for the MJLogFile from the given config.
func NewMJLogFileClient(c config) *MJLogFileClient {
	return &MJLogFileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mjlogfile.Hooks(f(g(h())))`.
func (c *MJLogFileClient) Use(hooks ...Hook) {
	c.hooks.MJLogFile = append(c.hooks.MJLogFile, hooks...)
}

// Create returns a builder for creating a MJLogFile entity.
func (c *MJLogFileClient) Create() *MJLogFileCreate {
	mutation := newMJLogFileMutation(c.config, OpCreate)
	return &MJLogFileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MJLogFile entities.
func (c *MJLogFileClient) CreateBulk(builders ...*MJLogFileCreate) *MJLogFileCreateBulk {
	return &MJLogFileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MJLogFile.
func (c *MJLogFileClient) Update() *MJLogFileUpdate {
	mutation := newMJLogFileMutation(c.config, OpUpdate)
	return &MJLogFileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MJLogFileClient) UpdateOne(mlf *MJLogFile) *MJLogFileUpdateOne {
	mutation := newMJLogFileMutation(c.config, OpUpdateOne, withMJLogFile(mlf))
	return &MJLogFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MJLogFileClient) UpdateOneID(id uuid.UUID) *MJLogFileUpdateOne {
	mutation := newMJLogFileMutation(c.config, OpUpdateOne, withMJLogFileID(id))
	return &MJLogFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MJLogFile.
func (c *MJLogFileClient) Delete() *MJLogFileDelete {
	mutation := newMJLogFileMutation(c.config, OpDelete)
	return &MJLogFileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MJLogFileClient) DeleteOne(mlf *MJLogFile) *MJLogFileDeleteOne {
	return c.DeleteOneID(mlf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MJLogFileClient) DeleteOneID(id uuid.UUID) *MJLogFileDeleteOne {
	builder := c.Delete().Where(mjlogfile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MJLogFileDeleteOne{builder}
}

// Query returns a query builder for MJLogFile.
func (c *MJLogFileClient) Query() *MJLogFileQuery {
	return &MJLogFileQuery{
		config: c.config,
	}
}

// Get returns a MJLogFile entity by its id.
func (c *MJLogFileClient) Get(ctx context.Context, id uuid.UUID) (*MJLogFile, error) {
	return c.Query().Where(mjlogfile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MJLogFileClient) GetX(ctx context.Context, id uuid.UUID) *MJLogFile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompressedMjlogFiles queries the compressed_mjlog_files edge of a MJLogFile.
func (c *MJLogFileClient) QueryCompressedMjlogFiles(mlf *MJLogFile) *CompressedMJLogQuery {
	query := &CompressedMJLogQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mlf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlogfile.Table, mjlogfile.FieldID, id),
			sqlgraph.To(compressedmjlog.Table, compressedmjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlogfile.CompressedMjlogFilesTable, mjlogfile.CompressedMjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(mlf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMjlogs queries the mjlogs edge of a MJLogFile.
func (c *MJLogFileClient) QueryMjlogs(mlf *MJLogFile) *MJLogQuery {
	query := &MJLogQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mlf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlogfile.Table, mjlogfile.FieldID, id),
			sqlgraph.To(mjlog.Table, mjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, mjlogfile.MjlogsTable, mjlogfile.MjlogsColumn),
		)
		fromV = sqlgraph.Neighbors(mlf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MJLogFileClient) Hooks() []Hook {
	return c.hooks.MJLogFile
}

// MeldedKanClient is a client for the MeldedKan schema.
type MeldedKanClient struct {
	config
}

// NewMeldedKanClient returns a client for the MeldedKan from the given config.
func NewMeldedKanClient(c config) *MeldedKanClient {
	return &MeldedKanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `meldedkan.Hooks(f(g(h())))`.
func (c *MeldedKanClient) Use(hooks ...Hook) {
	c.hooks.MeldedKan = append(c.hooks.MeldedKan, hooks...)
}

// Create returns a builder for creating a MeldedKan entity.
func (c *MeldedKanClient) Create() *MeldedKanCreate {
	mutation := newMeldedKanMutation(c.config, OpCreate)
	return &MeldedKanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MeldedKan entities.
func (c *MeldedKanClient) CreateBulk(builders ...*MeldedKanCreate) *MeldedKanCreateBulk {
	return &MeldedKanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MeldedKan.
func (c *MeldedKanClient) Update() *MeldedKanUpdate {
	mutation := newMeldedKanMutation(c.config, OpUpdate)
	return &MeldedKanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MeldedKanClient) UpdateOne(mk *MeldedKan) *MeldedKanUpdateOne {
	mutation := newMeldedKanMutation(c.config, OpUpdateOne, withMeldedKan(mk))
	return &MeldedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MeldedKanClient) UpdateOneID(id int) *MeldedKanUpdateOne {
	mutation := newMeldedKanMutation(c.config, OpUpdateOne, withMeldedKanID(id))
	return &MeldedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MeldedKan.
func (c *MeldedKanClient) Delete() *MeldedKanDelete {
	mutation := newMeldedKanMutation(c.config, OpDelete)
	return &MeldedKanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MeldedKanClient) DeleteOne(mk *MeldedKan) *MeldedKanDeleteOne {
	return c.DeleteOneID(mk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MeldedKanClient) DeleteOneID(id int) *MeldedKanDeleteOne {
	builder := c.Delete().Where(meldedkan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MeldedKanDeleteOne{builder}
}

// Query returns a query builder for MeldedKan.
func (c *MeldedKanClient) Query() *MeldedKanQuery {
	return &MeldedKanQuery{
		config: c.config,
	}
}

// Get returns a MeldedKan entity by its id.
func (c *MeldedKanClient) Get(ctx context.Context, id int) (*MeldedKan, error) {
	return c.Query().Where(meldedkan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MeldedKanClient) GetX(ctx context.Context, id int) *MeldedKan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MeldedKanClient) Hooks() []Hook {
	return c.hooks.MeldedKan
}

// PlayerClient is a client for the Player schema.
type PlayerClient struct {
	config
}

// NewPlayerClient returns a client for the Player from the given config.
func NewPlayerClient(c config) *PlayerClient {
	return &PlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `player.Hooks(f(g(h())))`.
func (c *PlayerClient) Use(hooks ...Hook) {
	c.hooks.Player = append(c.hooks.Player, hooks...)
}

// Create returns a builder for creating a Player entity.
func (c *PlayerClient) Create() *PlayerCreate {
	mutation := newPlayerMutation(c.config, OpCreate)
	return &PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Player entities.
func (c *PlayerClient) CreateBulk(builders ...*PlayerCreate) *PlayerCreateBulk {
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Player.
func (c *PlayerClient) Update() *PlayerUpdate {
	mutation := newPlayerMutation(c.config, OpUpdate)
	return &PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerClient) UpdateOne(pl *Player) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayer(pl))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerClient) UpdateOneID(id uuid.UUID) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayerID(id))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Player.
func (c *PlayerClient) Delete() *PlayerDelete {
	mutation := newPlayerMutation(c.config, OpDelete)
	return &PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerClient) DeleteOne(pl *Player) *PlayerDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerClient) DeleteOneID(id uuid.UUID) *PlayerDeleteOne {
	builder := c.Delete().Where(player.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerDeleteOne{builder}
}

// Query returns a query builder for Player.
func (c *PlayerClient) Query() *PlayerQuery {
	return &PlayerQuery{
		config: c.config,
	}
}

// Get returns a Player entity by its id.
func (c *PlayerClient) Get(ctx context.Context, id uuid.UUID) (*Player, error) {
	return c.Query().Where(player.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerClient) GetX(ctx context.Context, id uuid.UUID) *Player {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGamePlayers queries the game_players edge of a Player.
func (c *PlayerClient) QueryGamePlayers(pl *Player) *GamePlayerQuery {
	query := &GamePlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.GamePlayersTable, player.GamePlayersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerClient) Hooks() []Hook {
	return c.hooks.Player
}

// PonClient is a client for the Pon schema.
type PonClient struct {
	config
}

// NewPonClient returns a client for the Pon from the given config.
func NewPonClient(c config) *PonClient {
	return &PonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pon.Hooks(f(g(h())))`.
func (c *PonClient) Use(hooks ...Hook) {
	c.hooks.Pon = append(c.hooks.Pon, hooks...)
}

// Create returns a builder for creating a Pon entity.
func (c *PonClient) Create() *PonCreate {
	mutation := newPonMutation(c.config, OpCreate)
	return &PonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Pon entities.
func (c *PonClient) CreateBulk(builders ...*PonCreate) *PonCreateBulk {
	return &PonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Pon.
func (c *PonClient) Update() *PonUpdate {
	mutation := newPonMutation(c.config, OpUpdate)
	return &PonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PonClient) UpdateOne(po *Pon) *PonUpdateOne {
	mutation := newPonMutation(c.config, OpUpdateOne, withPon(po))
	return &PonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PonClient) UpdateOneID(id int) *PonUpdateOne {
	mutation := newPonMutation(c.config, OpUpdateOne, withPonID(id))
	return &PonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Pon.
func (c *PonClient) Delete() *PonDelete {
	mutation := newPonMutation(c.config, OpDelete)
	return &PonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PonClient) DeleteOne(po *Pon) *PonDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PonClient) DeleteOneID(id int) *PonDeleteOne {
	builder := c.Delete().Where(pon.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PonDeleteOne{builder}
}

// Query returns a query builder for Pon.
func (c *PonClient) Query() *PonQuery {
	return &PonQuery{
		config: c.config,
	}
}

// Get returns a Pon entity by its id.
func (c *PonClient) Get(ctx context.Context, id int) (*Pon, error) {
	return c.Query().Where(pon.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PonClient) GetX(ctx context.Context, id int) *Pon {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PonClient) Hooks() []Hook {
	return c.hooks.Pon
}

// RoomClient is a client for the Room schema.
type RoomClient struct {
	config
}

// NewRoomClient returns a client for the Room from the given config.
func NewRoomClient(c config) *RoomClient {
	return &RoomClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `room.Hooks(f(g(h())))`.
func (c *RoomClient) Use(hooks ...Hook) {
	c.hooks.Room = append(c.hooks.Room, hooks...)
}

// Create returns a builder for creating a Room entity.
func (c *RoomClient) Create() *RoomCreate {
	mutation := newRoomMutation(c.config, OpCreate)
	return &RoomCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Room entities.
func (c *RoomClient) CreateBulk(builders ...*RoomCreate) *RoomCreateBulk {
	return &RoomCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Room.
func (c *RoomClient) Update() *RoomUpdate {
	mutation := newRoomMutation(c.config, OpUpdate)
	return &RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoomClient) UpdateOne(r *Room) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoom(r))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoomClient) UpdateOneID(id uuid.UUID) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoomID(id))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Room.
func (c *RoomClient) Delete() *RoomDelete {
	mutation := newRoomMutation(c.config, OpDelete)
	return &RoomDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoomClient) DeleteOne(r *Room) *RoomDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoomClient) DeleteOneID(id uuid.UUID) *RoomDeleteOne {
	builder := c.Delete().Where(room.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoomDeleteOne{builder}
}

// Query returns a query builder for Room.
func (c *RoomClient) Query() *RoomQuery {
	return &RoomQuery{
		config: c.config,
	}
}

// Get returns a Room entity by its id.
func (c *RoomClient) Get(ctx context.Context, id uuid.UUID) (*Room, error) {
	return c.Query().Where(room.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoomClient) GetX(ctx context.Context, id uuid.UUID) *Room {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Room.
func (c *RoomClient) QueryGames(r *Room) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, room.GamesTable, room.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoomClient) Hooks() []Hook {
	return c.hooks.Room
}

// RoundClient is a client for the Round schema.
type RoundClient struct {
	config
}

// NewRoundClient returns a client for the Round from the given config.
func NewRoundClient(c config) *RoundClient {
	return &RoundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `round.Hooks(f(g(h())))`.
func (c *RoundClient) Use(hooks ...Hook) {
	c.hooks.Round = append(c.hooks.Round, hooks...)
}

// Create returns a builder for creating a Round entity.
func (c *RoundClient) Create() *RoundCreate {
	mutation := newRoundMutation(c.config, OpCreate)
	return &RoundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Round entities.
func (c *RoundClient) CreateBulk(builders ...*RoundCreate) *RoundCreateBulk {
	return &RoundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Round.
func (c *RoundClient) Update() *RoundUpdate {
	mutation := newRoundMutation(c.config, OpUpdate)
	return &RoundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoundClient) UpdateOne(r *Round) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRound(r))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoundClient) UpdateOneID(id uuid.UUID) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRoundID(id))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Round.
func (c *RoundClient) Delete() *RoundDelete {
	mutation := newRoundMutation(c.config, OpDelete)
	return &RoundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoundClient) DeleteOne(r *Round) *RoundDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoundClient) DeleteOneID(id uuid.UUID) *RoundDeleteOne {
	builder := c.Delete().Where(round.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoundDeleteOne{builder}
}

// Query returns a query builder for Round.
func (c *RoundClient) Query() *RoundQuery {
	return &RoundQuery{
		config: c.config,
	}
}

// Get returns a Round entity by its id.
func (c *RoundClient) Get(ctx context.Context, id uuid.UUID) (*Round, error) {
	return c.Query().Where(round.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoundClient) GetX(ctx context.Context, id uuid.UUID) *Round {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Round.
func (c *RoundClient) QueryGames(r *Round) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, round.GamesTable, round.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHands queries the hands edge of a Round.
func (c *RoundClient) QueryHands(r *Round) *HandQuery {
	query := &HandQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(hand.Table, hand.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, round.HandsTable, round.HandsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoundClient) Hooks() []Hook {
	return c.hooks.Round
}

// TurnClient is a client for the Turn schema.
type TurnClient struct {
	config
}

// NewTurnClient returns a client for the Turn from the given config.
func NewTurnClient(c config) *TurnClient {
	return &TurnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `turn.Hooks(f(g(h())))`.
func (c *TurnClient) Use(hooks ...Hook) {
	c.hooks.Turn = append(c.hooks.Turn, hooks...)
}

// Create returns a builder for creating a Turn entity.
func (c *TurnClient) Create() *TurnCreate {
	mutation := newTurnMutation(c.config, OpCreate)
	return &TurnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Turn entities.
func (c *TurnClient) CreateBulk(builders ...*TurnCreate) *TurnCreateBulk {
	return &TurnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Turn.
func (c *TurnClient) Update() *TurnUpdate {
	mutation := newTurnMutation(c.config, OpUpdate)
	return &TurnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TurnClient) UpdateOne(t *Turn) *TurnUpdateOne {
	mutation := newTurnMutation(c.config, OpUpdateOne, withTurn(t))
	return &TurnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TurnClient) UpdateOneID(id uuid.UUID) *TurnUpdateOne {
	mutation := newTurnMutation(c.config, OpUpdateOne, withTurnID(id))
	return &TurnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Turn.
func (c *TurnClient) Delete() *TurnDelete {
	mutation := newTurnMutation(c.config, OpDelete)
	return &TurnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TurnClient) DeleteOne(t *Turn) *TurnDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TurnClient) DeleteOneID(id uuid.UUID) *TurnDeleteOne {
	builder := c.Delete().Where(turn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TurnDeleteOne{builder}
}

// Query returns a query builder for Turn.
func (c *TurnClient) Query() *TurnQuery {
	return &TurnQuery{
		config: c.config,
	}
}

// Get returns a Turn entity by its id.
func (c *TurnClient) Get(ctx context.Context, id uuid.UUID) (*Turn, error) {
	return c.Query().Where(turn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TurnClient) GetX(ctx context.Context, id uuid.UUID) *Turn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHands queries the hands edge of a Turn.
func (c *TurnClient) QueryHands(t *Turn) *HandQuery {
	query := &HandQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(turn.Table, turn.FieldID, id),
			sqlgraph.To(hand.Table, hand.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, turn.HandsTable, turn.HandsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGamePlayerPoints queries the game_player_points edge of a Turn.
func (c *TurnClient) QueryGamePlayerPoints(t *Turn) *GamePlayerPointQuery {
	query := &GamePlayerPointQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(turn.Table, turn.FieldID, id),
			sqlgraph.To(gameplayerpoint.Table, gameplayerpoint.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, turn.GamePlayerPointsTable, turn.GamePlayerPointsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TurnClient) Hooks() []Hook {
	return c.hooks.Turn
}

// WinClient is a client for the Win schema.
type WinClient struct {
	config
}

// NewWinClient returns a client for the Win from the given config.
func NewWinClient(c config) *WinClient {
	return &WinClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `win.Hooks(f(g(h())))`.
func (c *WinClient) Use(hooks ...Hook) {
	c.hooks.Win = append(c.hooks.Win, hooks...)
}

// Create returns a builder for creating a Win entity.
func (c *WinClient) Create() *WinCreate {
	mutation := newWinMutation(c.config, OpCreate)
	return &WinCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Win entities.
func (c *WinClient) CreateBulk(builders ...*WinCreate) *WinCreateBulk {
	return &WinCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Win.
func (c *WinClient) Update() *WinUpdate {
	mutation := newWinMutation(c.config, OpUpdate)
	return &WinUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinClient) UpdateOne(w *Win) *WinUpdateOne {
	mutation := newWinMutation(c.config, OpUpdateOne, withWin(w))
	return &WinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinClient) UpdateOneID(id int) *WinUpdateOne {
	mutation := newWinMutation(c.config, OpUpdateOne, withWinID(id))
	return &WinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Win.
func (c *WinClient) Delete() *WinDelete {
	mutation := newWinMutation(c.config, OpDelete)
	return &WinDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinClient) DeleteOne(w *Win) *WinDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinClient) DeleteOneID(id int) *WinDeleteOne {
	builder := c.Delete().Where(win.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinDeleteOne{builder}
}

// Query returns a query builder for Win.
func (c *WinClient) Query() *WinQuery {
	return &WinQuery{
		config: c.config,
	}
}

// Get returns a Win entity by its id.
func (c *WinClient) Get(ctx context.Context, id int) (*Win, error) {
	return c.Query().Where(win.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinClient) GetX(ctx context.Context, id int) *Win {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *WinClient) Hooks() []Hook {
	return c.hooks.Win
}
