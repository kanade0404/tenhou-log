// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/kanade0404/tenhou-log/services/ent/migrate"

	"github.com/kanade0404/tenhou-log/services/ent/compressedmjlog"
	"github.com/kanade0404/tenhou-log/services/ent/dan"
	"github.com/kanade0404/tenhou-log/services/ent/game"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayer"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerhandhai"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerpoint"
	"github.com/kanade0404/tenhou-log/services/ent/goaround"
	"github.com/kanade0404/tenhou-log/services/ent/hand"
	"github.com/kanade0404/tenhou-log/services/ent/mjlog"
	"github.com/kanade0404/tenhou-log/services/ent/mjlogfile"
	"github.com/kanade0404/tenhou-log/services/ent/player"
	"github.com/kanade0404/tenhou-log/services/ent/room"
	"github.com/kanade0404/tenhou-log/services/ent/round"
	"github.com/kanade0404/tenhou-log/services/ent/wind"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// CompressedMJLog is the client for interacting with the CompressedMJLog builders.
	CompressedMJLog *CompressedMJLogClient
	// Dan is the client for interacting with the Dan builders.
	Dan *DanClient
	// Game is the client for interacting with the Game builders.
	Game *GameClient
	// GamePlayer is the client for interacting with the GamePlayer builders.
	GamePlayer *GamePlayerClient
	// GamePlayerHandHai is the client for interacting with the GamePlayerHandHai builders.
	GamePlayerHandHai *GamePlayerHandHaiClient
	// GamePlayerPoint is the client for interacting with the GamePlayerPoint builders.
	GamePlayerPoint *GamePlayerPointClient
	// GoAround is the client for interacting with the GoAround builders.
	GoAround *GoAroundClient
	// Hand is the client for interacting with the Hand builders.
	Hand *HandClient
	// MJLog is the client for interacting with the MJLog builders.
	MJLog *MJLogClient
	// MJLogFile is the client for interacting with the MJLogFile builders.
	MJLogFile *MJLogFileClient
	// Player is the client for interacting with the Player builders.
	Player *PlayerClient
	// Room is the client for interacting with the Room builders.
	Room *RoomClient
	// Round is the client for interacting with the Round builders.
	Round *RoundClient
	// Wind is the client for interacting with the Wind builders.
	Wind *WindClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.CompressedMJLog = NewCompressedMJLogClient(c.config)
	c.Dan = NewDanClient(c.config)
	c.Game = NewGameClient(c.config)
	c.GamePlayer = NewGamePlayerClient(c.config)
	c.GamePlayerHandHai = NewGamePlayerHandHaiClient(c.config)
	c.GamePlayerPoint = NewGamePlayerPointClient(c.config)
	c.GoAround = NewGoAroundClient(c.config)
	c.Hand = NewHandClient(c.config)
	c.MJLog = NewMJLogClient(c.config)
	c.MJLogFile = NewMJLogFileClient(c.config)
	c.Player = NewPlayerClient(c.config)
	c.Room = NewRoomClient(c.config)
	c.Round = NewRoundClient(c.config)
	c.Wind = NewWindClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		CompressedMJLog:   NewCompressedMJLogClient(cfg),
		Dan:               NewDanClient(cfg),
		Game:              NewGameClient(cfg),
		GamePlayer:        NewGamePlayerClient(cfg),
		GamePlayerHandHai: NewGamePlayerHandHaiClient(cfg),
		GamePlayerPoint:   NewGamePlayerPointClient(cfg),
		GoAround:          NewGoAroundClient(cfg),
		Hand:              NewHandClient(cfg),
		MJLog:             NewMJLogClient(cfg),
		MJLogFile:         NewMJLogFileClient(cfg),
		Player:            NewPlayerClient(cfg),
		Room:              NewRoomClient(cfg),
		Round:             NewRoundClient(cfg),
		Wind:              NewWindClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		CompressedMJLog:   NewCompressedMJLogClient(cfg),
		Dan:               NewDanClient(cfg),
		Game:              NewGameClient(cfg),
		GamePlayer:        NewGamePlayerClient(cfg),
		GamePlayerHandHai: NewGamePlayerHandHaiClient(cfg),
		GamePlayerPoint:   NewGamePlayerPointClient(cfg),
		GoAround:          NewGoAroundClient(cfg),
		Hand:              NewHandClient(cfg),
		MJLog:             NewMJLogClient(cfg),
		MJLogFile:         NewMJLogFileClient(cfg),
		Player:            NewPlayerClient(cfg),
		Room:              NewRoomClient(cfg),
		Round:             NewRoundClient(cfg),
		Wind:              NewWindClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		CompressedMJLog.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.CompressedMJLog.Use(hooks...)
	c.Dan.Use(hooks...)
	c.Game.Use(hooks...)
	c.GamePlayer.Use(hooks...)
	c.GamePlayerHandHai.Use(hooks...)
	c.GamePlayerPoint.Use(hooks...)
	c.GoAround.Use(hooks...)
	c.Hand.Use(hooks...)
	c.MJLog.Use(hooks...)
	c.MJLogFile.Use(hooks...)
	c.Player.Use(hooks...)
	c.Room.Use(hooks...)
	c.Round.Use(hooks...)
	c.Wind.Use(hooks...)
}

// CompressedMJLogClient is a client for the CompressedMJLog schema.
type CompressedMJLogClient struct {
	config
}

// NewCompressedMJLogClient returns a client for the CompressedMJLog from the given config.
func NewCompressedMJLogClient(c config) *CompressedMJLogClient {
	return &CompressedMJLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `compressedmjlog.Hooks(f(g(h())))`.
func (c *CompressedMJLogClient) Use(hooks ...Hook) {
	c.hooks.CompressedMJLog = append(c.hooks.CompressedMJLog, hooks...)
}

// Create returns a builder for creating a CompressedMJLog entity.
func (c *CompressedMJLogClient) Create() *CompressedMJLogCreate {
	mutation := newCompressedMJLogMutation(c.config, OpCreate)
	return &CompressedMJLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CompressedMJLog entities.
func (c *CompressedMJLogClient) CreateBulk(builders ...*CompressedMJLogCreate) *CompressedMJLogCreateBulk {
	return &CompressedMJLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CompressedMJLog.
func (c *CompressedMJLogClient) Update() *CompressedMJLogUpdate {
	mutation := newCompressedMJLogMutation(c.config, OpUpdate)
	return &CompressedMJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompressedMJLogClient) UpdateOne(cml *CompressedMJLog) *CompressedMJLogUpdateOne {
	mutation := newCompressedMJLogMutation(c.config, OpUpdateOne, withCompressedMJLog(cml))
	return &CompressedMJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompressedMJLogClient) UpdateOneID(id uuid.UUID) *CompressedMJLogUpdateOne {
	mutation := newCompressedMJLogMutation(c.config, OpUpdateOne, withCompressedMJLogID(id))
	return &CompressedMJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CompressedMJLog.
func (c *CompressedMJLogClient) Delete() *CompressedMJLogDelete {
	mutation := newCompressedMJLogMutation(c.config, OpDelete)
	return &CompressedMJLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompressedMJLogClient) DeleteOne(cml *CompressedMJLog) *CompressedMJLogDeleteOne {
	return c.DeleteOneID(cml.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompressedMJLogClient) DeleteOneID(id uuid.UUID) *CompressedMJLogDeleteOne {
	builder := c.Delete().Where(compressedmjlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompressedMJLogDeleteOne{builder}
}

// Query returns a query builder for CompressedMJLog.
func (c *CompressedMJLogClient) Query() *CompressedMJLogQuery {
	return &CompressedMJLogQuery{
		config: c.config,
	}
}

// Get returns a CompressedMJLog entity by its id.
func (c *CompressedMJLogClient) Get(ctx context.Context, id uuid.UUID) (*CompressedMJLog, error) {
	return c.Query().Where(compressedmjlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompressedMJLogClient) GetX(ctx context.Context, id uuid.UUID) *CompressedMJLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogFiles queries the mjlog_files edge of a CompressedMJLog.
func (c *CompressedMJLogClient) QueryMjlogFiles(cml *CompressedMJLog) *MJLogFileQuery {
	query := &MJLogFileQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(compressedmjlog.Table, compressedmjlog.FieldID, id),
			sqlgraph.To(mjlogfile.Table, mjlogfile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, compressedmjlog.MjlogFilesTable, compressedmjlog.MjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(cml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompressedMJLogClient) Hooks() []Hook {
	return c.hooks.CompressedMJLog
}

// DanClient is a client for the Dan schema.
type DanClient struct {
	config
}

// NewDanClient returns a client for the Dan from the given config.
func NewDanClient(c config) *DanClient {
	return &DanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dan.Hooks(f(g(h())))`.
func (c *DanClient) Use(hooks ...Hook) {
	c.hooks.Dan = append(c.hooks.Dan, hooks...)
}

// Create returns a builder for creating a Dan entity.
func (c *DanClient) Create() *DanCreate {
	mutation := newDanMutation(c.config, OpCreate)
	return &DanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dan entities.
func (c *DanClient) CreateBulk(builders ...*DanCreate) *DanCreateBulk {
	return &DanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dan.
func (c *DanClient) Update() *DanUpdate {
	mutation := newDanMutation(c.config, OpUpdate)
	return &DanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DanClient) UpdateOne(d *Dan) *DanUpdateOne {
	mutation := newDanMutation(c.config, OpUpdateOne, withDan(d))
	return &DanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DanClient) UpdateOneID(id uuid.UUID) *DanUpdateOne {
	mutation := newDanMutation(c.config, OpUpdateOne, withDanID(id))
	return &DanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dan.
func (c *DanClient) Delete() *DanDelete {
	mutation := newDanMutation(c.config, OpDelete)
	return &DanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DanClient) DeleteOne(d *Dan) *DanDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DanClient) DeleteOneID(id uuid.UUID) *DanDeleteOne {
	builder := c.Delete().Where(dan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DanDeleteOne{builder}
}

// Query returns a query builder for Dan.
func (c *DanClient) Query() *DanQuery {
	return &DanQuery{
		config: c.config,
	}
}

// Get returns a Dan entity by its id.
func (c *DanClient) Get(ctx context.Context, id uuid.UUID) (*Dan, error) {
	return c.Query().Where(dan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DanClient) GetX(ctx context.Context, id uuid.UUID) *Dan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGamePlayers queries the game_players edge of a Dan.
func (c *DanClient) QueryGamePlayers(d *Dan) *GamePlayerQuery {
	query := &GamePlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dan.Table, dan.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dan.GamePlayersTable, dan.GamePlayersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DanClient) Hooks() []Hook {
	return c.hooks.Dan
}

// GameClient is a client for the Game schema.
type GameClient struct {
	config
}

// NewGameClient returns a client for the Game from the given config.
func NewGameClient(c config) *GameClient {
	return &GameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `game.Hooks(f(g(h())))`.
func (c *GameClient) Use(hooks ...Hook) {
	c.hooks.Game = append(c.hooks.Game, hooks...)
}

// Create returns a builder for creating a Game entity.
func (c *GameClient) Create() *GameCreate {
	mutation := newGameMutation(c.config, OpCreate)
	return &GameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Game entities.
func (c *GameClient) CreateBulk(builders ...*GameCreate) *GameCreateBulk {
	return &GameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Game.
func (c *GameClient) Update() *GameUpdate {
	mutation := newGameMutation(c.config, OpUpdate)
	return &GameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameClient) UpdateOne(ga *Game) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGame(ga))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameClient) UpdateOneID(id uuid.UUID) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGameID(id))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Game.
func (c *GameClient) Delete() *GameDelete {
	mutation := newGameMutation(c.config, OpDelete)
	return &GameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameClient) DeleteOne(ga *Game) *GameDeleteOne {
	return c.DeleteOneID(ga.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameClient) DeleteOneID(id uuid.UUID) *GameDeleteOne {
	builder := c.Delete().Where(game.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameDeleteOne{builder}
}

// Query returns a query builder for Game.
func (c *GameClient) Query() *GameQuery {
	return &GameQuery{
		config: c.config,
	}
}

// Get returns a Game entity by its id.
func (c *GameClient) Get(ctx context.Context, id uuid.UUID) (*Game, error) {
	return c.Query().Where(game.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameClient) GetX(ctx context.Context, id uuid.UUID) *Game {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogs queries the mjlogs edge of a Game.
func (c *GameClient) QueryMjlogs(ga *Game) *MJLogQuery {
	query := &MJLogQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(mjlog.Table, mjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, game.MjlogsTable, game.MjlogsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGamePlayers queries the game_players edge of a Game.
func (c *GameClient) QueryGamePlayers(ga *Game) *GamePlayerQuery {
	query := &GamePlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, game.GamePlayersTable, game.GamePlayersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRooms queries the rooms edge of a Game.
func (c *GameClient) QueryRooms(ga *Game) *RoomQuery {
	query := &RoomQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, game.RoomsTable, game.RoomsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRounds queries the rounds edge of a Game.
func (c *GameClient) QueryRounds(ga *Game) *RoundQuery {
	query := &RoundQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, game.RoundsTable, game.RoundsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameClient) Hooks() []Hook {
	return c.hooks.Game
}

// GamePlayerClient is a client for the GamePlayer schema.
type GamePlayerClient struct {
	config
}

// NewGamePlayerClient returns a client for the GamePlayer from the given config.
func NewGamePlayerClient(c config) *GamePlayerClient {
	return &GamePlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayer.Hooks(f(g(h())))`.
func (c *GamePlayerClient) Use(hooks ...Hook) {
	c.hooks.GamePlayer = append(c.hooks.GamePlayer, hooks...)
}

// Create returns a builder for creating a GamePlayer entity.
func (c *GamePlayerClient) Create() *GamePlayerCreate {
	mutation := newGamePlayerMutation(c.config, OpCreate)
	return &GamePlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayer entities.
func (c *GamePlayerClient) CreateBulk(builders ...*GamePlayerCreate) *GamePlayerCreateBulk {
	return &GamePlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayer.
func (c *GamePlayerClient) Update() *GamePlayerUpdate {
	mutation := newGamePlayerMutation(c.config, OpUpdate)
	return &GamePlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerClient) UpdateOne(gp *GamePlayer) *GamePlayerUpdateOne {
	mutation := newGamePlayerMutation(c.config, OpUpdateOne, withGamePlayer(gp))
	return &GamePlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerClient) UpdateOneID(id uuid.UUID) *GamePlayerUpdateOne {
	mutation := newGamePlayerMutation(c.config, OpUpdateOne, withGamePlayerID(id))
	return &GamePlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayer.
func (c *GamePlayerClient) Delete() *GamePlayerDelete {
	mutation := newGamePlayerMutation(c.config, OpDelete)
	return &GamePlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerClient) DeleteOne(gp *GamePlayer) *GamePlayerDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerClient) DeleteOneID(id uuid.UUID) *GamePlayerDeleteOne {
	builder := c.Delete().Where(gameplayer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerDeleteOne{builder}
}

// Query returns a query builder for GamePlayer.
func (c *GamePlayerClient) Query() *GamePlayerQuery {
	return &GamePlayerQuery{
		config: c.config,
	}
}

// Get returns a GamePlayer entity by its id.
func (c *GamePlayerClient) Get(ctx context.Context, id uuid.UUID) (*GamePlayer, error) {
	return c.Query().Where(gameplayer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerClient) GetX(ctx context.Context, id uuid.UUID) *GamePlayer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a GamePlayer.
func (c *GamePlayerClient) QueryGames(gp *GamePlayer) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, gameplayer.GamesTable, gameplayer.GamesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayers queries the players edge of a GamePlayer.
func (c *GamePlayerClient) QueryPlayers(gp *GamePlayer) *PlayerQuery {
	query := &PlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameplayer.PlayersTable, gameplayer.PlayersColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDans queries the dans edge of a GamePlayer.
func (c *GamePlayerClient) QueryDans(gp *GamePlayer) *DanQuery {
	query := &DanQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(dan.Table, dan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameplayer.DansTable, gameplayer.DansColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GamePlayerClient) Hooks() []Hook {
	return c.hooks.GamePlayer
}

// GamePlayerHandHaiClient is a client for the GamePlayerHandHai schema.
type GamePlayerHandHaiClient struct {
	config
}

// NewGamePlayerHandHaiClient returns a client for the GamePlayerHandHai from the given config.
func NewGamePlayerHandHaiClient(c config) *GamePlayerHandHaiClient {
	return &GamePlayerHandHaiClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayerhandhai.Hooks(f(g(h())))`.
func (c *GamePlayerHandHaiClient) Use(hooks ...Hook) {
	c.hooks.GamePlayerHandHai = append(c.hooks.GamePlayerHandHai, hooks...)
}

// Create returns a builder for creating a GamePlayerHandHai entity.
func (c *GamePlayerHandHaiClient) Create() *GamePlayerHandHaiCreate {
	mutation := newGamePlayerHandHaiMutation(c.config, OpCreate)
	return &GamePlayerHandHaiCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayerHandHai entities.
func (c *GamePlayerHandHaiClient) CreateBulk(builders ...*GamePlayerHandHaiCreate) *GamePlayerHandHaiCreateBulk {
	return &GamePlayerHandHaiCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Update() *GamePlayerHandHaiUpdate {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdate)
	return &GamePlayerHandHaiUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerHandHaiClient) UpdateOne(gphh *GamePlayerHandHai) *GamePlayerHandHaiUpdateOne {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdateOne, withGamePlayerHandHai(gphh))
	return &GamePlayerHandHaiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerHandHaiClient) UpdateOneID(id int) *GamePlayerHandHaiUpdateOne {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdateOne, withGamePlayerHandHaiID(id))
	return &GamePlayerHandHaiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Delete() *GamePlayerHandHaiDelete {
	mutation := newGamePlayerHandHaiMutation(c.config, OpDelete)
	return &GamePlayerHandHaiDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerHandHaiClient) DeleteOne(gphh *GamePlayerHandHai) *GamePlayerHandHaiDeleteOne {
	return c.DeleteOneID(gphh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerHandHaiClient) DeleteOneID(id int) *GamePlayerHandHaiDeleteOne {
	builder := c.Delete().Where(gameplayerhandhai.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerHandHaiDeleteOne{builder}
}

// Query returns a query builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Query() *GamePlayerHandHaiQuery {
	return &GamePlayerHandHaiQuery{
		config: c.config,
	}
}

// Get returns a GamePlayerHandHai entity by its id.
func (c *GamePlayerHandHaiClient) Get(ctx context.Context, id int) (*GamePlayerHandHai, error) {
	return c.Query().Where(gameplayerhandhai.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerHandHaiClient) GetX(ctx context.Context, id int) *GamePlayerHandHai {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GamePlayerHandHaiClient) Hooks() []Hook {
	return c.hooks.GamePlayerHandHai
}

// GamePlayerPointClient is a client for the GamePlayerPoint schema.
type GamePlayerPointClient struct {
	config
}

// NewGamePlayerPointClient returns a client for the GamePlayerPoint from the given config.
func NewGamePlayerPointClient(c config) *GamePlayerPointClient {
	return &GamePlayerPointClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayerpoint.Hooks(f(g(h())))`.
func (c *GamePlayerPointClient) Use(hooks ...Hook) {
	c.hooks.GamePlayerPoint = append(c.hooks.GamePlayerPoint, hooks...)
}

// Create returns a builder for creating a GamePlayerPoint entity.
func (c *GamePlayerPointClient) Create() *GamePlayerPointCreate {
	mutation := newGamePlayerPointMutation(c.config, OpCreate)
	return &GamePlayerPointCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayerPoint entities.
func (c *GamePlayerPointClient) CreateBulk(builders ...*GamePlayerPointCreate) *GamePlayerPointCreateBulk {
	return &GamePlayerPointCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Update() *GamePlayerPointUpdate {
	mutation := newGamePlayerPointMutation(c.config, OpUpdate)
	return &GamePlayerPointUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerPointClient) UpdateOne(gpp *GamePlayerPoint) *GamePlayerPointUpdateOne {
	mutation := newGamePlayerPointMutation(c.config, OpUpdateOne, withGamePlayerPoint(gpp))
	return &GamePlayerPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerPointClient) UpdateOneID(id int) *GamePlayerPointUpdateOne {
	mutation := newGamePlayerPointMutation(c.config, OpUpdateOne, withGamePlayerPointID(id))
	return &GamePlayerPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Delete() *GamePlayerPointDelete {
	mutation := newGamePlayerPointMutation(c.config, OpDelete)
	return &GamePlayerPointDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerPointClient) DeleteOne(gpp *GamePlayerPoint) *GamePlayerPointDeleteOne {
	return c.DeleteOneID(gpp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerPointClient) DeleteOneID(id int) *GamePlayerPointDeleteOne {
	builder := c.Delete().Where(gameplayerpoint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerPointDeleteOne{builder}
}

// Query returns a query builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Query() *GamePlayerPointQuery {
	return &GamePlayerPointQuery{
		config: c.config,
	}
}

// Get returns a GamePlayerPoint entity by its id.
func (c *GamePlayerPointClient) Get(ctx context.Context, id int) (*GamePlayerPoint, error) {
	return c.Query().Where(gameplayerpoint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerPointClient) GetX(ctx context.Context, id int) *GamePlayerPoint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GamePlayerPointClient) Hooks() []Hook {
	return c.hooks.GamePlayerPoint
}

// GoAroundClient is a client for the GoAround schema.
type GoAroundClient struct {
	config
}

// NewGoAroundClient returns a client for the GoAround from the given config.
func NewGoAroundClient(c config) *GoAroundClient {
	return &GoAroundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `goaround.Hooks(f(g(h())))`.
func (c *GoAroundClient) Use(hooks ...Hook) {
	c.hooks.GoAround = append(c.hooks.GoAround, hooks...)
}

// Create returns a builder for creating a GoAround entity.
func (c *GoAroundClient) Create() *GoAroundCreate {
	mutation := newGoAroundMutation(c.config, OpCreate)
	return &GoAroundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GoAround entities.
func (c *GoAroundClient) CreateBulk(builders ...*GoAroundCreate) *GoAroundCreateBulk {
	return &GoAroundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GoAround.
func (c *GoAroundClient) Update() *GoAroundUpdate {
	mutation := newGoAroundMutation(c.config, OpUpdate)
	return &GoAroundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GoAroundClient) UpdateOne(ga *GoAround) *GoAroundUpdateOne {
	mutation := newGoAroundMutation(c.config, OpUpdateOne, withGoAround(ga))
	return &GoAroundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GoAroundClient) UpdateOneID(id uuid.UUID) *GoAroundUpdateOne {
	mutation := newGoAroundMutation(c.config, OpUpdateOne, withGoAroundID(id))
	return &GoAroundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GoAround.
func (c *GoAroundClient) Delete() *GoAroundDelete {
	mutation := newGoAroundMutation(c.config, OpDelete)
	return &GoAroundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GoAroundClient) DeleteOne(ga *GoAround) *GoAroundDeleteOne {
	return c.DeleteOneID(ga.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GoAroundClient) DeleteOneID(id uuid.UUID) *GoAroundDeleteOne {
	builder := c.Delete().Where(goaround.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GoAroundDeleteOne{builder}
}

// Query returns a query builder for GoAround.
func (c *GoAroundClient) Query() *GoAroundQuery {
	return &GoAroundQuery{
		config: c.config,
	}
}

// Get returns a GoAround entity by its id.
func (c *GoAroundClient) Get(ctx context.Context, id uuid.UUID) (*GoAround, error) {
	return c.Query().Where(goaround.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GoAroundClient) GetX(ctx context.Context, id uuid.UUID) *GoAround {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GoAroundClient) Hooks() []Hook {
	return c.hooks.GoAround
}

// HandClient is a client for the Hand schema.
type HandClient struct {
	config
}

// NewHandClient returns a client for the Hand from the given config.
func NewHandClient(c config) *HandClient {
	return &HandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hand.Hooks(f(g(h())))`.
func (c *HandClient) Use(hooks ...Hook) {
	c.hooks.Hand = append(c.hooks.Hand, hooks...)
}

// Create returns a builder for creating a Hand entity.
func (c *HandClient) Create() *HandCreate {
	mutation := newHandMutation(c.config, OpCreate)
	return &HandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hand entities.
func (c *HandClient) CreateBulk(builders ...*HandCreate) *HandCreateBulk {
	return &HandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hand.
func (c *HandClient) Update() *HandUpdate {
	mutation := newHandMutation(c.config, OpUpdate)
	return &HandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HandClient) UpdateOne(h *Hand) *HandUpdateOne {
	mutation := newHandMutation(c.config, OpUpdateOne, withHand(h))
	return &HandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HandClient) UpdateOneID(id uuid.UUID) *HandUpdateOne {
	mutation := newHandMutation(c.config, OpUpdateOne, withHandID(id))
	return &HandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hand.
func (c *HandClient) Delete() *HandDelete {
	mutation := newHandMutation(c.config, OpDelete)
	return &HandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HandClient) DeleteOne(h *Hand) *HandDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HandClient) DeleteOneID(id uuid.UUID) *HandDeleteOne {
	builder := c.Delete().Where(hand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HandDeleteOne{builder}
}

// Query returns a query builder for Hand.
func (c *HandClient) Query() *HandQuery {
	return &HandQuery{
		config: c.config,
	}
}

// Get returns a Hand entity by its id.
func (c *HandClient) Get(ctx context.Context, id uuid.UUID) (*Hand, error) {
	return c.Query().Where(hand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HandClient) GetX(ctx context.Context, id uuid.UUID) *Hand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *HandClient) Hooks() []Hook {
	return c.hooks.Hand
}

// MJLogClient is a client for the MJLog schema.
type MJLogClient struct {
	config
}

// NewMJLogClient returns a client for the MJLog from the given config.
func NewMJLogClient(c config) *MJLogClient {
	return &MJLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mjlog.Hooks(f(g(h())))`.
func (c *MJLogClient) Use(hooks ...Hook) {
	c.hooks.MJLog = append(c.hooks.MJLog, hooks...)
}

// Create returns a builder for creating a MJLog entity.
func (c *MJLogClient) Create() *MJLogCreate {
	mutation := newMJLogMutation(c.config, OpCreate)
	return &MJLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MJLog entities.
func (c *MJLogClient) CreateBulk(builders ...*MJLogCreate) *MJLogCreateBulk {
	return &MJLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MJLog.
func (c *MJLogClient) Update() *MJLogUpdate {
	mutation := newMJLogMutation(c.config, OpUpdate)
	return &MJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MJLogClient) UpdateOne(ml *MJLog) *MJLogUpdateOne {
	mutation := newMJLogMutation(c.config, OpUpdateOne, withMJLog(ml))
	return &MJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MJLogClient) UpdateOneID(id uuid.UUID) *MJLogUpdateOne {
	mutation := newMJLogMutation(c.config, OpUpdateOne, withMJLogID(id))
	return &MJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MJLog.
func (c *MJLogClient) Delete() *MJLogDelete {
	mutation := newMJLogMutation(c.config, OpDelete)
	return &MJLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MJLogClient) DeleteOne(ml *MJLog) *MJLogDeleteOne {
	return c.DeleteOneID(ml.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MJLogClient) DeleteOneID(id uuid.UUID) *MJLogDeleteOne {
	builder := c.Delete().Where(mjlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MJLogDeleteOne{builder}
}

// Query returns a query builder for MJLog.
func (c *MJLogClient) Query() *MJLogQuery {
	return &MJLogQuery{
		config: c.config,
	}
}

// Get returns a MJLog entity by its id.
func (c *MJLogClient) Get(ctx context.Context, id uuid.UUID) (*MJLog, error) {
	return c.Query().Where(mjlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MJLogClient) GetX(ctx context.Context, id uuid.UUID) *MJLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogFiles queries the mjlog_files edge of a MJLog.
func (c *MJLogClient) QueryMjlogFiles(ml *MJLog) *MJLogFileQuery {
	query := &MJLogFileQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlog.Table, mjlog.FieldID, id),
			sqlgraph.To(mjlogfile.Table, mjlogfile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlog.MjlogFilesTable, mjlog.MjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGames queries the games edge of a MJLog.
func (c *MJLogClient) QueryGames(ml *MJLog) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlog.Table, mjlog.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlog.GamesTable, mjlog.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MJLogClient) Hooks() []Hook {
	return c.hooks.MJLog
}

// MJLogFileClient is a client for the MJLogFile schema.
type MJLogFileClient struct {
	config
}

// NewMJLogFileClient returns a client for the MJLogFile from the given config.
func NewMJLogFileClient(c config) *MJLogFileClient {
	return &MJLogFileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mjlogfile.Hooks(f(g(h())))`.
func (c *MJLogFileClient) Use(hooks ...Hook) {
	c.hooks.MJLogFile = append(c.hooks.MJLogFile, hooks...)
}

// Create returns a builder for creating a MJLogFile entity.
func (c *MJLogFileClient) Create() *MJLogFileCreate {
	mutation := newMJLogFileMutation(c.config, OpCreate)
	return &MJLogFileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MJLogFile entities.
func (c *MJLogFileClient) CreateBulk(builders ...*MJLogFileCreate) *MJLogFileCreateBulk {
	return &MJLogFileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MJLogFile.
func (c *MJLogFileClient) Update() *MJLogFileUpdate {
	mutation := newMJLogFileMutation(c.config, OpUpdate)
	return &MJLogFileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MJLogFileClient) UpdateOne(mlf *MJLogFile) *MJLogFileUpdateOne {
	mutation := newMJLogFileMutation(c.config, OpUpdateOne, withMJLogFile(mlf))
	return &MJLogFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MJLogFileClient) UpdateOneID(id uuid.UUID) *MJLogFileUpdateOne {
	mutation := newMJLogFileMutation(c.config, OpUpdateOne, withMJLogFileID(id))
	return &MJLogFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MJLogFile.
func (c *MJLogFileClient) Delete() *MJLogFileDelete {
	mutation := newMJLogFileMutation(c.config, OpDelete)
	return &MJLogFileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MJLogFileClient) DeleteOne(mlf *MJLogFile) *MJLogFileDeleteOne {
	return c.DeleteOneID(mlf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MJLogFileClient) DeleteOneID(id uuid.UUID) *MJLogFileDeleteOne {
	builder := c.Delete().Where(mjlogfile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MJLogFileDeleteOne{builder}
}

// Query returns a query builder for MJLogFile.
func (c *MJLogFileClient) Query() *MJLogFileQuery {
	return &MJLogFileQuery{
		config: c.config,
	}
}

// Get returns a MJLogFile entity by its id.
func (c *MJLogFileClient) Get(ctx context.Context, id uuid.UUID) (*MJLogFile, error) {
	return c.Query().Where(mjlogfile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MJLogFileClient) GetX(ctx context.Context, id uuid.UUID) *MJLogFile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompressedMjlogFiles queries the compressed_mjlog_files edge of a MJLogFile.
func (c *MJLogFileClient) QueryCompressedMjlogFiles(mlf *MJLogFile) *CompressedMJLogQuery {
	query := &CompressedMJLogQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mlf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlogfile.Table, mjlogfile.FieldID, id),
			sqlgraph.To(compressedmjlog.Table, compressedmjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlogfile.CompressedMjlogFilesTable, mjlogfile.CompressedMjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(mlf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMjlogs queries the mjlogs edge of a MJLogFile.
func (c *MJLogFileClient) QueryMjlogs(mlf *MJLogFile) *MJLogQuery {
	query := &MJLogQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mlf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlogfile.Table, mjlogfile.FieldID, id),
			sqlgraph.To(mjlog.Table, mjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, mjlogfile.MjlogsTable, mjlogfile.MjlogsColumn),
		)
		fromV = sqlgraph.Neighbors(mlf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MJLogFileClient) Hooks() []Hook {
	return c.hooks.MJLogFile
}

// PlayerClient is a client for the Player schema.
type PlayerClient struct {
	config
}

// NewPlayerClient returns a client for the Player from the given config.
func NewPlayerClient(c config) *PlayerClient {
	return &PlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `player.Hooks(f(g(h())))`.
func (c *PlayerClient) Use(hooks ...Hook) {
	c.hooks.Player = append(c.hooks.Player, hooks...)
}

// Create returns a builder for creating a Player entity.
func (c *PlayerClient) Create() *PlayerCreate {
	mutation := newPlayerMutation(c.config, OpCreate)
	return &PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Player entities.
func (c *PlayerClient) CreateBulk(builders ...*PlayerCreate) *PlayerCreateBulk {
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Player.
func (c *PlayerClient) Update() *PlayerUpdate {
	mutation := newPlayerMutation(c.config, OpUpdate)
	return &PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerClient) UpdateOne(pl *Player) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayer(pl))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerClient) UpdateOneID(id uuid.UUID) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayerID(id))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Player.
func (c *PlayerClient) Delete() *PlayerDelete {
	mutation := newPlayerMutation(c.config, OpDelete)
	return &PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerClient) DeleteOne(pl *Player) *PlayerDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerClient) DeleteOneID(id uuid.UUID) *PlayerDeleteOne {
	builder := c.Delete().Where(player.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerDeleteOne{builder}
}

// Query returns a query builder for Player.
func (c *PlayerClient) Query() *PlayerQuery {
	return &PlayerQuery{
		config: c.config,
	}
}

// Get returns a Player entity by its id.
func (c *PlayerClient) Get(ctx context.Context, id uuid.UUID) (*Player, error) {
	return c.Query().Where(player.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerClient) GetX(ctx context.Context, id uuid.UUID) *Player {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGamePlayers queries the game_players edge of a Player.
func (c *PlayerClient) QueryGamePlayers(pl *Player) *GamePlayerQuery {
	query := &GamePlayerQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.GamePlayersTable, player.GamePlayersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerClient) Hooks() []Hook {
	return c.hooks.Player
}

// RoomClient is a client for the Room schema.
type RoomClient struct {
	config
}

// NewRoomClient returns a client for the Room from the given config.
func NewRoomClient(c config) *RoomClient {
	return &RoomClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `room.Hooks(f(g(h())))`.
func (c *RoomClient) Use(hooks ...Hook) {
	c.hooks.Room = append(c.hooks.Room, hooks...)
}

// Create returns a builder for creating a Room entity.
func (c *RoomClient) Create() *RoomCreate {
	mutation := newRoomMutation(c.config, OpCreate)
	return &RoomCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Room entities.
func (c *RoomClient) CreateBulk(builders ...*RoomCreate) *RoomCreateBulk {
	return &RoomCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Room.
func (c *RoomClient) Update() *RoomUpdate {
	mutation := newRoomMutation(c.config, OpUpdate)
	return &RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoomClient) UpdateOne(r *Room) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoom(r))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoomClient) UpdateOneID(id uuid.UUID) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoomID(id))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Room.
func (c *RoomClient) Delete() *RoomDelete {
	mutation := newRoomMutation(c.config, OpDelete)
	return &RoomDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoomClient) DeleteOne(r *Room) *RoomDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoomClient) DeleteOneID(id uuid.UUID) *RoomDeleteOne {
	builder := c.Delete().Where(room.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoomDeleteOne{builder}
}

// Query returns a query builder for Room.
func (c *RoomClient) Query() *RoomQuery {
	return &RoomQuery{
		config: c.config,
	}
}

// Get returns a Room entity by its id.
func (c *RoomClient) Get(ctx context.Context, id uuid.UUID) (*Room, error) {
	return c.Query().Where(room.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoomClient) GetX(ctx context.Context, id uuid.UUID) *Room {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Room.
func (c *RoomClient) QueryGames(r *Room) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, room.GamesTable, room.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoomClient) Hooks() []Hook {
	return c.hooks.Room
}

// RoundClient is a client for the Round schema.
type RoundClient struct {
	config
}

// NewRoundClient returns a client for the Round from the given config.
func NewRoundClient(c config) *RoundClient {
	return &RoundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `round.Hooks(f(g(h())))`.
func (c *RoundClient) Use(hooks ...Hook) {
	c.hooks.Round = append(c.hooks.Round, hooks...)
}

// Create returns a builder for creating a Round entity.
func (c *RoundClient) Create() *RoundCreate {
	mutation := newRoundMutation(c.config, OpCreate)
	return &RoundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Round entities.
func (c *RoundClient) CreateBulk(builders ...*RoundCreate) *RoundCreateBulk {
	return &RoundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Round.
func (c *RoundClient) Update() *RoundUpdate {
	mutation := newRoundMutation(c.config, OpUpdate)
	return &RoundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoundClient) UpdateOne(r *Round) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRound(r))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoundClient) UpdateOneID(id uuid.UUID) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRoundID(id))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Round.
func (c *RoundClient) Delete() *RoundDelete {
	mutation := newRoundMutation(c.config, OpDelete)
	return &RoundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoundClient) DeleteOne(r *Round) *RoundDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoundClient) DeleteOneID(id uuid.UUID) *RoundDeleteOne {
	builder := c.Delete().Where(round.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoundDeleteOne{builder}
}

// Query returns a query builder for Round.
func (c *RoundClient) Query() *RoundQuery {
	return &RoundQuery{
		config: c.config,
	}
}

// Get returns a Round entity by its id.
func (c *RoundClient) Get(ctx context.Context, id uuid.UUID) (*Round, error) {
	return c.Query().Where(round.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoundClient) GetX(ctx context.Context, id uuid.UUID) *Round {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Round.
func (c *RoundClient) QueryGames(r *Round) *GameQuery {
	query := &GameQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, round.GamesTable, round.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWinds queries the winds edge of a Round.
func (c *RoundClient) QueryWinds(r *Round) *WindQuery {
	query := &WindQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(wind.Table, wind.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, round.WindsTable, round.WindsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoundClient) Hooks() []Hook {
	return c.hooks.Round
}

// WindClient is a client for the Wind schema.
type WindClient struct {
	config
}

// NewWindClient returns a client for the Wind from the given config.
func NewWindClient(c config) *WindClient {
	return &WindClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `wind.Hooks(f(g(h())))`.
func (c *WindClient) Use(hooks ...Hook) {
	c.hooks.Wind = append(c.hooks.Wind, hooks...)
}

// Create returns a builder for creating a Wind entity.
func (c *WindClient) Create() *WindCreate {
	mutation := newWindMutation(c.config, OpCreate)
	return &WindCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Wind entities.
func (c *WindClient) CreateBulk(builders ...*WindCreate) *WindCreateBulk {
	return &WindCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Wind.
func (c *WindClient) Update() *WindUpdate {
	mutation := newWindMutation(c.config, OpUpdate)
	return &WindUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WindClient) UpdateOne(w *Wind) *WindUpdateOne {
	mutation := newWindMutation(c.config, OpUpdateOne, withWind(w))
	return &WindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WindClient) UpdateOneID(id uuid.UUID) *WindUpdateOne {
	mutation := newWindMutation(c.config, OpUpdateOne, withWindID(id))
	return &WindUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Wind.
func (c *WindClient) Delete() *WindDelete {
	mutation := newWindMutation(c.config, OpDelete)
	return &WindDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WindClient) DeleteOne(w *Wind) *WindDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WindClient) DeleteOneID(id uuid.UUID) *WindDeleteOne {
	builder := c.Delete().Where(wind.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WindDeleteOne{builder}
}

// Query returns a query builder for Wind.
func (c *WindClient) Query() *WindQuery {
	return &WindQuery{
		config: c.config,
	}
}

// Get returns a Wind entity by its id.
func (c *WindClient) Get(ctx context.Context, id uuid.UUID) (*Wind, error) {
	return c.Query().Where(wind.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WindClient) GetX(ctx context.Context, id uuid.UUID) *Wind {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRounds queries the rounds edge of a Wind.
func (c *WindClient) QueryRounds(w *Wind) *RoundQuery {
	query := &RoundQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(wind.Table, wind.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, wind.RoundsTable, wind.RoundsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WindClient) Hooks() []Hook {
	return c.hooks.Wind
}
