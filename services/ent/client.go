// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/kanade0404/tenhou-log/services/ent/migrate"

	"github.com/kanade0404/tenhou-log/services/ent/call"
	"github.com/kanade0404/tenhou-log/services/ent/chakan"
	"github.com/kanade0404/tenhou-log/services/ent/chii"
	"github.com/kanade0404/tenhou-log/services/ent/compressedmjlog"
	"github.com/kanade0404/tenhou-log/services/ent/concealedkan"
	"github.com/kanade0404/tenhou-log/services/ent/dan"
	"github.com/kanade0404/tenhou-log/services/ent/discard"
	"github.com/kanade0404/tenhou-log/services/ent/drawn"
	"github.com/kanade0404/tenhou-log/services/ent/event"
	"github.com/kanade0404/tenhou-log/services/ent/game"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayer"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerhandhai"
	"github.com/kanade0404/tenhou-log/services/ent/gameplayerpoint"
	"github.com/kanade0404/tenhou-log/services/ent/hand"
	"github.com/kanade0404/tenhou-log/services/ent/meldedkan"
	"github.com/kanade0404/tenhou-log/services/ent/mjlog"
	"github.com/kanade0404/tenhou-log/services/ent/mjlogfile"
	"github.com/kanade0404/tenhou-log/services/ent/player"
	"github.com/kanade0404/tenhou-log/services/ent/pon"
	"github.com/kanade0404/tenhou-log/services/ent/reach"
	"github.com/kanade0404/tenhou-log/services/ent/room"
	"github.com/kanade0404/tenhou-log/services/ent/round"
	"github.com/kanade0404/tenhou-log/services/ent/turn"
	"github.com/kanade0404/tenhou-log/services/ent/win"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Call is the client for interacting with the Call builders.
	Call *CallClient
	// Chakan is the client for interacting with the Chakan builders.
	Chakan *ChakanClient
	// Chii is the client for interacting with the Chii builders.
	Chii *ChiiClient
	// CompressedMJLog is the client for interacting with the CompressedMJLog builders.
	CompressedMJLog *CompressedMJLogClient
	// ConcealedKan is the client for interacting with the ConcealedKan builders.
	ConcealedKan *ConcealedKanClient
	// Dan is the client for interacting with the Dan builders.
	Dan *DanClient
	// Discard is the client for interacting with the Discard builders.
	Discard *DiscardClient
	// Drawn is the client for interacting with the Drawn builders.
	Drawn *DrawnClient
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// Game is the client for interacting with the Game builders.
	Game *GameClient
	// GamePlayer is the client for interacting with the GamePlayer builders.
	GamePlayer *GamePlayerClient
	// GamePlayerHandHai is the client for interacting with the GamePlayerHandHai builders.
	GamePlayerHandHai *GamePlayerHandHaiClient
	// GamePlayerPoint is the client for interacting with the GamePlayerPoint builders.
	GamePlayerPoint *GamePlayerPointClient
	// Hand is the client for interacting with the Hand builders.
	Hand *HandClient
	// MJLog is the client for interacting with the MJLog builders.
	MJLog *MJLogClient
	// MJLogFile is the client for interacting with the MJLogFile builders.
	MJLogFile *MJLogFileClient
	// MeldedKan is the client for interacting with the MeldedKan builders.
	MeldedKan *MeldedKanClient
	// Player is the client for interacting with the Player builders.
	Player *PlayerClient
	// Pon is the client for interacting with the Pon builders.
	Pon *PonClient
	// Reach is the client for interacting with the Reach builders.
	Reach *ReachClient
	// Room is the client for interacting with the Room builders.
	Room *RoomClient
	// Round is the client for interacting with the Round builders.
	Round *RoundClient
	// Turn is the client for interacting with the Turn builders.
	Turn *TurnClient
	// Win is the client for interacting with the Win builders.
	Win *WinClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Call = NewCallClient(c.config)
	c.Chakan = NewChakanClient(c.config)
	c.Chii = NewChiiClient(c.config)
	c.CompressedMJLog = NewCompressedMJLogClient(c.config)
	c.ConcealedKan = NewConcealedKanClient(c.config)
	c.Dan = NewDanClient(c.config)
	c.Discard = NewDiscardClient(c.config)
	c.Drawn = NewDrawnClient(c.config)
	c.Event = NewEventClient(c.config)
	c.Game = NewGameClient(c.config)
	c.GamePlayer = NewGamePlayerClient(c.config)
	c.GamePlayerHandHai = NewGamePlayerHandHaiClient(c.config)
	c.GamePlayerPoint = NewGamePlayerPointClient(c.config)
	c.Hand = NewHandClient(c.config)
	c.MJLog = NewMJLogClient(c.config)
	c.MJLogFile = NewMJLogFileClient(c.config)
	c.MeldedKan = NewMeldedKanClient(c.config)
	c.Player = NewPlayerClient(c.config)
	c.Pon = NewPonClient(c.config)
	c.Reach = NewReachClient(c.config)
	c.Room = NewRoomClient(c.config)
	c.Round = NewRoundClient(c.config)
	c.Turn = NewTurnClient(c.config)
	c.Win = NewWinClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Call:              NewCallClient(cfg),
		Chakan:            NewChakanClient(cfg),
		Chii:              NewChiiClient(cfg),
		CompressedMJLog:   NewCompressedMJLogClient(cfg),
		ConcealedKan:      NewConcealedKanClient(cfg),
		Dan:               NewDanClient(cfg),
		Discard:           NewDiscardClient(cfg),
		Drawn:             NewDrawnClient(cfg),
		Event:             NewEventClient(cfg),
		Game:              NewGameClient(cfg),
		GamePlayer:        NewGamePlayerClient(cfg),
		GamePlayerHandHai: NewGamePlayerHandHaiClient(cfg),
		GamePlayerPoint:   NewGamePlayerPointClient(cfg),
		Hand:              NewHandClient(cfg),
		MJLog:             NewMJLogClient(cfg),
		MJLogFile:         NewMJLogFileClient(cfg),
		MeldedKan:         NewMeldedKanClient(cfg),
		Player:            NewPlayerClient(cfg),
		Pon:               NewPonClient(cfg),
		Reach:             NewReachClient(cfg),
		Room:              NewRoomClient(cfg),
		Round:             NewRoundClient(cfg),
		Turn:              NewTurnClient(cfg),
		Win:               NewWinClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Call:              NewCallClient(cfg),
		Chakan:            NewChakanClient(cfg),
		Chii:              NewChiiClient(cfg),
		CompressedMJLog:   NewCompressedMJLogClient(cfg),
		ConcealedKan:      NewConcealedKanClient(cfg),
		Dan:               NewDanClient(cfg),
		Discard:           NewDiscardClient(cfg),
		Drawn:             NewDrawnClient(cfg),
		Event:             NewEventClient(cfg),
		Game:              NewGameClient(cfg),
		GamePlayer:        NewGamePlayerClient(cfg),
		GamePlayerHandHai: NewGamePlayerHandHaiClient(cfg),
		GamePlayerPoint:   NewGamePlayerPointClient(cfg),
		Hand:              NewHandClient(cfg),
		MJLog:             NewMJLogClient(cfg),
		MJLogFile:         NewMJLogFileClient(cfg),
		MeldedKan:         NewMeldedKanClient(cfg),
		Player:            NewPlayerClient(cfg),
		Pon:               NewPonClient(cfg),
		Reach:             NewReachClient(cfg),
		Room:              NewRoomClient(cfg),
		Round:             NewRoundClient(cfg),
		Turn:              NewTurnClient(cfg),
		Win:               NewWinClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Call.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Call.Use(hooks...)
	c.Chakan.Use(hooks...)
	c.Chii.Use(hooks...)
	c.CompressedMJLog.Use(hooks...)
	c.ConcealedKan.Use(hooks...)
	c.Dan.Use(hooks...)
	c.Discard.Use(hooks...)
	c.Drawn.Use(hooks...)
	c.Event.Use(hooks...)
	c.Game.Use(hooks...)
	c.GamePlayer.Use(hooks...)
	c.GamePlayerHandHai.Use(hooks...)
	c.GamePlayerPoint.Use(hooks...)
	c.Hand.Use(hooks...)
	c.MJLog.Use(hooks...)
	c.MJLogFile.Use(hooks...)
	c.MeldedKan.Use(hooks...)
	c.Player.Use(hooks...)
	c.Pon.Use(hooks...)
	c.Reach.Use(hooks...)
	c.Room.Use(hooks...)
	c.Round.Use(hooks...)
	c.Turn.Use(hooks...)
	c.Win.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.Call.Intercept(interceptors...)
	c.Chakan.Intercept(interceptors...)
	c.Chii.Intercept(interceptors...)
	c.CompressedMJLog.Intercept(interceptors...)
	c.ConcealedKan.Intercept(interceptors...)
	c.Dan.Intercept(interceptors...)
	c.Discard.Intercept(interceptors...)
	c.Drawn.Intercept(interceptors...)
	c.Event.Intercept(interceptors...)
	c.Game.Intercept(interceptors...)
	c.GamePlayer.Intercept(interceptors...)
	c.GamePlayerHandHai.Intercept(interceptors...)
	c.GamePlayerPoint.Intercept(interceptors...)
	c.Hand.Intercept(interceptors...)
	c.MJLog.Intercept(interceptors...)
	c.MJLogFile.Intercept(interceptors...)
	c.MeldedKan.Intercept(interceptors...)
	c.Player.Intercept(interceptors...)
	c.Pon.Intercept(interceptors...)
	c.Reach.Intercept(interceptors...)
	c.Room.Intercept(interceptors...)
	c.Round.Intercept(interceptors...)
	c.Turn.Intercept(interceptors...)
	c.Win.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *CallMutation:
		return c.Call.mutate(ctx, m)
	case *ChakanMutation:
		return c.Chakan.mutate(ctx, m)
	case *ChiiMutation:
		return c.Chii.mutate(ctx, m)
	case *CompressedMJLogMutation:
		return c.CompressedMJLog.mutate(ctx, m)
	case *ConcealedKanMutation:
		return c.ConcealedKan.mutate(ctx, m)
	case *DanMutation:
		return c.Dan.mutate(ctx, m)
	case *DiscardMutation:
		return c.Discard.mutate(ctx, m)
	case *DrawnMutation:
		return c.Drawn.mutate(ctx, m)
	case *EventMutation:
		return c.Event.mutate(ctx, m)
	case *GameMutation:
		return c.Game.mutate(ctx, m)
	case *GamePlayerMutation:
		return c.GamePlayer.mutate(ctx, m)
	case *GamePlayerHandHaiMutation:
		return c.GamePlayerHandHai.mutate(ctx, m)
	case *GamePlayerPointMutation:
		return c.GamePlayerPoint.mutate(ctx, m)
	case *HandMutation:
		return c.Hand.mutate(ctx, m)
	case *MJLogMutation:
		return c.MJLog.mutate(ctx, m)
	case *MJLogFileMutation:
		return c.MJLogFile.mutate(ctx, m)
	case *MeldedKanMutation:
		return c.MeldedKan.mutate(ctx, m)
	case *PlayerMutation:
		return c.Player.mutate(ctx, m)
	case *PonMutation:
		return c.Pon.mutate(ctx, m)
	case *ReachMutation:
		return c.Reach.mutate(ctx, m)
	case *RoomMutation:
		return c.Room.mutate(ctx, m)
	case *RoundMutation:
		return c.Round.mutate(ctx, m)
	case *TurnMutation:
		return c.Turn.mutate(ctx, m)
	case *WinMutation:
		return c.Win.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// CallClient is a client for the Call schema.
type CallClient struct {
	config
}

// NewCallClient returns a client for the Call from the given config.
func NewCallClient(c config) *CallClient {
	return &CallClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `call.Hooks(f(g(h())))`.
func (c *CallClient) Use(hooks ...Hook) {
	c.hooks.Call = append(c.hooks.Call, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `call.Intercept(f(g(h())))`.
func (c *CallClient) Intercept(interceptors ...Interceptor) {
	c.inters.Call = append(c.inters.Call, interceptors...)
}

// Create returns a builder for creating a Call entity.
func (c *CallClient) Create() *CallCreate {
	mutation := newCallMutation(c.config, OpCreate)
	return &CallCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Call entities.
func (c *CallClient) CreateBulk(builders ...*CallCreate) *CallCreateBulk {
	return &CallCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Call.
func (c *CallClient) Update() *CallUpdate {
	mutation := newCallMutation(c.config, OpUpdate)
	return &CallUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CallClient) UpdateOne(ca *Call) *CallUpdateOne {
	mutation := newCallMutation(c.config, OpUpdateOne, withCall(ca))
	return &CallUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CallClient) UpdateOneID(id uuid.UUID) *CallUpdateOne {
	mutation := newCallMutation(c.config, OpUpdateOne, withCallID(id))
	return &CallUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Call.
func (c *CallClient) Delete() *CallDelete {
	mutation := newCallMutation(c.config, OpDelete)
	return &CallDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CallClient) DeleteOne(ca *Call) *CallDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CallClient) DeleteOneID(id uuid.UUID) *CallDeleteOne {
	builder := c.Delete().Where(call.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CallDeleteOne{builder}
}

// Query returns a query builder for Call.
func (c *CallClient) Query() *CallQuery {
	return &CallQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Call entity by its id.
func (c *CallClient) Get(ctx context.Context, id uuid.UUID) (*Call, error) {
	return c.Query().Where(call.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CallClient) GetX(ctx context.Context, id uuid.UUID) *Call {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a Call.
func (c *CallClient) QueryEvent(ca *Call) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(call.Table, call.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, call.EventTable, call.EventColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscard queries the discard edge of a Call.
func (c *CallClient) QueryDiscard(ca *Call) *DiscardQuery {
	query := (&DiscardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(call.Table, call.FieldID, id),
			sqlgraph.To(discard.Table, discard.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, call.DiscardTable, call.DiscardColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChii queries the chii edge of a Call.
func (c *CallClient) QueryChii(ca *Call) *ChiiQuery {
	query := (&ChiiClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(call.Table, call.FieldID, id),
			sqlgraph.To(chii.Table, chii.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, call.ChiiTable, call.ChiiColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChakan queries the chakan edge of a Call.
func (c *CallClient) QueryChakan(ca *Call) *ChakanQuery {
	query := (&ChakanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(call.Table, call.FieldID, id),
			sqlgraph.To(chakan.Table, chakan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, call.ChakanTable, call.ChakanColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConcealedkan queries the concealedkan edge of a Call.
func (c *CallClient) QueryConcealedkan(ca *Call) *ConcealedKanQuery {
	query := (&ConcealedKanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(call.Table, call.FieldID, id),
			sqlgraph.To(concealedkan.Table, concealedkan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, call.ConcealedkanTable, call.ConcealedkanColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMeldedkan queries the meldedkan edge of a Call.
func (c *CallClient) QueryMeldedkan(ca *Call) *MeldedKanQuery {
	query := (&MeldedKanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(call.Table, call.FieldID, id),
			sqlgraph.To(meldedkan.Table, meldedkan.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, call.MeldedkanTable, call.MeldedkanColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPon queries the pon edge of a Call.
func (c *CallClient) QueryPon(ca *Call) *PonQuery {
	query := (&PonClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(call.Table, call.FieldID, id),
			sqlgraph.To(pon.Table, pon.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, call.PonTable, call.PonColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CallClient) Hooks() []Hook {
	return c.hooks.Call
}

// Interceptors returns the client interceptors.
func (c *CallClient) Interceptors() []Interceptor {
	return c.inters.Call
}

func (c *CallClient) mutate(ctx context.Context, m *CallMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CallCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CallUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CallUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CallDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Call mutation op: %q", m.Op())
	}
}

// ChakanClient is a client for the Chakan schema.
type ChakanClient struct {
	config
}

// NewChakanClient returns a client for the Chakan from the given config.
func NewChakanClient(c config) *ChakanClient {
	return &ChakanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chakan.Hooks(f(g(h())))`.
func (c *ChakanClient) Use(hooks ...Hook) {
	c.hooks.Chakan = append(c.hooks.Chakan, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chakan.Intercept(f(g(h())))`.
func (c *ChakanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Chakan = append(c.inters.Chakan, interceptors...)
}

// Create returns a builder for creating a Chakan entity.
func (c *ChakanClient) Create() *ChakanCreate {
	mutation := newChakanMutation(c.config, OpCreate)
	return &ChakanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Chakan entities.
func (c *ChakanClient) CreateBulk(builders ...*ChakanCreate) *ChakanCreateBulk {
	return &ChakanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Chakan.
func (c *ChakanClient) Update() *ChakanUpdate {
	mutation := newChakanMutation(c.config, OpUpdate)
	return &ChakanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChakanClient) UpdateOne(ch *Chakan) *ChakanUpdateOne {
	mutation := newChakanMutation(c.config, OpUpdateOne, withChakan(ch))
	return &ChakanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChakanClient) UpdateOneID(id uuid.UUID) *ChakanUpdateOne {
	mutation := newChakanMutation(c.config, OpUpdateOne, withChakanID(id))
	return &ChakanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Chakan.
func (c *ChakanClient) Delete() *ChakanDelete {
	mutation := newChakanMutation(c.config, OpDelete)
	return &ChakanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChakanClient) DeleteOne(ch *Chakan) *ChakanDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChakanClient) DeleteOneID(id uuid.UUID) *ChakanDeleteOne {
	builder := c.Delete().Where(chakan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChakanDeleteOne{builder}
}

// Query returns a query builder for Chakan.
func (c *ChakanClient) Query() *ChakanQuery {
	return &ChakanQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Chakan entity by its id.
func (c *ChakanClient) Get(ctx context.Context, id uuid.UUID) (*Chakan, error) {
	return c.Query().Where(chakan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChakanClient) GetX(ctx context.Context, id uuid.UUID) *Chakan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCall queries the call edge of a Chakan.
func (c *ChakanClient) QueryCall(ch *Chakan) *CallQuery {
	query := (&CallClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chakan.Table, chakan.FieldID, id),
			sqlgraph.To(call.Table, call.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, chakan.CallTable, chakan.CallColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChakanClient) Hooks() []Hook {
	return c.hooks.Chakan
}

// Interceptors returns the client interceptors.
func (c *ChakanClient) Interceptors() []Interceptor {
	return c.inters.Chakan
}

func (c *ChakanClient) mutate(ctx context.Context, m *ChakanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChakanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChakanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChakanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChakanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Chakan mutation op: %q", m.Op())
	}
}

// ChiiClient is a client for the Chii schema.
type ChiiClient struct {
	config
}

// NewChiiClient returns a client for the Chii from the given config.
func NewChiiClient(c config) *ChiiClient {
	return &ChiiClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `chii.Hooks(f(g(h())))`.
func (c *ChiiClient) Use(hooks ...Hook) {
	c.hooks.Chii = append(c.hooks.Chii, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `chii.Intercept(f(g(h())))`.
func (c *ChiiClient) Intercept(interceptors ...Interceptor) {
	c.inters.Chii = append(c.inters.Chii, interceptors...)
}

// Create returns a builder for creating a Chii entity.
func (c *ChiiClient) Create() *ChiiCreate {
	mutation := newChiiMutation(c.config, OpCreate)
	return &ChiiCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Chii entities.
func (c *ChiiClient) CreateBulk(builders ...*ChiiCreate) *ChiiCreateBulk {
	return &ChiiCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Chii.
func (c *ChiiClient) Update() *ChiiUpdate {
	mutation := newChiiMutation(c.config, OpUpdate)
	return &ChiiUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChiiClient) UpdateOne(ch *Chii) *ChiiUpdateOne {
	mutation := newChiiMutation(c.config, OpUpdateOne, withChii(ch))
	return &ChiiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChiiClient) UpdateOneID(id uuid.UUID) *ChiiUpdateOne {
	mutation := newChiiMutation(c.config, OpUpdateOne, withChiiID(id))
	return &ChiiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Chii.
func (c *ChiiClient) Delete() *ChiiDelete {
	mutation := newChiiMutation(c.config, OpDelete)
	return &ChiiDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChiiClient) DeleteOne(ch *Chii) *ChiiDeleteOne {
	return c.DeleteOneID(ch.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChiiClient) DeleteOneID(id uuid.UUID) *ChiiDeleteOne {
	builder := c.Delete().Where(chii.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChiiDeleteOne{builder}
}

// Query returns a query builder for Chii.
func (c *ChiiClient) Query() *ChiiQuery {
	return &ChiiQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Chii entity by its id.
func (c *ChiiClient) Get(ctx context.Context, id uuid.UUID) (*Chii, error) {
	return c.Query().Where(chii.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChiiClient) GetX(ctx context.Context, id uuid.UUID) *Chii {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCall queries the call edge of a Chii.
func (c *ChiiClient) QueryCall(ch *Chii) *CallQuery {
	query := (&CallClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ch.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(chii.Table, chii.FieldID, id),
			sqlgraph.To(call.Table, call.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, chii.CallTable, chii.CallColumn),
		)
		fromV = sqlgraph.Neighbors(ch.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChiiClient) Hooks() []Hook {
	return c.hooks.Chii
}

// Interceptors returns the client interceptors.
func (c *ChiiClient) Interceptors() []Interceptor {
	return c.inters.Chii
}

func (c *ChiiClient) mutate(ctx context.Context, m *ChiiMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChiiCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChiiUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChiiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChiiDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Chii mutation op: %q", m.Op())
	}
}

// CompressedMJLogClient is a client for the CompressedMJLog schema.
type CompressedMJLogClient struct {
	config
}

// NewCompressedMJLogClient returns a client for the CompressedMJLog from the given config.
func NewCompressedMJLogClient(c config) *CompressedMJLogClient {
	return &CompressedMJLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `compressedmjlog.Hooks(f(g(h())))`.
func (c *CompressedMJLogClient) Use(hooks ...Hook) {
	c.hooks.CompressedMJLog = append(c.hooks.CompressedMJLog, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `compressedmjlog.Intercept(f(g(h())))`.
func (c *CompressedMJLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.CompressedMJLog = append(c.inters.CompressedMJLog, interceptors...)
}

// Create returns a builder for creating a CompressedMJLog entity.
func (c *CompressedMJLogClient) Create() *CompressedMJLogCreate {
	mutation := newCompressedMJLogMutation(c.config, OpCreate)
	return &CompressedMJLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CompressedMJLog entities.
func (c *CompressedMJLogClient) CreateBulk(builders ...*CompressedMJLogCreate) *CompressedMJLogCreateBulk {
	return &CompressedMJLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CompressedMJLog.
func (c *CompressedMJLogClient) Update() *CompressedMJLogUpdate {
	mutation := newCompressedMJLogMutation(c.config, OpUpdate)
	return &CompressedMJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CompressedMJLogClient) UpdateOne(cml *CompressedMJLog) *CompressedMJLogUpdateOne {
	mutation := newCompressedMJLogMutation(c.config, OpUpdateOne, withCompressedMJLog(cml))
	return &CompressedMJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CompressedMJLogClient) UpdateOneID(id uuid.UUID) *CompressedMJLogUpdateOne {
	mutation := newCompressedMJLogMutation(c.config, OpUpdateOne, withCompressedMJLogID(id))
	return &CompressedMJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CompressedMJLog.
func (c *CompressedMJLogClient) Delete() *CompressedMJLogDelete {
	mutation := newCompressedMJLogMutation(c.config, OpDelete)
	return &CompressedMJLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CompressedMJLogClient) DeleteOne(cml *CompressedMJLog) *CompressedMJLogDeleteOne {
	return c.DeleteOneID(cml.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CompressedMJLogClient) DeleteOneID(id uuid.UUID) *CompressedMJLogDeleteOne {
	builder := c.Delete().Where(compressedmjlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CompressedMJLogDeleteOne{builder}
}

// Query returns a query builder for CompressedMJLog.
func (c *CompressedMJLogClient) Query() *CompressedMJLogQuery {
	return &CompressedMJLogQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a CompressedMJLog entity by its id.
func (c *CompressedMJLogClient) Get(ctx context.Context, id uuid.UUID) (*CompressedMJLog, error) {
	return c.Query().Where(compressedmjlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CompressedMJLogClient) GetX(ctx context.Context, id uuid.UUID) *CompressedMJLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogFiles queries the mjlog_files edge of a CompressedMJLog.
func (c *CompressedMJLogClient) QueryMjlogFiles(cml *CompressedMJLog) *MJLogFileQuery {
	query := (&MJLogFileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(compressedmjlog.Table, compressedmjlog.FieldID, id),
			sqlgraph.To(mjlogfile.Table, mjlogfile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, compressedmjlog.MjlogFilesTable, compressedmjlog.MjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(cml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CompressedMJLogClient) Hooks() []Hook {
	return c.hooks.CompressedMJLog
}

// Interceptors returns the client interceptors.
func (c *CompressedMJLogClient) Interceptors() []Interceptor {
	return c.inters.CompressedMJLog
}

func (c *CompressedMJLogClient) mutate(ctx context.Context, m *CompressedMJLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CompressedMJLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CompressedMJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CompressedMJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CompressedMJLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CompressedMJLog mutation op: %q", m.Op())
	}
}

// ConcealedKanClient is a client for the ConcealedKan schema.
type ConcealedKanClient struct {
	config
}

// NewConcealedKanClient returns a client for the ConcealedKan from the given config.
func NewConcealedKanClient(c config) *ConcealedKanClient {
	return &ConcealedKanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `concealedkan.Hooks(f(g(h())))`.
func (c *ConcealedKanClient) Use(hooks ...Hook) {
	c.hooks.ConcealedKan = append(c.hooks.ConcealedKan, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `concealedkan.Intercept(f(g(h())))`.
func (c *ConcealedKanClient) Intercept(interceptors ...Interceptor) {
	c.inters.ConcealedKan = append(c.inters.ConcealedKan, interceptors...)
}

// Create returns a builder for creating a ConcealedKan entity.
func (c *ConcealedKanClient) Create() *ConcealedKanCreate {
	mutation := newConcealedKanMutation(c.config, OpCreate)
	return &ConcealedKanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConcealedKan entities.
func (c *ConcealedKanClient) CreateBulk(builders ...*ConcealedKanCreate) *ConcealedKanCreateBulk {
	return &ConcealedKanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConcealedKan.
func (c *ConcealedKanClient) Update() *ConcealedKanUpdate {
	mutation := newConcealedKanMutation(c.config, OpUpdate)
	return &ConcealedKanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConcealedKanClient) UpdateOne(ck *ConcealedKan) *ConcealedKanUpdateOne {
	mutation := newConcealedKanMutation(c.config, OpUpdateOne, withConcealedKan(ck))
	return &ConcealedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConcealedKanClient) UpdateOneID(id uuid.UUID) *ConcealedKanUpdateOne {
	mutation := newConcealedKanMutation(c.config, OpUpdateOne, withConcealedKanID(id))
	return &ConcealedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConcealedKan.
func (c *ConcealedKanClient) Delete() *ConcealedKanDelete {
	mutation := newConcealedKanMutation(c.config, OpDelete)
	return &ConcealedKanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConcealedKanClient) DeleteOne(ck *ConcealedKan) *ConcealedKanDeleteOne {
	return c.DeleteOneID(ck.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConcealedKanClient) DeleteOneID(id uuid.UUID) *ConcealedKanDeleteOne {
	builder := c.Delete().Where(concealedkan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConcealedKanDeleteOne{builder}
}

// Query returns a query builder for ConcealedKan.
func (c *ConcealedKanClient) Query() *ConcealedKanQuery {
	return &ConcealedKanQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a ConcealedKan entity by its id.
func (c *ConcealedKanClient) Get(ctx context.Context, id uuid.UUID) (*ConcealedKan, error) {
	return c.Query().Where(concealedkan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConcealedKanClient) GetX(ctx context.Context, id uuid.UUID) *ConcealedKan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCall queries the call edge of a ConcealedKan.
func (c *ConcealedKanClient) QueryCall(ck *ConcealedKan) *CallQuery {
	query := (&CallClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ck.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(concealedkan.Table, concealedkan.FieldID, id),
			sqlgraph.To(call.Table, call.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, concealedkan.CallTable, concealedkan.CallColumn),
		)
		fromV = sqlgraph.Neighbors(ck.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConcealedKanClient) Hooks() []Hook {
	return c.hooks.ConcealedKan
}

// Interceptors returns the client interceptors.
func (c *ConcealedKanClient) Interceptors() []Interceptor {
	return c.inters.ConcealedKan
}

func (c *ConcealedKanClient) mutate(ctx context.Context, m *ConcealedKanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConcealedKanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConcealedKanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConcealedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConcealedKanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ConcealedKan mutation op: %q", m.Op())
	}
}

// DanClient is a client for the Dan schema.
type DanClient struct {
	config
}

// NewDanClient returns a client for the Dan from the given config.
func NewDanClient(c config) *DanClient {
	return &DanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dan.Hooks(f(g(h())))`.
func (c *DanClient) Use(hooks ...Hook) {
	c.hooks.Dan = append(c.hooks.Dan, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dan.Intercept(f(g(h())))`.
func (c *DanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dan = append(c.inters.Dan, interceptors...)
}

// Create returns a builder for creating a Dan entity.
func (c *DanClient) Create() *DanCreate {
	mutation := newDanMutation(c.config, OpCreate)
	return &DanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dan entities.
func (c *DanClient) CreateBulk(builders ...*DanCreate) *DanCreateBulk {
	return &DanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dan.
func (c *DanClient) Update() *DanUpdate {
	mutation := newDanMutation(c.config, OpUpdate)
	return &DanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DanClient) UpdateOne(d *Dan) *DanUpdateOne {
	mutation := newDanMutation(c.config, OpUpdateOne, withDan(d))
	return &DanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DanClient) UpdateOneID(id uuid.UUID) *DanUpdateOne {
	mutation := newDanMutation(c.config, OpUpdateOne, withDanID(id))
	return &DanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dan.
func (c *DanClient) Delete() *DanDelete {
	mutation := newDanMutation(c.config, OpDelete)
	return &DanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DanClient) DeleteOne(d *Dan) *DanDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DanClient) DeleteOneID(id uuid.UUID) *DanDeleteOne {
	builder := c.Delete().Where(dan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DanDeleteOne{builder}
}

// Query returns a query builder for Dan.
func (c *DanClient) Query() *DanQuery {
	return &DanQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Dan entity by its id.
func (c *DanClient) Get(ctx context.Context, id uuid.UUID) (*Dan, error) {
	return c.Query().Where(dan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DanClient) GetX(ctx context.Context, id uuid.UUID) *Dan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGamePlayers queries the game_players edge of a Dan.
func (c *DanClient) QueryGamePlayers(d *Dan) *GamePlayerQuery {
	query := (&GamePlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dan.Table, dan.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dan.GamePlayersTable, dan.GamePlayersColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DanClient) Hooks() []Hook {
	return c.hooks.Dan
}

// Interceptors returns the client interceptors.
func (c *DanClient) Interceptors() []Interceptor {
	return c.inters.Dan
}

func (c *DanClient) mutate(ctx context.Context, m *DanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dan mutation op: %q", m.Op())
	}
}

// DiscardClient is a client for the Discard schema.
type DiscardClient struct {
	config
}

// NewDiscardClient returns a client for the Discard from the given config.
func NewDiscardClient(c config) *DiscardClient {
	return &DiscardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `discard.Hooks(f(g(h())))`.
func (c *DiscardClient) Use(hooks ...Hook) {
	c.hooks.Discard = append(c.hooks.Discard, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `discard.Intercept(f(g(h())))`.
func (c *DiscardClient) Intercept(interceptors ...Interceptor) {
	c.inters.Discard = append(c.inters.Discard, interceptors...)
}

// Create returns a builder for creating a Discard entity.
func (c *DiscardClient) Create() *DiscardCreate {
	mutation := newDiscardMutation(c.config, OpCreate)
	return &DiscardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Discard entities.
func (c *DiscardClient) CreateBulk(builders ...*DiscardCreate) *DiscardCreateBulk {
	return &DiscardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Discard.
func (c *DiscardClient) Update() *DiscardUpdate {
	mutation := newDiscardMutation(c.config, OpUpdate)
	return &DiscardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiscardClient) UpdateOne(d *Discard) *DiscardUpdateOne {
	mutation := newDiscardMutation(c.config, OpUpdateOne, withDiscard(d))
	return &DiscardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiscardClient) UpdateOneID(id uuid.UUID) *DiscardUpdateOne {
	mutation := newDiscardMutation(c.config, OpUpdateOne, withDiscardID(id))
	return &DiscardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Discard.
func (c *DiscardClient) Delete() *DiscardDelete {
	mutation := newDiscardMutation(c.config, OpDelete)
	return &DiscardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiscardClient) DeleteOne(d *Discard) *DiscardDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiscardClient) DeleteOneID(id uuid.UUID) *DiscardDeleteOne {
	builder := c.Delete().Where(discard.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiscardDeleteOne{builder}
}

// Query returns a query builder for Discard.
func (c *DiscardClient) Query() *DiscardQuery {
	return &DiscardQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Discard entity by its id.
func (c *DiscardClient) Get(ctx context.Context, id uuid.UUID) (*Discard, error) {
	return c.Query().Where(discard.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiscardClient) GetX(ctx context.Context, id uuid.UUID) *Discard {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReach queries the reach edge of a Discard.
func (c *DiscardClient) QueryReach(d *Discard) *ReachQuery {
	query := (&ReachClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discard.Table, discard.FieldID, id),
			sqlgraph.To(reach.Table, reach.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, discard.ReachTable, discard.ReachColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCall queries the call edge of a Discard.
func (c *DiscardClient) QueryCall(d *Discard) *CallQuery {
	query := (&CallClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discard.Table, discard.FieldID, id),
			sqlgraph.To(call.Table, call.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, discard.CallTable, discard.CallColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDraw queries the draw edge of a Discard.
func (c *DiscardClient) QueryDraw(d *Discard) *DrawnQuery {
	query := (&DrawnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discard.Table, discard.FieldID, id),
			sqlgraph.To(drawn.Table, drawn.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, discard.DrawTable, discard.DrawColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiscardClient) Hooks() []Hook {
	return c.hooks.Discard
}

// Interceptors returns the client interceptors.
func (c *DiscardClient) Interceptors() []Interceptor {
	return c.inters.Discard
}

func (c *DiscardClient) mutate(ctx context.Context, m *DiscardMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiscardCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiscardUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiscardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiscardDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Discard mutation op: %q", m.Op())
	}
}

// DrawnClient is a client for the Drawn schema.
type DrawnClient struct {
	config
}

// NewDrawnClient returns a client for the Drawn from the given config.
func NewDrawnClient(c config) *DrawnClient {
	return &DrawnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `drawn.Hooks(f(g(h())))`.
func (c *DrawnClient) Use(hooks ...Hook) {
	c.hooks.Drawn = append(c.hooks.Drawn, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `drawn.Intercept(f(g(h())))`.
func (c *DrawnClient) Intercept(interceptors ...Interceptor) {
	c.inters.Drawn = append(c.inters.Drawn, interceptors...)
}

// Create returns a builder for creating a Drawn entity.
func (c *DrawnClient) Create() *DrawnCreate {
	mutation := newDrawnMutation(c.config, OpCreate)
	return &DrawnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Drawn entities.
func (c *DrawnClient) CreateBulk(builders ...*DrawnCreate) *DrawnCreateBulk {
	return &DrawnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Drawn.
func (c *DrawnClient) Update() *DrawnUpdate {
	mutation := newDrawnMutation(c.config, OpUpdate)
	return &DrawnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DrawnClient) UpdateOne(d *Drawn) *DrawnUpdateOne {
	mutation := newDrawnMutation(c.config, OpUpdateOne, withDrawn(d))
	return &DrawnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DrawnClient) UpdateOneID(id uuid.UUID) *DrawnUpdateOne {
	mutation := newDrawnMutation(c.config, OpUpdateOne, withDrawnID(id))
	return &DrawnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Drawn.
func (c *DrawnClient) Delete() *DrawnDelete {
	mutation := newDrawnMutation(c.config, OpDelete)
	return &DrawnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DrawnClient) DeleteOne(d *Drawn) *DrawnDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DrawnClient) DeleteOneID(id uuid.UUID) *DrawnDeleteOne {
	builder := c.Delete().Where(drawn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DrawnDeleteOne{builder}
}

// Query returns a query builder for Drawn.
func (c *DrawnClient) Query() *DrawnQuery {
	return &DrawnQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Drawn entity by its id.
func (c *DrawnClient) Get(ctx context.Context, id uuid.UUID) (*Drawn, error) {
	return c.Query().Where(drawn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DrawnClient) GetX(ctx context.Context, id uuid.UUID) *Drawn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a Drawn.
func (c *DrawnClient) QueryEvent(d *Drawn) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(drawn.Table, drawn.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, drawn.EventTable, drawn.EventColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscard queries the discard edge of a Drawn.
func (c *DrawnClient) QueryDiscard(d *Drawn) *DiscardQuery {
	query := (&DiscardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(drawn.Table, drawn.FieldID, id),
			sqlgraph.To(discard.Table, discard.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, drawn.DiscardTable, drawn.DiscardColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DrawnClient) Hooks() []Hook {
	return c.hooks.Drawn
}

// Interceptors returns the client interceptors.
func (c *DrawnClient) Interceptors() []Interceptor {
	return c.inters.Drawn
}

func (c *DrawnClient) mutate(ctx context.Context, m *DrawnMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DrawnCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DrawnUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DrawnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DrawnDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Drawn mutation op: %q", m.Op())
	}
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `event.Intercept(f(g(h())))`.
func (c *EventClient) Intercept(interceptors ...Interceptor) {
	c.inters.Event = append(c.inters.Event, interceptors...)
}

// Create returns a builder for creating a Event entity.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id uuid.UUID) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventClient) DeleteOneID(id uuid.UUID) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id uuid.UUID) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id uuid.UUID) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTurn queries the turn edge of a Event.
func (c *EventClient) QueryTurn(e *Event) *TurnQuery {
	query := (&TurnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(turn.Table, turn.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, event.TurnTable, event.TurnColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWin queries the win edge of a Event.
func (c *EventClient) QueryWin(e *Event) *WinQuery {
	query := (&WinClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(win.Table, win.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.WinTable, event.WinColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCall queries the call edge of a Event.
func (c *EventClient) QueryCall(e *Event) *CallQuery {
	query := (&CallClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(call.Table, call.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.CallTable, event.CallColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDraw queries the draw edge of a Event.
func (c *EventClient) QueryDraw(e *Event) *DrawnQuery {
	query := (&DrawnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(drawn.Table, drawn.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.DrawTable, event.DrawColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReach queries the reach edge of a Event.
func (c *EventClient) QueryReach(e *Event) *ReachQuery {
	query := (&ReachClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(reach.Table, reach.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.ReachTable, event.ReachColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// Interceptors returns the client interceptors.
func (c *EventClient) Interceptors() []Interceptor {
	return c.inters.Event
}

func (c *EventClient) mutate(ctx context.Context, m *EventMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Event mutation op: %q", m.Op())
	}
}

// GameClient is a client for the Game schema.
type GameClient struct {
	config
}

// NewGameClient returns a client for the Game from the given config.
func NewGameClient(c config) *GameClient {
	return &GameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `game.Hooks(f(g(h())))`.
func (c *GameClient) Use(hooks ...Hook) {
	c.hooks.Game = append(c.hooks.Game, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `game.Intercept(f(g(h())))`.
func (c *GameClient) Intercept(interceptors ...Interceptor) {
	c.inters.Game = append(c.inters.Game, interceptors...)
}

// Create returns a builder for creating a Game entity.
func (c *GameClient) Create() *GameCreate {
	mutation := newGameMutation(c.config, OpCreate)
	return &GameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Game entities.
func (c *GameClient) CreateBulk(builders ...*GameCreate) *GameCreateBulk {
	return &GameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Game.
func (c *GameClient) Update() *GameUpdate {
	mutation := newGameMutation(c.config, OpUpdate)
	return &GameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameClient) UpdateOne(ga *Game) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGame(ga))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameClient) UpdateOneID(id uuid.UUID) *GameUpdateOne {
	mutation := newGameMutation(c.config, OpUpdateOne, withGameID(id))
	return &GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Game.
func (c *GameClient) Delete() *GameDelete {
	mutation := newGameMutation(c.config, OpDelete)
	return &GameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameClient) DeleteOne(ga *Game) *GameDeleteOne {
	return c.DeleteOneID(ga.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameClient) DeleteOneID(id uuid.UUID) *GameDeleteOne {
	builder := c.Delete().Where(game.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameDeleteOne{builder}
}

// Query returns a query builder for Game.
func (c *GameClient) Query() *GameQuery {
	return &GameQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Game entity by its id.
func (c *GameClient) Get(ctx context.Context, id uuid.UUID) (*Game, error) {
	return c.Query().Where(game.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameClient) GetX(ctx context.Context, id uuid.UUID) *Game {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogs queries the mjlogs edge of a Game.
func (c *GameClient) QueryMjlogs(ga *Game) *MJLogQuery {
	query := (&MJLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(mjlog.Table, mjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, game.MjlogsTable, game.MjlogsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGamePlayers queries the game_players edge of a Game.
func (c *GameClient) QueryGamePlayers(ga *Game) *GamePlayerQuery {
	query := (&GamePlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, game.GamePlayersTable, game.GamePlayersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRooms queries the rooms edge of a Game.
func (c *GameClient) QueryRooms(ga *Game) *RoomQuery {
	query := (&RoomClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(room.Table, room.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, game.RoomsTable, game.RoomsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRounds queries the rounds edge of a Game.
func (c *GameClient) QueryRounds(ga *Game) *RoundQuery {
	query := (&RoundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ga.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(game.Table, game.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, game.RoundsTable, game.RoundsColumn),
		)
		fromV = sqlgraph.Neighbors(ga.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GameClient) Hooks() []Hook {
	return c.hooks.Game
}

// Interceptors returns the client interceptors.
func (c *GameClient) Interceptors() []Interceptor {
	return c.inters.Game
}

func (c *GameClient) mutate(ctx context.Context, m *GameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Game mutation op: %q", m.Op())
	}
}

// GamePlayerClient is a client for the GamePlayer schema.
type GamePlayerClient struct {
	config
}

// NewGamePlayerClient returns a client for the GamePlayer from the given config.
func NewGamePlayerClient(c config) *GamePlayerClient {
	return &GamePlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayer.Hooks(f(g(h())))`.
func (c *GamePlayerClient) Use(hooks ...Hook) {
	c.hooks.GamePlayer = append(c.hooks.GamePlayer, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gameplayer.Intercept(f(g(h())))`.
func (c *GamePlayerClient) Intercept(interceptors ...Interceptor) {
	c.inters.GamePlayer = append(c.inters.GamePlayer, interceptors...)
}

// Create returns a builder for creating a GamePlayer entity.
func (c *GamePlayerClient) Create() *GamePlayerCreate {
	mutation := newGamePlayerMutation(c.config, OpCreate)
	return &GamePlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayer entities.
func (c *GamePlayerClient) CreateBulk(builders ...*GamePlayerCreate) *GamePlayerCreateBulk {
	return &GamePlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayer.
func (c *GamePlayerClient) Update() *GamePlayerUpdate {
	mutation := newGamePlayerMutation(c.config, OpUpdate)
	return &GamePlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerClient) UpdateOne(gp *GamePlayer) *GamePlayerUpdateOne {
	mutation := newGamePlayerMutation(c.config, OpUpdateOne, withGamePlayer(gp))
	return &GamePlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerClient) UpdateOneID(id uuid.UUID) *GamePlayerUpdateOne {
	mutation := newGamePlayerMutation(c.config, OpUpdateOne, withGamePlayerID(id))
	return &GamePlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayer.
func (c *GamePlayerClient) Delete() *GamePlayerDelete {
	mutation := newGamePlayerMutation(c.config, OpDelete)
	return &GamePlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerClient) DeleteOne(gp *GamePlayer) *GamePlayerDeleteOne {
	return c.DeleteOneID(gp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerClient) DeleteOneID(id uuid.UUID) *GamePlayerDeleteOne {
	builder := c.Delete().Where(gameplayer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerDeleteOne{builder}
}

// Query returns a query builder for GamePlayer.
func (c *GamePlayerClient) Query() *GamePlayerQuery {
	return &GamePlayerQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a GamePlayer entity by its id.
func (c *GamePlayerClient) Get(ctx context.Context, id uuid.UUID) (*GamePlayer, error) {
	return c.Query().Where(gameplayer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerClient) GetX(ctx context.Context, id uuid.UUID) *GamePlayer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a GamePlayer.
func (c *GamePlayerClient) QueryGames(gp *GamePlayer) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, gameplayer.GamesTable, gameplayer.GamesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPlayers queries the players edge of a GamePlayer.
func (c *GamePlayerClient) QueryPlayers(gp *GamePlayer) *PlayerQuery {
	query := (&PlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(player.Table, player.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameplayer.PlayersTable, gameplayer.PlayersColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDans queries the dans edge of a GamePlayer.
func (c *GamePlayerClient) QueryDans(gp *GamePlayer) *DanQuery {
	query := (&DanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayer.Table, gameplayer.FieldID, id),
			sqlgraph.To(dan.Table, dan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, gameplayer.DansTable, gameplayer.DansColumn),
		)
		fromV = sqlgraph.Neighbors(gp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GamePlayerClient) Hooks() []Hook {
	return c.hooks.GamePlayer
}

// Interceptors returns the client interceptors.
func (c *GamePlayerClient) Interceptors() []Interceptor {
	return c.inters.GamePlayer
}

func (c *GamePlayerClient) mutate(ctx context.Context, m *GamePlayerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GamePlayerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GamePlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GamePlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GamePlayerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GamePlayer mutation op: %q", m.Op())
	}
}

// GamePlayerHandHaiClient is a client for the GamePlayerHandHai schema.
type GamePlayerHandHaiClient struct {
	config
}

// NewGamePlayerHandHaiClient returns a client for the GamePlayerHandHai from the given config.
func NewGamePlayerHandHaiClient(c config) *GamePlayerHandHaiClient {
	return &GamePlayerHandHaiClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayerhandhai.Hooks(f(g(h())))`.
func (c *GamePlayerHandHaiClient) Use(hooks ...Hook) {
	c.hooks.GamePlayerHandHai = append(c.hooks.GamePlayerHandHai, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gameplayerhandhai.Intercept(f(g(h())))`.
func (c *GamePlayerHandHaiClient) Intercept(interceptors ...Interceptor) {
	c.inters.GamePlayerHandHai = append(c.inters.GamePlayerHandHai, interceptors...)
}

// Create returns a builder for creating a GamePlayerHandHai entity.
func (c *GamePlayerHandHaiClient) Create() *GamePlayerHandHaiCreate {
	mutation := newGamePlayerHandHaiMutation(c.config, OpCreate)
	return &GamePlayerHandHaiCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayerHandHai entities.
func (c *GamePlayerHandHaiClient) CreateBulk(builders ...*GamePlayerHandHaiCreate) *GamePlayerHandHaiCreateBulk {
	return &GamePlayerHandHaiCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Update() *GamePlayerHandHaiUpdate {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdate)
	return &GamePlayerHandHaiUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerHandHaiClient) UpdateOne(gphh *GamePlayerHandHai) *GamePlayerHandHaiUpdateOne {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdateOne, withGamePlayerHandHai(gphh))
	return &GamePlayerHandHaiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerHandHaiClient) UpdateOneID(id uuid.UUID) *GamePlayerHandHaiUpdateOne {
	mutation := newGamePlayerHandHaiMutation(c.config, OpUpdateOne, withGamePlayerHandHaiID(id))
	return &GamePlayerHandHaiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Delete() *GamePlayerHandHaiDelete {
	mutation := newGamePlayerHandHaiMutation(c.config, OpDelete)
	return &GamePlayerHandHaiDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerHandHaiClient) DeleteOne(gphh *GamePlayerHandHai) *GamePlayerHandHaiDeleteOne {
	return c.DeleteOneID(gphh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerHandHaiClient) DeleteOneID(id uuid.UUID) *GamePlayerHandHaiDeleteOne {
	builder := c.Delete().Where(gameplayerhandhai.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerHandHaiDeleteOne{builder}
}

// Query returns a query builder for GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) Query() *GamePlayerHandHaiQuery {
	return &GamePlayerHandHaiQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a GamePlayerHandHai entity by its id.
func (c *GamePlayerHandHaiClient) Get(ctx context.Context, id uuid.UUID) (*GamePlayerHandHai, error) {
	return c.Query().Where(gameplayerhandhai.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerHandHaiClient) GetX(ctx context.Context, id uuid.UUID) *GamePlayerHandHai {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTurn queries the turn edge of a GamePlayerHandHai.
func (c *GamePlayerHandHaiClient) QueryTurn(gphh *GamePlayerHandHai) *TurnQuery {
	query := (&TurnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gphh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayerhandhai.Table, gameplayerhandhai.FieldID, id),
			sqlgraph.To(turn.Table, turn.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, gameplayerhandhai.TurnTable, gameplayerhandhai.TurnColumn),
		)
		fromV = sqlgraph.Neighbors(gphh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GamePlayerHandHaiClient) Hooks() []Hook {
	return c.hooks.GamePlayerHandHai
}

// Interceptors returns the client interceptors.
func (c *GamePlayerHandHaiClient) Interceptors() []Interceptor {
	return c.inters.GamePlayerHandHai
}

func (c *GamePlayerHandHaiClient) mutate(ctx context.Context, m *GamePlayerHandHaiMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GamePlayerHandHaiCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GamePlayerHandHaiUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GamePlayerHandHaiUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GamePlayerHandHaiDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GamePlayerHandHai mutation op: %q", m.Op())
	}
}

// GamePlayerPointClient is a client for the GamePlayerPoint schema.
type GamePlayerPointClient struct {
	config
}

// NewGamePlayerPointClient returns a client for the GamePlayerPoint from the given config.
func NewGamePlayerPointClient(c config) *GamePlayerPointClient {
	return &GamePlayerPointClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gameplayerpoint.Hooks(f(g(h())))`.
func (c *GamePlayerPointClient) Use(hooks ...Hook) {
	c.hooks.GamePlayerPoint = append(c.hooks.GamePlayerPoint, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gameplayerpoint.Intercept(f(g(h())))`.
func (c *GamePlayerPointClient) Intercept(interceptors ...Interceptor) {
	c.inters.GamePlayerPoint = append(c.inters.GamePlayerPoint, interceptors...)
}

// Create returns a builder for creating a GamePlayerPoint entity.
func (c *GamePlayerPointClient) Create() *GamePlayerPointCreate {
	mutation := newGamePlayerPointMutation(c.config, OpCreate)
	return &GamePlayerPointCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GamePlayerPoint entities.
func (c *GamePlayerPointClient) CreateBulk(builders ...*GamePlayerPointCreate) *GamePlayerPointCreateBulk {
	return &GamePlayerPointCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Update() *GamePlayerPointUpdate {
	mutation := newGamePlayerPointMutation(c.config, OpUpdate)
	return &GamePlayerPointUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GamePlayerPointClient) UpdateOne(gpp *GamePlayerPoint) *GamePlayerPointUpdateOne {
	mutation := newGamePlayerPointMutation(c.config, OpUpdateOne, withGamePlayerPoint(gpp))
	return &GamePlayerPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GamePlayerPointClient) UpdateOneID(id uuid.UUID) *GamePlayerPointUpdateOne {
	mutation := newGamePlayerPointMutation(c.config, OpUpdateOne, withGamePlayerPointID(id))
	return &GamePlayerPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Delete() *GamePlayerPointDelete {
	mutation := newGamePlayerPointMutation(c.config, OpDelete)
	return &GamePlayerPointDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GamePlayerPointClient) DeleteOne(gpp *GamePlayerPoint) *GamePlayerPointDeleteOne {
	return c.DeleteOneID(gpp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GamePlayerPointClient) DeleteOneID(id uuid.UUID) *GamePlayerPointDeleteOne {
	builder := c.Delete().Where(gameplayerpoint.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GamePlayerPointDeleteOne{builder}
}

// Query returns a query builder for GamePlayerPoint.
func (c *GamePlayerPointClient) Query() *GamePlayerPointQuery {
	return &GamePlayerPointQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a GamePlayerPoint entity by its id.
func (c *GamePlayerPointClient) Get(ctx context.Context, id uuid.UUID) (*GamePlayerPoint, error) {
	return c.Query().Where(gameplayerpoint.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GamePlayerPointClient) GetX(ctx context.Context, id uuid.UUID) *GamePlayerPoint {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTurns queries the turns edge of a GamePlayerPoint.
func (c *GamePlayerPointClient) QueryTurns(gpp *GamePlayerPoint) *TurnQuery {
	query := (&TurnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := gpp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(gameplayerpoint.Table, gameplayerpoint.FieldID, id),
			sqlgraph.To(turn.Table, turn.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, gameplayerpoint.TurnsTable, gameplayerpoint.TurnsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(gpp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *GamePlayerPointClient) Hooks() []Hook {
	return c.hooks.GamePlayerPoint
}

// Interceptors returns the client interceptors.
func (c *GamePlayerPointClient) Interceptors() []Interceptor {
	return c.inters.GamePlayerPoint
}

func (c *GamePlayerPointClient) mutate(ctx context.Context, m *GamePlayerPointMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GamePlayerPointCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GamePlayerPointUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GamePlayerPointUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GamePlayerPointDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown GamePlayerPoint mutation op: %q", m.Op())
	}
}

// HandClient is a client for the Hand schema.
type HandClient struct {
	config
}

// NewHandClient returns a client for the Hand from the given config.
func NewHandClient(c config) *HandClient {
	return &HandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hand.Hooks(f(g(h())))`.
func (c *HandClient) Use(hooks ...Hook) {
	c.hooks.Hand = append(c.hooks.Hand, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `hand.Intercept(f(g(h())))`.
func (c *HandClient) Intercept(interceptors ...Interceptor) {
	c.inters.Hand = append(c.inters.Hand, interceptors...)
}

// Create returns a builder for creating a Hand entity.
func (c *HandClient) Create() *HandCreate {
	mutation := newHandMutation(c.config, OpCreate)
	return &HandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hand entities.
func (c *HandClient) CreateBulk(builders ...*HandCreate) *HandCreateBulk {
	return &HandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hand.
func (c *HandClient) Update() *HandUpdate {
	mutation := newHandMutation(c.config, OpUpdate)
	return &HandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HandClient) UpdateOne(h *Hand) *HandUpdateOne {
	mutation := newHandMutation(c.config, OpUpdateOne, withHand(h))
	return &HandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HandClient) UpdateOneID(id uuid.UUID) *HandUpdateOne {
	mutation := newHandMutation(c.config, OpUpdateOne, withHandID(id))
	return &HandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hand.
func (c *HandClient) Delete() *HandDelete {
	mutation := newHandMutation(c.config, OpDelete)
	return &HandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HandClient) DeleteOne(h *Hand) *HandDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HandClient) DeleteOneID(id uuid.UUID) *HandDeleteOne {
	builder := c.Delete().Where(hand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HandDeleteOne{builder}
}

// Query returns a query builder for Hand.
func (c *HandClient) Query() *HandQuery {
	return &HandQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Hand entity by its id.
func (c *HandClient) Get(ctx context.Context, id uuid.UUID) (*Hand, error) {
	return c.Query().Where(hand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HandClient) GetX(ctx context.Context, id uuid.UUID) *Hand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRounds queries the rounds edge of a Hand.
func (c *HandClient) QueryRounds(h *Hand) *RoundQuery {
	query := (&RoundClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hand.Table, hand.FieldID, id),
			sqlgraph.To(round.Table, round.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hand.RoundsTable, hand.RoundsColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTurns queries the turns edge of a Hand.
func (c *HandClient) QueryTurns(h *Hand) *TurnQuery {
	query := (&TurnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hand.Table, hand.FieldID, id),
			sqlgraph.To(turn.Table, turn.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, hand.TurnsTable, hand.TurnsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HandClient) Hooks() []Hook {
	return c.hooks.Hand
}

// Interceptors returns the client interceptors.
func (c *HandClient) Interceptors() []Interceptor {
	return c.inters.Hand
}

func (c *HandClient) mutate(ctx context.Context, m *HandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&HandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&HandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&HandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&HandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Hand mutation op: %q", m.Op())
	}
}

// MJLogClient is a client for the MJLog schema.
type MJLogClient struct {
	config
}

// NewMJLogClient returns a client for the MJLog from the given config.
func NewMJLogClient(c config) *MJLogClient {
	return &MJLogClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mjlog.Hooks(f(g(h())))`.
func (c *MJLogClient) Use(hooks ...Hook) {
	c.hooks.MJLog = append(c.hooks.MJLog, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mjlog.Intercept(f(g(h())))`.
func (c *MJLogClient) Intercept(interceptors ...Interceptor) {
	c.inters.MJLog = append(c.inters.MJLog, interceptors...)
}

// Create returns a builder for creating a MJLog entity.
func (c *MJLogClient) Create() *MJLogCreate {
	mutation := newMJLogMutation(c.config, OpCreate)
	return &MJLogCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MJLog entities.
func (c *MJLogClient) CreateBulk(builders ...*MJLogCreate) *MJLogCreateBulk {
	return &MJLogCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MJLog.
func (c *MJLogClient) Update() *MJLogUpdate {
	mutation := newMJLogMutation(c.config, OpUpdate)
	return &MJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MJLogClient) UpdateOne(ml *MJLog) *MJLogUpdateOne {
	mutation := newMJLogMutation(c.config, OpUpdateOne, withMJLog(ml))
	return &MJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MJLogClient) UpdateOneID(id uuid.UUID) *MJLogUpdateOne {
	mutation := newMJLogMutation(c.config, OpUpdateOne, withMJLogID(id))
	return &MJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MJLog.
func (c *MJLogClient) Delete() *MJLogDelete {
	mutation := newMJLogMutation(c.config, OpDelete)
	return &MJLogDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MJLogClient) DeleteOne(ml *MJLog) *MJLogDeleteOne {
	return c.DeleteOneID(ml.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MJLogClient) DeleteOneID(id uuid.UUID) *MJLogDeleteOne {
	builder := c.Delete().Where(mjlog.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MJLogDeleteOne{builder}
}

// Query returns a query builder for MJLog.
func (c *MJLogClient) Query() *MJLogQuery {
	return &MJLogQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a MJLog entity by its id.
func (c *MJLogClient) Get(ctx context.Context, id uuid.UUID) (*MJLog, error) {
	return c.Query().Where(mjlog.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MJLogClient) GetX(ctx context.Context, id uuid.UUID) *MJLog {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryMjlogFiles queries the mjlog_files edge of a MJLog.
func (c *MJLogClient) QueryMjlogFiles(ml *MJLog) *MJLogFileQuery {
	query := (&MJLogFileClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlog.Table, mjlog.FieldID, id),
			sqlgraph.To(mjlogfile.Table, mjlogfile.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlog.MjlogFilesTable, mjlog.MjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGames queries the games edge of a MJLog.
func (c *MJLogClient) QueryGames(ml *MJLog) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ml.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlog.Table, mjlog.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlog.GamesTable, mjlog.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(ml.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MJLogClient) Hooks() []Hook {
	return c.hooks.MJLog
}

// Interceptors returns the client interceptors.
func (c *MJLogClient) Interceptors() []Interceptor {
	return c.inters.MJLog
}

func (c *MJLogClient) mutate(ctx context.Context, m *MJLogMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MJLogCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MJLogUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MJLogUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MJLogDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MJLog mutation op: %q", m.Op())
	}
}

// MJLogFileClient is a client for the MJLogFile schema.
type MJLogFileClient struct {
	config
}

// NewMJLogFileClient returns a client for the MJLogFile from the given config.
func NewMJLogFileClient(c config) *MJLogFileClient {
	return &MJLogFileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mjlogfile.Hooks(f(g(h())))`.
func (c *MJLogFileClient) Use(hooks ...Hook) {
	c.hooks.MJLogFile = append(c.hooks.MJLogFile, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mjlogfile.Intercept(f(g(h())))`.
func (c *MJLogFileClient) Intercept(interceptors ...Interceptor) {
	c.inters.MJLogFile = append(c.inters.MJLogFile, interceptors...)
}

// Create returns a builder for creating a MJLogFile entity.
func (c *MJLogFileClient) Create() *MJLogFileCreate {
	mutation := newMJLogFileMutation(c.config, OpCreate)
	return &MJLogFileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MJLogFile entities.
func (c *MJLogFileClient) CreateBulk(builders ...*MJLogFileCreate) *MJLogFileCreateBulk {
	return &MJLogFileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MJLogFile.
func (c *MJLogFileClient) Update() *MJLogFileUpdate {
	mutation := newMJLogFileMutation(c.config, OpUpdate)
	return &MJLogFileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MJLogFileClient) UpdateOne(mlf *MJLogFile) *MJLogFileUpdateOne {
	mutation := newMJLogFileMutation(c.config, OpUpdateOne, withMJLogFile(mlf))
	return &MJLogFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MJLogFileClient) UpdateOneID(id uuid.UUID) *MJLogFileUpdateOne {
	mutation := newMJLogFileMutation(c.config, OpUpdateOne, withMJLogFileID(id))
	return &MJLogFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MJLogFile.
func (c *MJLogFileClient) Delete() *MJLogFileDelete {
	mutation := newMJLogFileMutation(c.config, OpDelete)
	return &MJLogFileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MJLogFileClient) DeleteOne(mlf *MJLogFile) *MJLogFileDeleteOne {
	return c.DeleteOneID(mlf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MJLogFileClient) DeleteOneID(id uuid.UUID) *MJLogFileDeleteOne {
	builder := c.Delete().Where(mjlogfile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MJLogFileDeleteOne{builder}
}

// Query returns a query builder for MJLogFile.
func (c *MJLogFileClient) Query() *MJLogFileQuery {
	return &MJLogFileQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a MJLogFile entity by its id.
func (c *MJLogFileClient) Get(ctx context.Context, id uuid.UUID) (*MJLogFile, error) {
	return c.Query().Where(mjlogfile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MJLogFileClient) GetX(ctx context.Context, id uuid.UUID) *MJLogFile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCompressedMjlogFiles queries the compressed_mjlog_files edge of a MJLogFile.
func (c *MJLogFileClient) QueryCompressedMjlogFiles(mlf *MJLogFile) *CompressedMJLogQuery {
	query := (&CompressedMJLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mlf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlogfile.Table, mjlogfile.FieldID, id),
			sqlgraph.To(compressedmjlog.Table, compressedmjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, mjlogfile.CompressedMjlogFilesTable, mjlogfile.CompressedMjlogFilesColumn),
		)
		fromV = sqlgraph.Neighbors(mlf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMjlogs queries the mjlogs edge of a MJLogFile.
func (c *MJLogFileClient) QueryMjlogs(mlf *MJLogFile) *MJLogQuery {
	query := (&MJLogClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mlf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mjlogfile.Table, mjlogfile.FieldID, id),
			sqlgraph.To(mjlog.Table, mjlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, mjlogfile.MjlogsTable, mjlogfile.MjlogsColumn),
		)
		fromV = sqlgraph.Neighbors(mlf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MJLogFileClient) Hooks() []Hook {
	return c.hooks.MJLogFile
}

// Interceptors returns the client interceptors.
func (c *MJLogFileClient) Interceptors() []Interceptor {
	return c.inters.MJLogFile
}

func (c *MJLogFileClient) mutate(ctx context.Context, m *MJLogFileMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MJLogFileCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MJLogFileUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MJLogFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MJLogFileDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MJLogFile mutation op: %q", m.Op())
	}
}

// MeldedKanClient is a client for the MeldedKan schema.
type MeldedKanClient struct {
	config
}

// NewMeldedKanClient returns a client for the MeldedKan from the given config.
func NewMeldedKanClient(c config) *MeldedKanClient {
	return &MeldedKanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `meldedkan.Hooks(f(g(h())))`.
func (c *MeldedKanClient) Use(hooks ...Hook) {
	c.hooks.MeldedKan = append(c.hooks.MeldedKan, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `meldedkan.Intercept(f(g(h())))`.
func (c *MeldedKanClient) Intercept(interceptors ...Interceptor) {
	c.inters.MeldedKan = append(c.inters.MeldedKan, interceptors...)
}

// Create returns a builder for creating a MeldedKan entity.
func (c *MeldedKanClient) Create() *MeldedKanCreate {
	mutation := newMeldedKanMutation(c.config, OpCreate)
	return &MeldedKanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MeldedKan entities.
func (c *MeldedKanClient) CreateBulk(builders ...*MeldedKanCreate) *MeldedKanCreateBulk {
	return &MeldedKanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MeldedKan.
func (c *MeldedKanClient) Update() *MeldedKanUpdate {
	mutation := newMeldedKanMutation(c.config, OpUpdate)
	return &MeldedKanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MeldedKanClient) UpdateOne(mk *MeldedKan) *MeldedKanUpdateOne {
	mutation := newMeldedKanMutation(c.config, OpUpdateOne, withMeldedKan(mk))
	return &MeldedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MeldedKanClient) UpdateOneID(id uuid.UUID) *MeldedKanUpdateOne {
	mutation := newMeldedKanMutation(c.config, OpUpdateOne, withMeldedKanID(id))
	return &MeldedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MeldedKan.
func (c *MeldedKanClient) Delete() *MeldedKanDelete {
	mutation := newMeldedKanMutation(c.config, OpDelete)
	return &MeldedKanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MeldedKanClient) DeleteOne(mk *MeldedKan) *MeldedKanDeleteOne {
	return c.DeleteOneID(mk.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MeldedKanClient) DeleteOneID(id uuid.UUID) *MeldedKanDeleteOne {
	builder := c.Delete().Where(meldedkan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MeldedKanDeleteOne{builder}
}

// Query returns a query builder for MeldedKan.
func (c *MeldedKanClient) Query() *MeldedKanQuery {
	return &MeldedKanQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a MeldedKan entity by its id.
func (c *MeldedKanClient) Get(ctx context.Context, id uuid.UUID) (*MeldedKan, error) {
	return c.Query().Where(meldedkan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MeldedKanClient) GetX(ctx context.Context, id uuid.UUID) *MeldedKan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCall queries the call edge of a MeldedKan.
func (c *MeldedKanClient) QueryCall(mk *MeldedKan) *CallQuery {
	query := (&CallClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := mk.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(meldedkan.Table, meldedkan.FieldID, id),
			sqlgraph.To(call.Table, call.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, meldedkan.CallTable, meldedkan.CallColumn),
		)
		fromV = sqlgraph.Neighbors(mk.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MeldedKanClient) Hooks() []Hook {
	return c.hooks.MeldedKan
}

// Interceptors returns the client interceptors.
func (c *MeldedKanClient) Interceptors() []Interceptor {
	return c.inters.MeldedKan
}

func (c *MeldedKanClient) mutate(ctx context.Context, m *MeldedKanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MeldedKanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MeldedKanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MeldedKanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MeldedKanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MeldedKan mutation op: %q", m.Op())
	}
}

// PlayerClient is a client for the Player schema.
type PlayerClient struct {
	config
}

// NewPlayerClient returns a client for the Player from the given config.
func NewPlayerClient(c config) *PlayerClient {
	return &PlayerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `player.Hooks(f(g(h())))`.
func (c *PlayerClient) Use(hooks ...Hook) {
	c.hooks.Player = append(c.hooks.Player, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `player.Intercept(f(g(h())))`.
func (c *PlayerClient) Intercept(interceptors ...Interceptor) {
	c.inters.Player = append(c.inters.Player, interceptors...)
}

// Create returns a builder for creating a Player entity.
func (c *PlayerClient) Create() *PlayerCreate {
	mutation := newPlayerMutation(c.config, OpCreate)
	return &PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Player entities.
func (c *PlayerClient) CreateBulk(builders ...*PlayerCreate) *PlayerCreateBulk {
	return &PlayerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Player.
func (c *PlayerClient) Update() *PlayerUpdate {
	mutation := newPlayerMutation(c.config, OpUpdate)
	return &PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlayerClient) UpdateOne(pl *Player) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayer(pl))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlayerClient) UpdateOneID(id uuid.UUID) *PlayerUpdateOne {
	mutation := newPlayerMutation(c.config, OpUpdateOne, withPlayerID(id))
	return &PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Player.
func (c *PlayerClient) Delete() *PlayerDelete {
	mutation := newPlayerMutation(c.config, OpDelete)
	return &PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlayerClient) DeleteOne(pl *Player) *PlayerDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlayerClient) DeleteOneID(id uuid.UUID) *PlayerDeleteOne {
	builder := c.Delete().Where(player.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlayerDeleteOne{builder}
}

// Query returns a query builder for Player.
func (c *PlayerClient) Query() *PlayerQuery {
	return &PlayerQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Player entity by its id.
func (c *PlayerClient) Get(ctx context.Context, id uuid.UUID) (*Player, error) {
	return c.Query().Where(player.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlayerClient) GetX(ctx context.Context, id uuid.UUID) *Player {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGamePlayers queries the game_players edge of a Player.
func (c *PlayerClient) QueryGamePlayers(pl *Player) *GamePlayerQuery {
	query := (&GamePlayerClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(player.Table, player.FieldID, id),
			sqlgraph.To(gameplayer.Table, gameplayer.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, player.GamePlayersTable, player.GamePlayersColumn),
		)
		fromV = sqlgraph.Neighbors(pl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PlayerClient) Hooks() []Hook {
	return c.hooks.Player
}

// Interceptors returns the client interceptors.
func (c *PlayerClient) Interceptors() []Interceptor {
	return c.inters.Player
}

func (c *PlayerClient) mutate(ctx context.Context, m *PlayerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlayerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlayerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlayerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlayerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Player mutation op: %q", m.Op())
	}
}

// PonClient is a client for the Pon schema.
type PonClient struct {
	config
}

// NewPonClient returns a client for the Pon from the given config.
func NewPonClient(c config) *PonClient {
	return &PonClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `pon.Hooks(f(g(h())))`.
func (c *PonClient) Use(hooks ...Hook) {
	c.hooks.Pon = append(c.hooks.Pon, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `pon.Intercept(f(g(h())))`.
func (c *PonClient) Intercept(interceptors ...Interceptor) {
	c.inters.Pon = append(c.inters.Pon, interceptors...)
}

// Create returns a builder for creating a Pon entity.
func (c *PonClient) Create() *PonCreate {
	mutation := newPonMutation(c.config, OpCreate)
	return &PonCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Pon entities.
func (c *PonClient) CreateBulk(builders ...*PonCreate) *PonCreateBulk {
	return &PonCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Pon.
func (c *PonClient) Update() *PonUpdate {
	mutation := newPonMutation(c.config, OpUpdate)
	return &PonUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PonClient) UpdateOne(po *Pon) *PonUpdateOne {
	mutation := newPonMutation(c.config, OpUpdateOne, withPon(po))
	return &PonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PonClient) UpdateOneID(id uuid.UUID) *PonUpdateOne {
	mutation := newPonMutation(c.config, OpUpdateOne, withPonID(id))
	return &PonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Pon.
func (c *PonClient) Delete() *PonDelete {
	mutation := newPonMutation(c.config, OpDelete)
	return &PonDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PonClient) DeleteOne(po *Pon) *PonDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PonClient) DeleteOneID(id uuid.UUID) *PonDeleteOne {
	builder := c.Delete().Where(pon.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PonDeleteOne{builder}
}

// Query returns a query builder for Pon.
func (c *PonClient) Query() *PonQuery {
	return &PonQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Pon entity by its id.
func (c *PonClient) Get(ctx context.Context, id uuid.UUID) (*Pon, error) {
	return c.Query().Where(pon.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PonClient) GetX(ctx context.Context, id uuid.UUID) *Pon {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCall queries the call edge of a Pon.
func (c *PonClient) QueryCall(po *Pon) *CallQuery {
	query := (&CallClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(pon.Table, pon.FieldID, id),
			sqlgraph.To(call.Table, call.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, pon.CallTable, pon.CallColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PonClient) Hooks() []Hook {
	return c.hooks.Pon
}

// Interceptors returns the client interceptors.
func (c *PonClient) Interceptors() []Interceptor {
	return c.inters.Pon
}

func (c *PonClient) mutate(ctx context.Context, m *PonMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PonCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PonUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PonUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PonDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Pon mutation op: %q", m.Op())
	}
}

// ReachClient is a client for the Reach schema.
type ReachClient struct {
	config
}

// NewReachClient returns a client for the Reach from the given config.
func NewReachClient(c config) *ReachClient {
	return &ReachClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reach.Hooks(f(g(h())))`.
func (c *ReachClient) Use(hooks ...Hook) {
	c.hooks.Reach = append(c.hooks.Reach, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `reach.Intercept(f(g(h())))`.
func (c *ReachClient) Intercept(interceptors ...Interceptor) {
	c.inters.Reach = append(c.inters.Reach, interceptors...)
}

// Create returns a builder for creating a Reach entity.
func (c *ReachClient) Create() *ReachCreate {
	mutation := newReachMutation(c.config, OpCreate)
	return &ReachCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reach entities.
func (c *ReachClient) CreateBulk(builders ...*ReachCreate) *ReachCreateBulk {
	return &ReachCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reach.
func (c *ReachClient) Update() *ReachUpdate {
	mutation := newReachMutation(c.config, OpUpdate)
	return &ReachUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReachClient) UpdateOne(r *Reach) *ReachUpdateOne {
	mutation := newReachMutation(c.config, OpUpdateOne, withReach(r))
	return &ReachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReachClient) UpdateOneID(id uuid.UUID) *ReachUpdateOne {
	mutation := newReachMutation(c.config, OpUpdateOne, withReachID(id))
	return &ReachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reach.
func (c *ReachClient) Delete() *ReachDelete {
	mutation := newReachMutation(c.config, OpDelete)
	return &ReachDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReachClient) DeleteOne(r *Reach) *ReachDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReachClient) DeleteOneID(id uuid.UUID) *ReachDeleteOne {
	builder := c.Delete().Where(reach.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReachDeleteOne{builder}
}

// Query returns a query builder for Reach.
func (c *ReachClient) Query() *ReachQuery {
	return &ReachQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Reach entity by its id.
func (c *ReachClient) Get(ctx context.Context, id uuid.UUID) (*Reach, error) {
	return c.Query().Where(reach.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReachClient) GetX(ctx context.Context, id uuid.UUID) *Reach {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a Reach.
func (c *ReachClient) QueryEvent(r *Reach) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reach.Table, reach.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reach.EventTable, reach.EventColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDiscard queries the discard edge of a Reach.
func (c *ReachClient) QueryDiscard(r *Reach) *DiscardQuery {
	query := (&DiscardClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reach.Table, reach.FieldID, id),
			sqlgraph.To(discard.Table, discard.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, reach.DiscardTable, reach.DiscardColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReachClient) Hooks() []Hook {
	return c.hooks.Reach
}

// Interceptors returns the client interceptors.
func (c *ReachClient) Interceptors() []Interceptor {
	return c.inters.Reach
}

func (c *ReachClient) mutate(ctx context.Context, m *ReachMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ReachCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ReachUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ReachUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ReachDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Reach mutation op: %q", m.Op())
	}
}

// RoomClient is a client for the Room schema.
type RoomClient struct {
	config
}

// NewRoomClient returns a client for the Room from the given config.
func NewRoomClient(c config) *RoomClient {
	return &RoomClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `room.Hooks(f(g(h())))`.
func (c *RoomClient) Use(hooks ...Hook) {
	c.hooks.Room = append(c.hooks.Room, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `room.Intercept(f(g(h())))`.
func (c *RoomClient) Intercept(interceptors ...Interceptor) {
	c.inters.Room = append(c.inters.Room, interceptors...)
}

// Create returns a builder for creating a Room entity.
func (c *RoomClient) Create() *RoomCreate {
	mutation := newRoomMutation(c.config, OpCreate)
	return &RoomCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Room entities.
func (c *RoomClient) CreateBulk(builders ...*RoomCreate) *RoomCreateBulk {
	return &RoomCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Room.
func (c *RoomClient) Update() *RoomUpdate {
	mutation := newRoomMutation(c.config, OpUpdate)
	return &RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoomClient) UpdateOne(r *Room) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoom(r))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoomClient) UpdateOneID(id uuid.UUID) *RoomUpdateOne {
	mutation := newRoomMutation(c.config, OpUpdateOne, withRoomID(id))
	return &RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Room.
func (c *RoomClient) Delete() *RoomDelete {
	mutation := newRoomMutation(c.config, OpDelete)
	return &RoomDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoomClient) DeleteOne(r *Room) *RoomDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoomClient) DeleteOneID(id uuid.UUID) *RoomDeleteOne {
	builder := c.Delete().Where(room.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoomDeleteOne{builder}
}

// Query returns a query builder for Room.
func (c *RoomClient) Query() *RoomQuery {
	return &RoomQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Room entity by its id.
func (c *RoomClient) Get(ctx context.Context, id uuid.UUID) (*Room, error) {
	return c.Query().Where(room.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoomClient) GetX(ctx context.Context, id uuid.UUID) *Room {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Room.
func (c *RoomClient) QueryGames(r *Room) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(room.Table, room.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, room.GamesTable, room.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoomClient) Hooks() []Hook {
	return c.hooks.Room
}

// Interceptors returns the client interceptors.
func (c *RoomClient) Interceptors() []Interceptor {
	return c.inters.Room
}

func (c *RoomClient) mutate(ctx context.Context, m *RoomMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoomCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoomUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoomUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoomDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Room mutation op: %q", m.Op())
	}
}

// RoundClient is a client for the Round schema.
type RoundClient struct {
	config
}

// NewRoundClient returns a client for the Round from the given config.
func NewRoundClient(c config) *RoundClient {
	return &RoundClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `round.Hooks(f(g(h())))`.
func (c *RoundClient) Use(hooks ...Hook) {
	c.hooks.Round = append(c.hooks.Round, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `round.Intercept(f(g(h())))`.
func (c *RoundClient) Intercept(interceptors ...Interceptor) {
	c.inters.Round = append(c.inters.Round, interceptors...)
}

// Create returns a builder for creating a Round entity.
func (c *RoundClient) Create() *RoundCreate {
	mutation := newRoundMutation(c.config, OpCreate)
	return &RoundCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Round entities.
func (c *RoundClient) CreateBulk(builders ...*RoundCreate) *RoundCreateBulk {
	return &RoundCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Round.
func (c *RoundClient) Update() *RoundUpdate {
	mutation := newRoundMutation(c.config, OpUpdate)
	return &RoundUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoundClient) UpdateOne(r *Round) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRound(r))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoundClient) UpdateOneID(id uuid.UUID) *RoundUpdateOne {
	mutation := newRoundMutation(c.config, OpUpdateOne, withRoundID(id))
	return &RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Round.
func (c *RoundClient) Delete() *RoundDelete {
	mutation := newRoundMutation(c.config, OpDelete)
	return &RoundDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoundClient) DeleteOne(r *Round) *RoundDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoundClient) DeleteOneID(id uuid.UUID) *RoundDeleteOne {
	builder := c.Delete().Where(round.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoundDeleteOne{builder}
}

// Query returns a query builder for Round.
func (c *RoundClient) Query() *RoundQuery {
	return &RoundQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Round entity by its id.
func (c *RoundClient) Get(ctx context.Context, id uuid.UUID) (*Round, error) {
	return c.Query().Where(round.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoundClient) GetX(ctx context.Context, id uuid.UUID) *Round {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryGames queries the games edge of a Round.
func (c *RoundClient) QueryGames(r *Round) *GameQuery {
	query := (&GameClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(game.Table, game.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, round.GamesTable, round.GamesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHands queries the hands edge of a Round.
func (c *RoundClient) QueryHands(r *Round) *HandQuery {
	query := (&HandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(round.Table, round.FieldID, id),
			sqlgraph.To(hand.Table, hand.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, round.HandsTable, round.HandsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoundClient) Hooks() []Hook {
	return c.hooks.Round
}

// Interceptors returns the client interceptors.
func (c *RoundClient) Interceptors() []Interceptor {
	return c.inters.Round
}

func (c *RoundClient) mutate(ctx context.Context, m *RoundMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoundCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoundUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoundUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoundDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Round mutation op: %q", m.Op())
	}
}

// TurnClient is a client for the Turn schema.
type TurnClient struct {
	config
}

// NewTurnClient returns a client for the Turn from the given config.
func NewTurnClient(c config) *TurnClient {
	return &TurnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `turn.Hooks(f(g(h())))`.
func (c *TurnClient) Use(hooks ...Hook) {
	c.hooks.Turn = append(c.hooks.Turn, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `turn.Intercept(f(g(h())))`.
func (c *TurnClient) Intercept(interceptors ...Interceptor) {
	c.inters.Turn = append(c.inters.Turn, interceptors...)
}

// Create returns a builder for creating a Turn entity.
func (c *TurnClient) Create() *TurnCreate {
	mutation := newTurnMutation(c.config, OpCreate)
	return &TurnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Turn entities.
func (c *TurnClient) CreateBulk(builders ...*TurnCreate) *TurnCreateBulk {
	return &TurnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Turn.
func (c *TurnClient) Update() *TurnUpdate {
	mutation := newTurnMutation(c.config, OpUpdate)
	return &TurnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TurnClient) UpdateOne(t *Turn) *TurnUpdateOne {
	mutation := newTurnMutation(c.config, OpUpdateOne, withTurn(t))
	return &TurnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TurnClient) UpdateOneID(id uuid.UUID) *TurnUpdateOne {
	mutation := newTurnMutation(c.config, OpUpdateOne, withTurnID(id))
	return &TurnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Turn.
func (c *TurnClient) Delete() *TurnDelete {
	mutation := newTurnMutation(c.config, OpDelete)
	return &TurnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TurnClient) DeleteOne(t *Turn) *TurnDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TurnClient) DeleteOneID(id uuid.UUID) *TurnDeleteOne {
	builder := c.Delete().Where(turn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TurnDeleteOne{builder}
}

// Query returns a query builder for Turn.
func (c *TurnClient) Query() *TurnQuery {
	return &TurnQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Turn entity by its id.
func (c *TurnClient) Get(ctx context.Context, id uuid.UUID) (*Turn, error) {
	return c.Query().Where(turn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TurnClient) GetX(ctx context.Context, id uuid.UUID) *Turn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryHands queries the hands edge of a Turn.
func (c *TurnClient) QueryHands(t *Turn) *HandQuery {
	query := (&HandClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(turn.Table, turn.FieldID, id),
			sqlgraph.To(hand.Table, hand.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, turn.HandsTable, turn.HandsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGamePlayerPoints queries the game_player_points edge of a Turn.
func (c *TurnClient) QueryGamePlayerPoints(t *Turn) *GamePlayerPointQuery {
	query := (&GamePlayerPointClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(turn.Table, turn.FieldID, id),
			sqlgraph.To(gameplayerpoint.Table, gameplayerpoint.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, turn.GamePlayerPointsTable, turn.GamePlayerPointsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Turn.
func (c *TurnClient) QueryEvent(t *Turn) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(turn.Table, turn.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, turn.EventTable, turn.EventColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryGameplayerhandhai queries the gameplayerhandhai edge of a Turn.
func (c *TurnClient) QueryGameplayerhandhai(t *Turn) *GamePlayerHandHaiQuery {
	query := (&GamePlayerHandHaiClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(turn.Table, turn.FieldID, id),
			sqlgraph.To(gameplayerhandhai.Table, gameplayerhandhai.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, turn.GameplayerhandhaiTable, turn.GameplayerhandhaiColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TurnClient) Hooks() []Hook {
	return c.hooks.Turn
}

// Interceptors returns the client interceptors.
func (c *TurnClient) Interceptors() []Interceptor {
	return c.inters.Turn
}

func (c *TurnClient) mutate(ctx context.Context, m *TurnMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TurnCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TurnUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TurnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TurnDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Turn mutation op: %q", m.Op())
	}
}

// WinClient is a client for the Win schema.
type WinClient struct {
	config
}

// NewWinClient returns a client for the Win from the given config.
func NewWinClient(c config) *WinClient {
	return &WinClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `win.Hooks(f(g(h())))`.
func (c *WinClient) Use(hooks ...Hook) {
	c.hooks.Win = append(c.hooks.Win, hooks...)
}

// Use adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `win.Intercept(f(g(h())))`.
func (c *WinClient) Intercept(interceptors ...Interceptor) {
	c.inters.Win = append(c.inters.Win, interceptors...)
}

// Create returns a builder for creating a Win entity.
func (c *WinClient) Create() *WinCreate {
	mutation := newWinMutation(c.config, OpCreate)
	return &WinCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Win entities.
func (c *WinClient) CreateBulk(builders ...*WinCreate) *WinCreateBulk {
	return &WinCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Win.
func (c *WinClient) Update() *WinUpdate {
	mutation := newWinMutation(c.config, OpUpdate)
	return &WinUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WinClient) UpdateOne(w *Win) *WinUpdateOne {
	mutation := newWinMutation(c.config, OpUpdateOne, withWin(w))
	return &WinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WinClient) UpdateOneID(id uuid.UUID) *WinUpdateOne {
	mutation := newWinMutation(c.config, OpUpdateOne, withWinID(id))
	return &WinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Win.
func (c *WinClient) Delete() *WinDelete {
	mutation := newWinMutation(c.config, OpDelete)
	return &WinDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WinClient) DeleteOne(w *Win) *WinDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WinClient) DeleteOneID(id uuid.UUID) *WinDeleteOne {
	builder := c.Delete().Where(win.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WinDeleteOne{builder}
}

// Query returns a query builder for Win.
func (c *WinClient) Query() *WinQuery {
	return &WinQuery{
		config: c.config,
		inters: c.Interceptors(),
	}
}

// Get returns a Win entity by its id.
func (c *WinClient) Get(ctx context.Context, id uuid.UUID) (*Win, error) {
	return c.Query().Where(win.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WinClient) GetX(ctx context.Context, id uuid.UUID) *Win {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a Win.
func (c *WinClient) QueryEvent(w *Win) *EventQuery {
	query := (&EventClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(win.Table, win.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, win.EventTable, win.EventColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WinClient) Hooks() []Hook {
	return c.hooks.Win
}

// Interceptors returns the client interceptors.
func (c *WinClient) Interceptors() []Interceptor {
	return c.inters.Win
}

func (c *WinClient) mutate(ctx context.Context, m *WinMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WinCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WinUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WinDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Win mutation op: %q", m.Op())
	}
}
